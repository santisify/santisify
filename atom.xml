<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Santisify</title>
  <icon>https://blog.lazy-boy-acmer.cn/icon.png</icon>
  <subtitle>菜就多练 练就不菜</subtitle>
  <link href="https://blog.lazy-boy-acmer.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.lazy-boy-acmer.cn/"/>
  <updated>2025-08-22T02:37:23.079Z</updated>
  <id>https://blog.lazy-boy-acmer.cn/</id>
  
  <author>
    <name>santisify</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(2025)第十三届重庆市大学生程序设计竞赛</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/737bd1f1.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/737bd1f1.html</id>
    <published>2025-05-12T12:39:06.000Z</published>
    <updated>2025-08-22T02:37:23.079Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/105887">codeforces补题链接</a><br><a href="https://codeforces.com/gym/105887/attachments/download/31526/cqcpc2025.pdf">题面链接</a></p><h1>A</h1><h2 id="题目描述">题目描述</h2><blockquote><p>给定一个长度为 $n$ 的一个数组$A$，对于数组$A$会有$T$轮操作,第$i$轮操作操作如下：</p><p>$A_{j} \gets A_{i} | A_{(i+j) \mod n}$<br>经过多少轮，可以使得这个数组所有数相同？</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>将数拆分为二进制,对于每个数的某一位,至少存在一个 $1$, 进行一次操作，可产生一个 $1$, 第二次操作可产生两个$1$，依次进行，可产生$1 + 1 + 2 + 3 + \cdots + i$个 $1$，那么我们就可以暴力枚举一下，复杂度为$O(n \sqrt(n))$<br>起始也可以大胆猜想下，至多执行 $\log_{2}n$ 次就可以使得数组的数相同。</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">500</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n; j ++) &#123;</span><br><span class="line">            a[j] |= a[(j + i) % n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n - <span class="number">1</span>;j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] != a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                f = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!f) &#123;</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C</h1><h2 id="题目描述-2">题目描述</h2><blockquote><p>给出数字$n$,构造一个$n \times n$的方格图，方格中划分区域，每个区域的颜色相同，相邻区域的颜色不同，现在要用最少的颜色填土涂区域。<br>问：如何填涂可以使得所用的最少颜色数最大？</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>要使得最少的颜色数最大，无非就是以下方式填涂：</p><p>$(1,2),(1,3), \cdots , (1,n), (2,1), (2,3), \cdots , (n, n-1)$</p><p>就是让$1~n$中的数两个相邻。</p><p>还有一种思路就是对于每一行的构造，我们可以将$1~n$的上升序列进行$i$的右移($i$代表行数)<br>这样的移动满足题面要求的期望还是极高的, 正解为第一种，第二种期望值较高,也可满足(不要问我为什么知道，问就是打表发现的)</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1ll</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n;i ++) &#123;</span><br><span class="line">        std::<span class="built_in">rotate</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + i, a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n; j ++) &#123;</span><br><span class="line">            std::cout &lt;&lt; a[j] &lt;&lt; <span class="string">&quot; \n&quot;</span>[j == n - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>F</h1><h2 id="题面描述">题面描述</h2><blockquote><p>给出三个数$a, b, c$，根据三个数的大小关系输出:</p><ul><li>$a &gt; b$ ,输出$Win$;</li><li>$a \le b , c &gt; b$ ,输出$WIN$</li><li>$a \le b , c \le b$，输出$nowin$</li></ul></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    std::cout &lt;&lt; (a &gt; b ? <span class="string">&quot;Win&quot;</span> : (c &gt; b ? <span class="string">&quot;WIN&quot;</span> : <span class="string">&quot;nowin&quot;</span>)) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H</h1><h2 id="题目描述-3">题目描述</h2><blockquote><p>给出三个长度为$n$的数组$A,B,C$,数组$A,B$是长度为$n$的排列，代表一个盒子中的上边界和下边界小球的排序，数组$C$代表上边界小球是否靠边($C_{i}=0 \to$ 小球$i$不靠上边界，反之，则靠上边界)。</p><p>现在需要将编号相同的小球用绳子连起来(绳子是可任意变换形状的，长度也是任意长度的，绳子不可越出盒子边界)，若绳子相交，则输出$No$,否则输出$Yes$。</p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>既然绳子是任意长度的,那么对于上边界没有靠边的球，可以直接连接起来，就算中间有靠边界的球相连，总有方式绕过。<br>那么，只剩下靠上边界的球需要考虑，不难发现上下边界的球需要序列相同才能满足相连不相交。<br>那么就只需要处理出那些球紧靠上边界即可</p></blockquote><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span>, <span class="title">c</span><span class="params">(n)</span>, x, y</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) std::cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) std::cin &gt;&gt; c[i];</span><br><span class="line"></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt;se;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]) x.<span class="built_in">push_back</span>(a[i]), se.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(se.<span class="built_in">count</span>(b[i]) ) &#123;</span><br><span class="line">            y.<span class="built_in">push_back</span>(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (x == y ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>L</h1><h2 id="题目描述-4">题目描述</h2><blockquote><p>模拟一个栈的操作，操作$n$次，操作如下：</p><ul><li>Push $x$: 将$x$压入栈。</li><li>Pop: 弹出栈顶元素。</li><li>Repeat: 将此前的操作重复，不包含当前操作。</li></ul><p>每次操作都输出栈的元素总和，结果$ \mod 998244353$。<br>$1 \le n \le 2 \times 10^5, 0 \le x \le 998244353$</p></blockquote><h2 id="解题思路-4">解题思路</h2><blockquote><p>首先模拟操作即可，但需要注意，当栈的大小大于 $2 \times 10^5$时，就不需要执行Repeat操作，斌且需要用数组模拟栈。</p></blockquote><h2 id="参考代码-5">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, res = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++) &#123;</span><br><span class="line">        std::string s;</span><br><span class="line">        std::cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;Push&quot;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            std::cin &gt;&gt; x;</span><br><span class="line">            q.<span class="built_in">push_back</span>(x);</span><br><span class="line">            res = (res + x + MOD) % MOD;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;Pop&quot;</span>) &#123;</span><br><span class="line">            res = (res - q.<span class="built_in">back</span>() + MOD) % MOD;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res = (((res + res)%MOD) + MOD) %MOD;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>() &lt; <span class="number">2e5</span>) &#123;</span><br><span class="line">                <span class="type">int</span> t = q.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; t; i ++) &#123;</span><br><span class="line">                    q.<span class="built_in">push_back</span>(q[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; res % MOD &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T --) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">A,C,F,H,L</summary>
    
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>2025省赛预选赛补题</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/86ca1ebf.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/86ca1ebf.html</id>
    <published>2025-04-27T13:57:52.000Z</published>
    <updated>2025-08-22T02:37:23.079Z</updated>
    
    <content type="html"><![CDATA[<p>(cf补题链接)[<a href="https://codeforces.com/gym/606649">https://codeforces.com/gym/606649</a>]</p><h1>H</h1><h2 id="题目描述">题目描述</h2><blockquote><p>给定三个数组$A$, $B$, $C$,长度分别为 $n$, $m$, $p$,每个数组取一个数求和，输出前$k$个最大值。</p><p>数据范围： $l \le n,m,p \le 1000$, $1 \le k \le min(3000, n \times m \times p)$ , $0 \le A_{i}, B_{i}, C_{i} \le  10000000000$</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>首先想到的最简单的思路是暴力求解，这样的时间复杂度将会是$1e^{9} \log_{2} ^{1e^{9}}$ ，如何优化呢？<br>我们可以将其中两个数组合并，这里我们选择将$A, B$ 两个数组合并，然后进行排序，这里复杂度为$1e^{6}\log_{2}^{1e^{6}}$,  我么选择合并后的前$k$个最大值和数组$C$合并，这里的复杂度为$3e^{3} \times 1e^{3}$, 可以用堆维护$k$个数。</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m, p, k;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(m)</span>, <span class="title">c</span><span class="params">(p)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) std::cin &gt;&gt; b[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p; i++) std::cin &gt;&gt; c[i];</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; ab;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      ab.<span class="built_in">push_back</span>(a[i] + b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(ab.<span class="built_in">begin</span>(), ab.<span class="built_in">end</span>(), std::greater&lt;&gt;());</span><br><span class="line">  std::<span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), std::greater&lt;&gt;());</span><br><span class="line">  std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;&gt; &gt; pq;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; std::<span class="built_in">min</span>(k, (<span class="type">int</span>) ab.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; p; j++) &#123;</span><br><span class="line">      <span class="type">int</span> t = ab[i] + c[j];</span><br><span class="line">      <span class="keyword">if</span> (pq.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        <span class="keyword">auto</span> w = pq.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (w &lt; t) &#123;</span><br><span class="line">          pq.<span class="built_in">pop</span>();</span><br><span class="line">          pq.<span class="built_in">push</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i : res) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E</h1><h2 id="题目描述-2">题目描述</h2><blockquote><p>给定一个长度为$n$的数组$A$, 有$q$次询问,每次给出$l, r, start, end$, 对于每次询问，我们要输出$A$中在区间段$[l,r]$中,$start \le A_{i} \le end$的数的个数。</p><p>数据范围：$1 \le N, q \le 10^{5}, -10^{12} \le A_{i} \le 10^{12}$</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>赛时，我想的是对区间内的数排序,然后二分查找边界,计算数量,奈何<code>TLE</code>,tql,显然是排序超时了。<br>正解是树状数组或者线段树</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(MAX_N)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> l&#123;&#125;, r&#123;&#125;;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; sorted;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node tr[<span class="number">4</span> * MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  tr[u].l = l;</span><br><span class="line">  tr[u].r = r;</span><br><span class="line">  tr[u].sorted.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    tr[u].sorted.<span class="built_in">push_back</span>(a[l]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">  <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="keyword">auto</span> &amp;left = tr[u &lt;&lt; <span class="number">1</span>].sorted;</span><br><span class="line">  <span class="keyword">auto</span> &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sorted;</span><br><span class="line">  tr[u].sorted.<span class="built_in">resize</span>(left.<span class="built_in">size</span>() + right.<span class="built_in">size</span>());</span><br><span class="line">  <span class="built_in">merge</span>(left.<span class="built_in">begin</span>(), left.<span class="built_in">end</span>(), right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>(), tr[u].sorted.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tr[u].r &lt; l || tr[u].l &gt; r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;v = tr[u].sorted;</span><br><span class="line">    <span class="type">int</span> left_pos = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), start) - v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> right_pos = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), end) - v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> right_pos - left_pos;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r, start, end) + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> N, Q;</span><br><span class="line">  std::cin &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line">  <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">    <span class="type">int</span> l, r, s, e;</span><br><span class="line">    std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; s &gt;&gt; e;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r, s, e) &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">2025年省赛预选赛补题，由成都信息工程大学出题。</summary>
    
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>电子科大校赛初赛Code</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/ff99f411.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/ff99f411.html</id>
    <published>2025-03-31T11:51:20.000Z</published>
    <updated>2025-08-22T02:37:23.083Z</updated>
    
    <content type="html"><![CDATA[<h1>C 箭串</h1><p><a href="https://cdoj.site/d/lutece/p/Lutece3389">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;parent, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">    parent[x] = parent[parent[x]];</span><br><span class="line">    x = parent[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="function">std::vector&lt;pii &gt; <span class="title">ops</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> p, l;</span><br><span class="line">    std::cin &gt;&gt; p &gt;&gt; l;</span><br><span class="line">    ops[i] = &#123;p, l&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    parent[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">last_p</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">last_l</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k = m - <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">    <span class="type">int</span> p = ops[k].first;</span><br><span class="line">    <span class="type">int</span> l = ops[k].second;</span><br><span class="line">    <span class="type">int</span> a = p;</span><br><span class="line">    <span class="type">int</span> b = p + l - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> current = a;</span><br><span class="line">    <span class="keyword">while</span> (current &lt;= b) &#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="built_in">find</span>(parent, current);</span><br><span class="line">      <span class="keyword">if</span> (i &gt; b) <span class="keyword">break</span>;</span><br><span class="line">      last_p[i] = p;</span><br><span class="line">      last_l[i] = l;</span><br><span class="line">      <span class="type">int</span> next_parent = <span class="built_in">find</span>(parent, i + <span class="number">1</span>);</span><br><span class="line">      parent[i] = next_parent;</span><br><span class="line">      current = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">res</span><span class="params">(n, <span class="string">&#x27;*&#x27;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (last_p[i] != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">int</span> pos = i - last_p[i] + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> l = last_l[i];</span><br><span class="line">      <span class="keyword">if</span> (pos == <span class="number">1</span>) &#123;</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt;= l - <span class="number">3</span>) &#123;</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; res.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D 阿罗祖斯坦的桥</h1><p><a href="https://cdoj.site/d/lutece/p/Lutece3390">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">angle</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> </span>&#123; <span class="comment">// c</span></span><br><span class="line">  <span class="type">double</span> res = (a * a + b * b - c * c) / (<span class="number">2</span> * a * b);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">acos</span>(std::<span class="built_in">max</span>(<span class="number">-1.0</span>, std::<span class="built_in">min</span>(<span class="number">1.0</span>, res)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">double</span> r;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; r;</span><br><span class="line">  r /= <span class="number">2.0</span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i];</span><br><span class="line">    a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res += r * <span class="built_in">angle</span>(r, r, a[i + <span class="number">1</span>] - a[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res += r * <span class="built_in">angle</span>(r, r, a[i] - a[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">fix</span>(<span class="number">12</span>) &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>F 我知道你姓啥</h1><p><a href="https://cdoj.site/d/lutece/p/Lutece3392">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bit_length</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">32</span> - __builtin_clz(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; s[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::unordered_map&lt;std::string, <span class="type">int</span>&gt; ump;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      str.<span class="built_in">push_back</span>(s[i][j]);</span><br><span class="line">    ump[str]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ma = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> [x, cnt] : ump) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">bit_length</span>(cnt - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (t &gt; ma) ma = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ma &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G 猜数游戏</h1><p><a href="https://cdoj.site/d/lutece/p/Lutece3393">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//x % p = a; l &lt;= x &lt;= r</span></span><br><span class="line">  i64 a, p, l, r;</span><br><span class="line">  std::cin &gt;&gt; a &gt;&gt; p &gt;&gt; l &gt;&gt; r;</span><br><span class="line">  i64 ans = ((l / p)) * p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ans + a &gt;= l &amp;&amp; ans + a &lt;= r) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans + a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ans += p;</span><br><span class="line">  <span class="keyword">if</span> (ans + a &gt;= l &amp;&amp; ans + a &lt;= r) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans + a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H 独立事件</h1><p><a href="https://cdoj.site/d/lutece/p/Lutece3394">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">    i64 ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      ans = ans * <span class="number">2</span> % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> sum_A = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    sum_A += a[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sum_A == <span class="number">1000</span>) &#123;</span><br><span class="line">    i64 ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      ans = ans * <span class="number">2</span> % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> sum_nA = <span class="number">1000</span> - sum_A;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dp_A</span><span class="params">(sum_A + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  dp_A[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> ai = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = sum_A; j &gt;= ai; --j) &#123;</span><br><span class="line">      dp_A[j] = (dp_A[j] + dp_A[j - ai]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dp_nA</span><span class="params">(sum_nA + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  dp_nA[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> ai = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = sum_nA; j &gt;= ai; --j) &#123;</span><br><span class="line">      dp_nA[j] = (dp_nA[j] + dp_nA[j - ai]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i64 ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt;= sum_A; ++x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp_A[x] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    i64 t = (<span class="number">1000LL</span> - sum_A) * x;</span><br><span class="line">    <span class="keyword">if</span> (t % sum_A != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> y = t / sum_A;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span> || y &gt; sum_nA) <span class="keyword">continue</span>;</span><br><span class="line">    ans = (ans + <span class="number">1LL</span> * dp_A[x] * dp_nA[y]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I 圆与直线交点</h1><p><a href="https://cdoj.site/d/lutece/p/Lutece3395">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="type">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Point</span><span class="params">(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>)</span> : x(x), y(y) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">  Point p, v;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Line</span><span class="params">(Point p = Point(), Point v = Point())</span> : p(p), v(v) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  Point c;</span><br><span class="line">  <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Circle</span><span class="params">(Point c = Point(), <span class="type">double</span> r = <span class="number">0</span>)</span> : c(c), r(r) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">waixin</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> a1 = <span class="number">2</span> * (b.x - a.x), b1 = <span class="number">2</span> * (b.y - a.y), c1 = (b.x * b.x + b.y * b.y - a.x * a.x - a.y * a.y);</span><br><span class="line">  <span class="type">double</span> a2 = <span class="number">2</span> * (c.x - a.x), b2 = <span class="number">2</span> * (c.y - a.y), c2 = (c.x * c.x + c.y * c.y - a.x * a.x - a.y * a.y);</span><br><span class="line">  <span class="type">double</span> d = a1 * b2 - a2 * b1, h = (c1 * b2 - c2 * b1) / d, k = (a1 * c2 - a2 * c1) / d;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Point</span>(h, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getLineCircleIntersection</span><span class="params">(Line L, Circle C)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> a = L.v.x, b = L.p.x - C.c.x;</span><br><span class="line">  <span class="type">double</span> c = L.v.y, d = L.p.y - C.c.y;</span><br><span class="line">  <span class="type">double</span> e = a * a + c * c;</span><br><span class="line">  <span class="type">double</span> f = <span class="number">2</span> * (a * b + c * d);</span><br><span class="line">  <span class="type">double</span> g = b * b + d * d - C.r * C.r;</span><br><span class="line">  <span class="type">double</span> delta = f * f - <span class="number">4</span> * e * g;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-3</span>;</span><br><span class="line">  <span class="keyword">if</span> (delta &lt; -eps) <span class="keyword">return</span> <span class="string">&quot;No&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(delta) &lt; eps) <span class="keyword">return</span> <span class="string">&quot;Or&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Point a[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : a) std::cin &gt;&gt; i.x &gt;&gt; i.y;</span><br><span class="line">  Point center = <span class="built_in">waixin</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">double</span> r = <span class="built_in">hypot</span>(center.x - a[<span class="number">0</span>].x, center.y - a[<span class="number">0</span>].y);</span><br><span class="line">  <span class="function">Circle <span class="title">cir</span><span class="params">(center, r)</span></span>;</span><br><span class="line">  Point p, v;</span><br><span class="line">  std::cin &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; v.x &gt;&gt; v.y;</span><br><span class="line">  Line L = <span class="built_in">Line</span>(p, v);</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">getLineCircleIntersection</span>(L, cir) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J 创建用户</h1><p><a href="https://cdoj.site/d/lutece/p/Lutece3396">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::map&lt;std::string, <span class="type">int</span>&gt; mp;</span><br><span class="line">  std::string s;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  std::cin.<span class="built_in">ignore</span>();</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    std::<span class="built_in">getline</span>(std::cin, s);</span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        str.<span class="built_in">push_back</span>(i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((pos = s.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>, pos + <span class="number">1</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">      str.<span class="built_in">push_back</span>(s[pos + <span class="number">1</span>]);</span><br><span class="line">      pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">count</span>(str)) &#123;</span><br><span class="line">      std::string t = std::<span class="built_in">to_string</span>(mp[str] + <span class="number">1</span>);</span><br><span class="line">      mp[str]++;</span><br><span class="line">      str.<span class="built_in">insert</span>(str.<span class="built_in">size</span>(), t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mp[str] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>N 幸运之环 II</h1><p><a href="https://cdoj.site/d/lutece/p/Lutece3400">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">a</span>(n + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">deg</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    a[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    a[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    deg[u]++, deg[v]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deg[i] == <span class="number">1</span>) &#123;</span><br><span class="line">      q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : a[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (deg[v] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        deg[v]--;</span><br><span class="line">        <span class="keyword">if</span> (deg[v] == <span class="number">1</span>) &#123;</span><br><span class="line">          q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> node = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deg[i] &gt;= <span class="number">2</span> &amp;&amp; !node) node = i;</span><br><span class="line">    std::<span class="built_in">sort</span>(a[i].<span class="built_in">begin</span>(), a[i].<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  res.<span class="built_in">push_back</span>(node);</span><br><span class="line">  q.<span class="built_in">push</span>(node);</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : a[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (deg[v] &gt;= <span class="number">2</span> &amp;&amp; !vis[v]) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; res.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i : res) std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>O 不走回头路</h1><p><a href="https://cdoj.site/d/lutece/p/Lutece3401">题目传送门</a></p><blockquote><p>error code</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e17</span> + <span class="number">50</span>, MAXN = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; adj;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; disc, low, scc, stt;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">int</span> ct_scc, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  disc[u] = low[u] = ++cnt;</span><br><span class="line">  stk.<span class="built_in">push</span>(u);</span><br><span class="line">  stt[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!disc[v]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v);</span><br><span class="line">      low[u] = std::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stt[v]) &#123;</span><br><span class="line">      low[u] = std::<span class="built_in">min</span>(low[u], disc[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (low[u] == disc[u]) &#123;</span><br><span class="line">    ct_scc++;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">int</span> x = stk.<span class="built_in">top</span>();</span><br><span class="line">      stk.<span class="built_in">pop</span>();</span><br><span class="line">      stt[x] = <span class="number">0</span>;</span><br><span class="line">      scc[x] = ct_scc;</span><br><span class="line">      <span class="keyword">if</span> (x == u) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  adj = std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt;(n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, u, v; i &lt; m; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  disc.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  low.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  scc.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  stt.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  ct_scc = cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!disc[i]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(ct_scc + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">out</span><span class="params">(ct_scc + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  std::unordered_map&lt;<span class="type">int</span>, std::unordered_set&lt;<span class="type">int</span>&gt; &gt; mp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">      <span class="type">int</span> su = scc[u], sv = scc[v];</span><br><span class="line">      <span class="keyword">if</span> (su != sv &amp;&amp; !mp[su].<span class="built_in">count</span>(sv)) &#123;</span><br><span class="line">        mp[su].<span class="built_in">insert</span>(sv);</span><br><span class="line">        out[su]++;</span><br><span class="line">        in[sv]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ct1 = <span class="number">0</span>, ct2 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ct_scc; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (in[i] == <span class="number">0</span>) ct1++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (in[i] != <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (out[i] == <span class="number">0</span>) ct2++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (out[i] != <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flag &amp;= (ct1 == <span class="number">1</span>) &amp;&amp; (ct2 == <span class="number">1</span>);</span><br><span class="line">  std::cout &lt;&lt; (flag ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">2025年电子科技大学校赛初赛-参考代码</summary>
    
    
    
    <category term="算法比赛" scheme="https://blog.lazy-boy-acmer.cn/categories/%E7%AE%97%E6%B3%95%E6%AF%94%E8%B5%9B/"/>
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/categories/%E7%AE%97%E6%B3%95%E6%AF%94%E8%B5%9B/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>主流API设计风格Restful-API</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/5bd2dc50.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/5bd2dc50.html</id>
    <published>2025-03-21T08:36:32.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<h1>API请求</h1><h2 id="HTTP动词">HTTP动词</h2><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">GET</span><span class="punctuation">: </span>    读取（READ）</span><br><span class="line"><span class="attribute">POST</span><span class="punctuation">: </span>   新建（CREATE）</span><br><span class="line"><span class="attribute">PUT</span><span class="punctuation">: </span>    更新（UPDATE）</span><br><span class="line"><span class="attribute">DELETE</span><span class="punctuation">: </span> 删除（DELETE）</span><br></pre></td></tr></table></figure><blockquote><p>PATCH 部分更新</p></blockquote><h2 id="URL宾语">URL宾语</h2><p><strong>宾语</strong> 顾名思义，是一个名词，<code>URL</code>作为<code>API</code>的宾语是作用<code>HTTP</code>的对象，普遍以复数形式存在.</p><p>以下为错误示例：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/getAllCars</span><br><span class="line">/createNewCar</span><br><span class="line">/deleteAllRedCars</span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/aticles</span><br><span class="line">/users</span><br><span class="line">/cars</span><br></pre></td></tr></table></figure><h3 id="煮个栗子">煮个栗子</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET    /zoos：列出所有动物园</span><br><span class="line">POST   /zoos：新建一个动物园</span><br><span class="line">GET    /zoos/ID：获取某个指定动物园的信息</span><br><span class="line">PUT    /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH  /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE /zoos/ID：删除某个动物园</span><br><span class="line">GET    /zoos/ID/animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure><h2 id="过滤（filter）">过滤（filter）</h2><p>通常在数据库中存储着许多数据，我们不可能将所有数据返回给用户，而是选择性的将一些数据返回给用户，而<code>API</code>就应该提供一些参数，过滤返回的结果。</p><p>下面是一些常见的参数。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br></pre></td></tr></table></figure><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，<code>GET /zoo/ID/animals</code> 与 <code>GET /animals?zoo_id=ID</code> 的含义是相同的。</p><h2 id="不符合-CRUD-情况的-RESTful-API">不符合 CRUD 情况的 RESTful API</h2><p>在实际资源操作中，总会有一些不符合 CRUD 的情况，一般有几种处理方法。</p><ul><li>1、使用 POST，为需要的动作增加一个 endpoint，使用 POST 来执行动作，比如: POST /resend 重新发送邮件。</li><li>2、增加控制参数，添加动作相关的参数，通过修改参数来控制动作。比如一个博客网站，会有把写好的文章“发布”的功能，可以用上面的 <code>POST /articles/&#123;:id&#125;/publish</code> 方法，也可以在文章中增加 <code>published:boolean</code> 字段，发布的时候就是更新该字段 <code>PUT /articles/&#123;:id&#125;?published=true</code></li><li>3、把动作转换成资源，把动作转换成可以执行 CRUD 操作的资源， github 就是用了这种方法。<br>比如“喜欢”一个 gist，就增加一个 <code>/gists/:id/star</code> 子资源，然后对其进行操作：“喜欢”使用<code>PUT /gists/:id/star</code>，“取消喜欢”使用 <code>DELETE /gists/:id/star</code>。<br>另外一个例子是 Fork，这也是一个动作，但是在 gist 下面增加 forks资源，就能把动作变成 CRUD 兼容的：<code>POST /gists/:id/forks</code> 可以执行用户 fork 的动作。</li></ul><h2 id="动词覆盖，应对服务器不完全支持-HTTP-的情况">动词覆盖，应对服务器不完全支持 HTTP 的情况</h2><p>有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。<br>这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p><h1>API响应</h1><h2 id="状态码">状态码</h2><h3 id="2xx-状态码">2xx 状态码</h3><p><code>200</code>状态码也称成功状态码，但是对于不同的方法又有不同的状态码</p><ul><li>GET --&gt; <code>200</code> OK</li><li>POST–&gt; <code>201</code> Created（表示生成新的资源）</li><li>PUT --&gt; <code>200</code> OK</li><li>PATCH --&gt; <code>200</code> OK</li><li>DELETE --&gt; <code>204</code> No Content（表示该资源已不存在）</li></ul><h3 id="3xx-状态码">3xx 状态码</h3><p>在<strong>Restful API</strong>中用不上，永久重定向（<code>301</code>）、暂时重定向（<code>302</code>、<code>307</code>）可由应用级别返回，浏览器直接跳转。<br>主要使用<code>303</code> see other，以表示参考另一个URL，它与302和307的含义一样，也是”暂时重定向”，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。</p><h3 id="4xx-状态码">4xx 状态码</h3><p><code>4xx</code> 状态码表示客户端错误，主要有下面几种：</p><ol><li><code>400</code> --&gt; Bad Request：服务器不理解客户端的请求，未做任何处理。</li><li><code>401</code> --&gt; Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</li><li><code>403</code> --&gt; Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</li><li><code>404</code> --&gt; Not Found：所请求的资源不存在，或不可用。</li><li><code>405</code> --&gt; Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</li><li><code>410</code> --&gt; Gone：所请求的资源已从这个地址转移，不再可用。</li><li><code>415</code> --&gt; Unsupported Media Type：客户端要求的返回格式不支持。比如，客户端要求返回XML格式，API只能返回JSON格式。</li><li><code>422</code> --&gt; Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</li><li><code>429</code> --&gt; Too Many Requests：客户端的请求次数超过限额。</li></ol><h3 id="5xx-状态码">5xx 状态码</h3><p><code>5xx</code>状态码表示服务端错误。一般来说，<strong>API</strong>不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p><ol><li><code>500</code> --&gt; Internal Server Error：客户端请求有效，服务器处理时发生了意外。</li><li><code>503</code> --&gt; Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</li></ol><h2 id="返回数据">返回数据</h2><p>以下事项均为注意事项，不要问为什么，因为站长在学之前全都犯过。</p><h3 id="不要返回纯本文">不要返回纯本文</h3><p><code>API</code> 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的<strong>Content-Type</strong>属性要设为<code>application/json</code>。<br>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成<code>application/json</code>。</p><h3 id="不要包装数据">不要包装数据</h3><p>response 的 body直接就是数据，不要做多余的包装。错误实例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;周伯通&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET    /collection：返回资源对象的列表（数组）</span><br><span class="line">GET    /collection/resource：返回单个资源对象</span><br><span class="line">POST   /collection：返回新生成的资源对象</span><br><span class="line">PUT    /collection/resource：返回完整的资源对象</span><br><span class="line">PATCH  /collection/resource：返回完整的资源对象</span><br><span class="line">DELETE /collection/resource：返回一个空文档</span><br></pre></td></tr></table></figure><h3 id="发生错误时，不要返回-200-状态码">发生错误时，不要返回 200 状态码</h3><p>有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面，就像下面这样。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;failure&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Expected at least two items in list.&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">400</span> Bad Request</span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Invalid payoad.&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;surname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This field is required.&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于主流API设计风格Restful API的学习</summary>
    
    
    
    <category term="技术" scheme="https://blog.lazy-boy-acmer.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="API" scheme="https://blog.lazy-boy-acmer.cn/categories/%E6%8A%80%E6%9C%AF/API/"/>
    
    
    <category term="Restful API" scheme="https://blog.lazy-boy-acmer.cn/tags/Restful-API/"/>
    
  </entry>
  
  <entry>
    <title>Vue学习笔记（二）</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/9a8dd726.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/9a8dd726.html</id>
    <published>2025-03-15T03:06:32.000Z</published>
    <updated>2025-08-22T02:37:23.082Z</updated>
    
    <content type="html"><![CDATA[<h1>组件基础</h1><h2 id="组件定义">组件定义</h2><p>Vue组件定义在一个<code>.vue</code>的文件中，被称为单文件组件<code>SFC</code> :</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>You clicked me &#123;&#123; count &#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件使用">组件使用</h2><p>若要使用一个子组件，需要在父组件中导入。假设我们把计数器组件放在了一个叫做 <code>ButtonCounter.vue</code> 的文件中，这个组件将会以默认导出的形式被暴露给外部：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ButtonCounter</span> <span class="keyword">from</span> <span class="string">&#x27;./ButtonCounter.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here is a child component!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ButtonCounter</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若是通过 <code>&lt;script setup&gt;</code> 导入的组件，可以在<code>&lt;template&gt; &lt;/template&gt;</code> 中直接使用。同时，一个组件可在同一个模板中引用多次：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ButtonCounter</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ButtonCounter</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ButtonCounter</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于以上的示例，每个<code>ButtonCounter</code> 组件在进行点击后不会影响其余的组件，因为每个组件都是维护自己的状态，每当我使用一个组件就新创建一个实例。</p><h2 id="传递-props">传递 props</h2><p>如果我们正在构建一个博客，我们可能需要一个表示博客文章的组件。我们希望所有的博客文章分享相同的视觉布局，但有不同的内容。要实现这样的效果自然必须向组件中传递数据，例如每篇文章标题和内容，这就会使用到 props。</p><p>Props 是一种特别的 attributes，你可以在组件上声明注册。要传递给博客文章组件一个标题，我们必须在组件的 props 列表上声明它。这里要用到 <code>defineProps</code> 宏：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- BlogPost.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;title&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>defineProps</code> 是一个仅 <code>&lt;script setup&gt;</code> 中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板。<code>defineProps</code> 会返回一个对象，其中包含了可以传递给组件的所有 props：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">title</span>)</span><br></pre></td></tr></table></figure><p>一个组件可以有任意多的 props，默认情况下，所有 prop 都接受任意类型的值。<br>当一个 prop 被注册后，可以像这样以自定义 attribute 的形式传递数据给它：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">title</span>=<span class="string">&quot;My journey with Vue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">title</span>=<span class="string">&quot;Blogging with Vue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">title</span>=<span class="string">&quot;Why Vue is so fun&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在实际应用中，我们可能在父组件中会有如下的一个博客文章数组：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> posts = <span class="title function_">ref</span>([</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;My journey with Vue&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;Blogging with Vue&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&#x27;Why Vue is so fun&#x27;</span> &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>这种情况下，我们可以使用 <code>v-for</code> 来渲染它们：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:key</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">&quot;post.title&quot;</span></span></span><br><span class="line"><span class="tag"> /&gt;</span></span><br></pre></td></tr></table></figure><p>留意我们是如何使用 <code>v-bind</code> 语法(<code>:title=&quot;post.title&quot;</code>) 来传递动态 prop 值的。当事先不知道要渲染的确切内容时，这一点特别有用。</p><h2 id="监听事件">监听事件</h2>]]></content>
    
    
    <summary type="html">组件基础，props（父组件 -&gt; 子组件），监听事件</summary>
    
    
    
    <category term="技术" scheme="https://blog.lazy-boy-acmer.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="vue" scheme="https://blog.lazy-boy-acmer.cn/categories/%E6%8A%80%E6%9C%AF/vue/"/>
    
    
    <category term="vue" scheme="https://blog.lazy-boy-acmer.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue学习笔记（一）</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/aa9b3bfe.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/aa9b3bfe.html</id>
    <published>2025-03-10T01:47:53.000Z</published>
    <updated>2025-08-22T02:37:23.082Z</updated>
    
    <content type="html"><![CDATA[<p>部分示例来源于<a href="https://cn.vuejs.org/">vuejs中文官网</a></p><p><strong>Vue3对Vue2向下兼容，但部分不兼容</strong></p><h1>语法</h1><h2 id="文本插值：">文本插值：</h2><p>在<code>HTML</code>中插入文本</p><figure class="highlight html"><figcaption><span><span>Message: &#123;&#123; msg &#125;&#125;</span></span></figcaption><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## HTML插值：</span><br><span class="line"></span><br><span class="line">上述操作只能插入纯文本，可以使用`v-html`插入`html`文本</span><br><span class="line"></span><br><span class="line">```html  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Using text interpolation: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Attribute-绑定">Attribute <strong>绑定</strong></h2><p>对使用的元素属性进行绑定  想响应式绑定一个Attribute,但又不能使用<code>&#123;&#123;  &#125;&#125;</code>时,可使用<code>v-bind</code>指令：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;num&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>v-bind</code>指令指示 Vue 将元素的<code>id</code>attribute 与组件的<code>num</code>属性保持一致。如果绑定的值是<code>null</code>或者<code>undefined</code>，那么该  attribute 将会从渲染的元素上移除。  简写：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">&quot;num&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//点击方块后颜色切换，其中click和ref会在下面会讲到</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px; width: 100px;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;switchColor&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;str&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> str = <span class="title function_">ref</span>(<span class="string">&quot;su&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">switchColor</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">str.<span class="property">value</span> = <span class="string">&quot;s&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.su</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.s</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可设为bool型数据</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当<code>isButtonDisabled</code>为<a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">真值</a>或一个空字符串 (即<br><code>&lt;button disabled=&quot;&quot;&gt;</code>) 时，元素会包含这个<code>disabled</code>  attribute。而当其为其他<a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">假值</a>时 attribute 将被忽略。</p><h2 id="动态绑定多个值">动态绑定多个值</h2><p>如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objectOfAttrs = &#123;</span><br><span class="line"><span class="attr">id</span>: <span class="string">&#x27;container&#x27;</span>,</span><br><span class="line"><span class="attr">class</span>: <span class="string">&#x27;wrapper&#x27;</span>,</span><br><span class="line"><span class="attr">style</span>: <span class="string">&#x27;background-color:green&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过不带参数的<code>v-bind</code>，你可以将它们绑定到单个元素上：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;objectOfAttrs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用-JavaScript-表达式">使用 JavaScript 表达式</h2><p>至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">&quot;`list-$&#123;id&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。  在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：</p><ul><li>在文本插值中 (双大括号)</li><li>在任何 Vue 指令 (以<code>v-</code>开头的特殊 attribute) attribute 的值中</li></ul><h2 id="仅支持表达式">仅支持表达式</h2><p>每个绑定仅支持<strong>单一表达式</strong>，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在<code>return</code>后面。</p><p>因此，下面的例子都是<strong>无效</strong>的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这是一个语句，而非表达式 --&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line"><span class="keyword">return</span> message</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用函数"><a href="https://cn.vuejs.org/guide/essentials/template-syntax#calling-functions">调用函数</a></h3><p>可以在绑定的表达式中使用一个组件暴露的方法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">:title</span>=<span class="string">&quot;toTitleDate(date)&quot;</span> <span class="attr">:datetime</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123; formatDate(date) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Tip: 绑定在表达式中的方法在组件每次更新时都会被重新调用，因此<strong>不</strong>应该产生任何副作用，比如改变数据或触发异步操作。</p><h2 id="受限的全局访问">受限的全局访问</h2><p>模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如<code>Math</code>和<code>Date</code>。  没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在<code>window</code>上的属性。然而，你也可以自行在<code>app.config.globalProperties</code>上显式地添加它们，供所有的  Vue 表达式使用。</p><h1>响应式基础</h1><h2 id="ref">ref()</h2><p>组合式API中,使用<code>ref()</code>函数声明响应式状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="title function_">ref</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><code>ref()</code>接收参数，并将其包裹在一个带有<code>.value</code>属性的 <code>ref</code> 对象中返回  所以<code>vue</code>中的<code>js</code>需要使用组合式<code>setup()</code>，并且在使用时需要添加上<code>.value</code></p><p>示例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123; count &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>vue2</code>中使用<code>set()</code>实现响应式，而在<code>vue3</code>中使用<code>ref()</code>，并且<code>vue3</code>不兼容<code>set()</code>函数</p></blockquote><h2 id="深层响应性">深层响应性</h2><p>Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如<code>Map</code>。</p><p>Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line"><span class="attr">nested</span>: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</span><br><span class="line"><span class="attr">arr</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mutateDeeply</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 以下都会按照期望工作</span></span><br><span class="line">obj.<span class="property">value</span>.<span class="property">nested</span>.<span class="property">count</span>++</span><br><span class="line">obj.<span class="property">value</span>.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reactive">reactive()</h2><blockquote><p><code>reactive()</code>是响应式的另一种<strong>API</strong>，<code>reactive()</code>可使对象本身具有响应性</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><p>在<code>template</code>中以下方式使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;state.cnt ++&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123; state.cnt &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>计算属性</h1><h2 id="基础示例">基础示例</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; author.books.length &gt; 0 ? &quot;YES&quot; : &quot;NO&quot; &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> author = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="attr">books</span>: [</span></span><br><span class="line"><span class="language-javascript"><span class="string">&#x27;Vue 2 - Advanced Guide&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="string">&#x27;Vue 3 - Basic Guide&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="string">&#x27;Vue 4 - The Mystery&#x27;</span></span></span><br><span class="line"><span class="language-javascript">]</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述示例中，可以发现计算是依靠<code>author.books</code>的大小确定的，如果我在模板中多次使用这样的判断，是否显得过于臃肿。<br>对于这样的判断可以引入<code>computed()</code>.</p><h2 id="computed">computed()</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;reactive, computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> author = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="attr">books</span>: [</span></span><br><span class="line"><span class="language-javascript"><span class="string">&#x27;Vue 2 - Advanced Guide&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="string">&#x27;Vue 3 - Basic Guide&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="string">&#x27;Vue 4 - The Mystery&#x27;</span></span></span><br><span class="line"><span class="language-javascript">]</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 一个计算属性 ref</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> publishedBooksMessage = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">return</span> author.<span class="property">books</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="string">&#x27;Yes&#x27;</span> : <span class="string">&#x27;No&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Has published books:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; publishedBooksMessage &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在这里定义了一个计算属性<code>publishedBooksMessage</code>。<code>computed()</code><br>方法期望接收一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description">getter 函数</a><br>，返回值为一个<strong>计算属性 ref</strong>。和其他一般的 ref 类似，你可以通过<code>publishedBooksMessage.value</code>访问计算结果。计算属性 ref<br>也会在模板中自动解包，因此在模板表达式中引用时无需添加<code>.value</code>。</p><p>Vue 的计算属性会自动追踪响应式依赖。它会检测到<code>publishedBooksMessage</code>依赖于<code>author.books</code>，所以当<code>author.books</code>改变时，任何依赖于<br><code>publishedBooksMessage</code>的绑定都会同时更新。</p><h2 id="可写计算属性">可写计算属性</h2><p>计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供<br>getter 和 setter 来创建：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&#123;&#123;fullName&#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123;ref, computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> firstName = <span class="title function_">ref</span>(<span class="string">&#x27;John&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> lastName = <span class="title function_">ref</span>(<span class="string">&#x27;Doe&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// getter</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">return</span> firstName.<span class="property">value</span> + <span class="string">&#x27; &#x27;</span> + lastName.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// setter</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 注意：我们这里使用的是解构赋值语法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">[firstName.<span class="property">value</span>, lastName.<span class="property">value</span>] = newValue.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName.<span class="property">value</span>, firstName.<span class="property">value</span>, lastName.<span class="property">value</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">fullName.<span class="property">value</span> = <span class="string">&quot;Jack Doe&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName.<span class="property">value</span>, firstName.<span class="property">value</span>, lastName.<span class="property">value</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在上述示例中，当运行<code>fullName.value = &quot;Jack Doe&quot;;</code>时，<code>firstName</code>和<code>lastName</code>也会随之更新。</p><h1>类与样式绑定</h1><h2 id="绑定HTML-class">绑定HTML class</h2><h3 id="绑定对象">绑定对象</h3><p>绑定对象一般使用<code>v-bind</code>，比如绑定<code>class</code>一般写为<code>v-bind:class</code> 简写为<code>:class</code>,对其传递对象可动态切换class：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中class的<code>active</code>是否存在由<code>isActive</code>的真值来确定。<br>对象中可通过多个字段class对象<br>例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;static&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">:class</span>=<span class="string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;</span></span><br><span class="line">123</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> isActive = <span class="title function_">ref</span>(<span class="literal">true</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> hasError = <span class="title function_">ref</span>(<span class="literal">false</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.text-danger</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述示例中，字段<code>active, hasError</code> 的真值影响在class类中是否存在对应的类名。当<code>hasError</code>为真时，由于css中的<code>text-danger</code><br>样式，会将字体<strong>123</strong>改变为红色。<br>上述示例渲染后的效果如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;static active&quot;</span>&gt;</span> 123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过以上，我们可以对<code>：class</code>传入一个对象</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;static&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:class</span>=<span class="string">&quot;obj&quot;</span>&gt;</span></span><br><span class="line">        123</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">active</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;text-danger&#x27;</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.text-danger</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>传入对象方法渲染后的效果同上，个人较为喜欢多个字段操作</p><p>我们也可以绑定一个返回对象的[[#计算属性]]。这是一个常见且很有用的技巧：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isActive = <span class="title function_">ref</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">active</span>: isActive.<span class="property">value</span> &amp;&amp; !error.<span class="property">value</span>,</span><br><span class="line">  <span class="string">&#x27;text-danger&#x27;</span>: error.<span class="property">value</span> &amp;&amp; error.<span class="property">value</span>.<span class="property">type</span> === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="绑定数组">绑定数组</h3><p>我们可以给<code>:class</code>绑定一个数组来渲染多个 CSS class：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> activeClass = <span class="title function_">ref</span>(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> errorClass = <span class="title function_">ref</span>(<span class="string">&#x27;text-danger&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>渲染的结果是：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>errorClass</code>会一直存在，但<code>activeClass</code>只会在<code>isActive</code>为真时才存在。</p><p>然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[&#123; [activeClass]: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在组件上使用">在组件上使用</h3><blockquote><p>本节假设你已经有<a href="https://cn.vuejs.org/guide/essentials/component-basics.html">Vue 组件</a>的知识基础。如果没有，你也可以暂时跳过，以后再阅读。</p></blockquote><p>对于只有一个根元素的组件，当你使用了<code>class</code>attribute 时，这些 class 会被添加到根元素上并与该元素上已有的 class 合并。</p><p>举例来说，如果你声明了一个组件名叫<code>MyComponent</code>，模板如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foo bar&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在使用时添加一些 class：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在使用组件时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">class</span>=<span class="string">&quot;baz boo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>渲染出的 HTML 为：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foo bar baz boo&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Class 的绑定也是同样的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当<code>isActive</code>为真时，被渲染的 HTML 会是：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foo bar active&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你的组件有多个根元素，你将需要指定哪个根元素来接收这个 class。你可以通过组件的<code>$attrs</code>属性来指定接收的元素：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;$attrs.class&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>This is a child component<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">class</span>=<span class="string">&quot;baz&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这将被渲染为：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;baz&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>This is a child component<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以在透传 Attribute一章中了解更多组件的 attribute 继承的细节。</p><h2 id="绑定内联样式">绑定内联样式</h2><h3 id="绑定对象-2">绑定对象</h3><p><code>:style</code>支持绑定 JavaScript 对象值，对应的是HTML 元素的<code>style</code>属性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> activeColor = <span class="title function_">ref</span>(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fontSize = <span class="title function_">ref</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尽管推荐使用 camelCase，但<code>:style</code>也支持 kebab-cased 形式的 CSS 属性 key (对应其 CSS 中的实际名称)，例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; &#x27;font-size&#x27;: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> styleObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"><span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line"><span class="attr">fontSize</span>: <span class="string">&#x27;30px&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样的，如果样式对象需要更复杂的逻辑，也可以使用返回样式对象的计算属性。</p><h3 id="绑定数组-2">绑定数组</h3><p>我们还可以给<code>:style</code>绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自动前缀">自动前缀</h3><p>当你在<code>:style</code>中使用了需要<a href="https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix">浏览器特殊前缀</a>的 CSS<br>属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将尝试加上各个浏览器特殊前缀，以找到哪一个是被支持的。</p><h3 id="样式多值">样式多值</h3><p>你可以对一个样式属性提供多个 (不同前缀的) 值，举例来说：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为<code>display: flex</code>。</p>]]></content>
    
    
    <summary type="html">语法，响应式基础，计算属性，类与样式绑定</summary>
    
    
    
    <category term="vue" scheme="https://blog.lazy-boy-acmer.cn/categories/vue/"/>
    
    <category term="技术" scheme="https://blog.lazy-boy-acmer.cn/categories/vue/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="vue" scheme="https://blog.lazy-boy-acmer.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Jetbrains全家桶</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/4d3c3453.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/4d3c3453.html</id>
    <published>2025-02-10T12:18:58.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">以下激活方式仅供个人使用，请勿商用，存在法律风险</p></div><h1>安装破解包</h1><p><a href="https://jet.bytebarn.top/">点击这里</a>安装破解包</p><blockquote><p>进入到网站后，我们可以看到一堆的Jetbrains的工具图标，我们找到最上方的<code>ja-netfilter.zip</code><br><img src="https://s2.loli.net/2025/02/10/zAXgtOFbnLiZ63Y.png" alt="image.png"><br>下载后解压大一个位置，确保能找到，打开解压后的文件夹进入<code>ja-netfilter/scripts</code>文件夹，里面有好几个文件,执行框选的文件<br><img src="https://s2.loli.net/2025/02/10/wZBXiaopfRTYkOy.png" alt="image.png"><br>会先后弹出两个窗口，一定要点确定</p></blockquote><h1>修改编译器的VM选项</h1><blockquote><p>若无法使用，需要激活可以先试用30天<br><img src="https://s2.loli.net/2025/02/10/TSyYhOIBzpNHPcu.png" alt="image.png"><br>添加以下三行代码</p></blockquote><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="attr">--add-opens</span>=java.base/jdk<span class="selector-class">.internal</span><span class="selector-class">.org</span><span class="selector-class">.objectweb</span>.asm=ALL-UNNAMED</span><br><span class="line"><span class="attr">--add-opens</span>=java.base/jdk<span class="selector-class">.internal</span><span class="selector-class">.org</span><span class="selector-class">.objectweb</span><span class="selector-class">.asm</span>.tree=ALL-UNNAMED</span><br><span class="line">-javaagent:C:\Tool\ja-netfilter\ja-netfilter.jar</span><br></pre></td></tr></table></figure><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>注意，第三行需要改为自己保存上面下载的文件的路径</p></div><h1>激活码激活工具</h1><blockquote><p>重启编译器(学计算机的应该都知道为什么)，在<a href="https://jet.bytebarn.top/">https://jet.bytebarn.top/</a>网页中找到对应的工具，使用激活码激活<br><img src="https://s2.loli.net/2025/02/10/q3HuVGdJkZcS4hr.png" alt="image.png"><br>将鼠标放在对应地方，然后点击即可获取激活码<br><img src="https://s2.loli.net/2025/02/10/vuCfUkx5qGmg6et.png" alt="image.png"><br>填入激活码，点击激活</p></blockquote><h1>注册机激活</h1><p><img src="https://s2.loli.net/2025/02/10/pURdKo6tjFJQOWY.png" alt="image.png"></p><blockquote><p>在服务器地址填写<code>https://jbls.bytebarn.top/</code>，点击激活</p></blockquote>]]></content>
    
    
    <summary type="html">Jetbrains全家桶2024.3激活</summary>
    
    
    
    <category term="分享" scheme="https://blog.lazy-boy-acmer.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="生产力" scheme="https://blog.lazy-boy-acmer.cn/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
    <category term="分享" scheme="https://blog.lazy-boy-acmer.cn/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 1002 (Div. 2)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/95434f20.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/95434f20.html</id>
    <published>2025-02-07T06:08:54.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<h1>A. Milya and Two Arrays</h1><p><a href="https://codeforces.com/contest/2059/problem/A"><strong>A. Milya and Two Arrays</strong></a></p><h2 id="题目描述">题目描述</h2><blockquote><p>给你两个长度为n的数组a和b，a,b中的每个元素都至少出现两次。你可以重新排列a，最后要使得ai+bi的不同种类大于等于3。</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>统计a和b的种类数cnt1,cnt2，因为长度为n且每个种类的数至少出现两次，所以a中每个数贡献的种类数就是出现次数，出现次数，min(<br>出现次数，cnt2)，只要cnt1∗cnt2&gt;=3就行。赛时没想的很清楚写的cnt1+cnt2&gt;=4，其实一样。</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  std::set&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::cin &gt;&gt; x;</span><br><span class="line">    a.<span class="built_in">insert</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::cin &gt;&gt; x;</span><br><span class="line">    b.<span class="built_in">insert</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>B. Cost of the Array time limit per test1 second</h1><p><a href="https://codeforces.com/contest/2059/problem/B"><strong>B. Cost of the Array time limit per test1 second</strong></a></p><h2 id="题目描述-2">题目描述</h2><blockquote><p>给你一个长度为n数组a和一个偶数k。你要把a分成k份。然后把所有偶数份按顺序拼到一起，得到b，求可以得到的bi!=i的最小的i。</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote></blockquote><p>我们让所有的k−1份都只占一个位置，第二份占多个位置，看能不能不让1开头，如果有我们可以把前面的1都给第一份，那么答案就是1。否则就全部都是1，那么全部给第二个份，那么答案就是2。<br>注意要特判n==k的情况</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n == k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>, j ++ ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] != j) &#123;</span><br><span class="line">        std::cout &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; k / <span class="number">2</span> + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - (k - <span class="number">2</span>); ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] != <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>C. Customer Service</h1><p><a href="https://codeforces.com/contest/2059/problem/C"><strong>C. Customer Service</strong></a></p><h2 id="题目描述-3">题目描述</h2><blockquote><p>给你n个长度为n的数组，你要给每一个数组截断一次，且所有数组截断的位置凑起来正好是一个排列。然后每个数组的值就是截断的后一部分的和。你要让所有数组和的mex最大。</p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote></blockquote><p>记录每个数组的后缀和与后缀长度相等的位置，那么保留这一段位置可以得到一个数字。于是我们从小到大枚举mex只要有一个没有被操作过的数组可以贡献这个值，就可以继续操作，否则就是答案。然后考虑每个值由哪个数组贡献，应该让可以贡献的最大值最小的数组来贡献这个值。因为其他数组都可以贡献更大的值，应该留下来。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector <span class="title">a</span><span class="params">(n, std::vector&lt;<span class="type">int</span>&gt;(n))</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">      std::cin &gt;&gt; a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">reverse</span>(a[i].<span class="built_in">begin</span>(), a[i].<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; <span class="built_in">s</span>(n + <span class="number">1</span>);</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">    i64 t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">      t += a[i][j];</span><br><span class="line">      <span class="keyword">if</span> (j == n || t != j) &#123;</span><br><span class="line">        b[i] = j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b[i]; ++ j) &#123;</span><br><span class="line">      s[j].<span class="built_in">insert</span>(&#123;b[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [_, x] = *s[i].<span class="built_in">begin</span>();</span><br><span class="line">    s[i].<span class="built_in">erase</span>(s[i].<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b[x]; ++ j) &#123;</span><br><span class="line">      s[j].<span class="built_in">erase</span>(&#123;b[x], x&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>D. Graph and Graph</h1><p><a href="https://codeforces.com/contest/2059/problem/D"><strong>D. Graph and Graph</strong></a></p><h2 id="题目描述-4">题目描述</h2><blockquote><p>给你两个由n个顶点的图，你在图一和图二各有一个起点，你每次要在这两个图上移动，假设从图一移动到了u,<br>图二移动到了v，移动代价是|u−v|。你要进行无限次操作，求操作的最小代价。</p></blockquote><h2 id="解题思路-4">解题思路</h2><blockquote><p>显然我们让两个图都到一个相同的点u，使得有一个v在图一和图二上都和u有边。那么可以在这两个点上反复横跳，代价是0。否则代价是正无穷。<br>那么可以考虑最短路，dist[i][j]表示图一在i，图二在j时的最小代价。最后枚举每个i，看有没有一个j使得在两个图上都有边，然后取最小值即可。</p></blockquote><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, s1, s2;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">  -- s1, -- s2;</span><br><span class="line">  <span class="function">std::vector <span class="title">g1</span><span class="params">(n, std::vector&lt;<span class="type">int</span>&gt;(n))</span></span>;</span><br><span class="line">  <span class="function">std::vector <span class="title">g2</span><span class="params">(n, std::vector&lt;<span class="type">int</span>&gt;(n))</span></span>;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">adj1</span>(n);</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">adj2</span>(n);</span><br><span class="line">  <span class="type">int</span> m1, m2;</span><br><span class="line">  std::cin &gt;&gt; m1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m1; ++ i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    -- u, -- v;</span><br><span class="line">    g1[u][v] = g1[v][u] = <span class="number">1</span>;</span><br><span class="line">    adj1[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    adj1[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; m2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m2; ++ i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    -- u, -- v;</span><br><span class="line">    g2[u][v] = g2[v][u] = <span class="number">1</span>;</span><br><span class="line">    adj2[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    adj2[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">  <span class="function">std::vector <span class="title">dist</span><span class="params">(n, std::vector&lt;<span class="type">int</span>&gt;(n, inf))</span></span>;</span><br><span class="line">  <span class="function">std::vector <span class="title">vis</span><span class="params">(n, std::vector&lt;<span class="type">int</span>&gt;(n))</span></span>;</span><br><span class="line">  <span class="keyword">using</span> A = std::array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line">  std::priority_queue&lt;A, std::vector&lt;A&gt;, std::greater&lt;A&gt; &gt; heap;</span><br><span class="line">  dist[s1][s2] = <span class="number">0</span>;</span><br><span class="line">  heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s1, s2&#125;);</span><br><span class="line">  <span class="keyword">while</span> (heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [_, x, y] = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (vis[x][y]) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; i : adj1[x]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; j : adj2[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i][j] &gt; dist[x][y] + std::<span class="built_in">abs</span>(i - j)) &#123;</span><br><span class="line">          dist[i][j] = dist[x][y] + std::<span class="built_in">abs</span>(i - j);</span><br><span class="line">          <span class="keyword">if</span> (!vis[i][j]) &#123;</span><br><span class="line">            heap.<span class="built_in">push</span>(&#123;dist[i][j], i, j&#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ans = inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (g1[i][j] &amp;&amp; g2[i][j]) &#123;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, dist[i][i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ans == inf) &#123;</span><br><span class="line">    ans = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>将Github pages打包为移动端应用</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/23652f0e.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/23652f0e.html</id>
    <published>2025-01-17T17:28:14.000Z</published>
    <updated>2025-08-22T02:37:23.083Z</updated>
    
    <content type="html"><![CDATA[<h1>配置环境</h1><p>首先我们得先配置好环境 </br><br>我这里用的是IDEA,也可以用android studio</p><p>首先在IDEA中安装一个叫Android的插件<br><img src="https://s2.loli.net/2025/01/18/YuBtGxPNjUenr6q.png" alt="image.png"><br>下载好后我们需要创建项目<br><img src="https://s2.loli.net/2025/01/18/HjckQeP8LGXhWMi.png" alt="image.png"><br>框选的位置一定要修改(language有误，应该选择kotlin)<br><img src="https://s2.loli.net/2025/01/18/aPnIcXe45WJU8xl.png" alt="image.png"><br>可能会提示下载SDK，直接下载就行了</br><br>创建好后，我们需要修改gradle镜像源<br><img src="https://s2.loli.net/2025/01/18/BgOMHLoG7StkyQf.png" alt="image.png"><br>将框选的地址换为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://mirrors.cloud.tencent.com/gradle/gradle-8.2-all.zip</span><br></pre></td></tr></table></figure><p>修改后，重新加载gradle项目即可</p><h1>项目搭建</h1><p>首先我们找到文件<code>app\src\main\java\com\example\myapplication\MainActivity</code></br><br>若没有修改项目名称，那路径就和我一样的<br><img src="https://s2.loli.net/2025/01/18/jw8aYu3sxOZClW1.png" alt="image.png"><br>将以下代码复制到上面的文件中,项目名称不同下述代码的第一行不用复制，粘贴的时候要保留原有的第一行</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapplication</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.<span class="keyword">annotation</span>.SuppressLint</span><br><span class="line"><span class="keyword">import</span> android.app.AlertDialog</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebResourceRequest</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebSettings</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebView</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebViewClient</span><br><span class="line"><span class="keyword">import</span> androidx.activity.ComponentActivity</span><br><span class="line"><span class="keyword">import</span> androidx.swiperefreshlayout.widget.SwipeRefreshLayout</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionException</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> webView: WebView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> swipeRefreshLayout: SwipeRefreshLayout</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executor = ThreadPoolExecutor(</span><br><span class="line">        <span class="number">2</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">        <span class="number">4</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">        <span class="number">30L</span>, TimeUnit.SECONDS, <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">        LinkedBlockingQueue(<span class="number">20</span>) <span class="comment">// 任务队列容量</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;SetJavaScriptEnabled&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        showWelcomeDialog()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 SwipeRefreshLayout 和 WebView</span></span><br><span class="line">        swipeRefreshLayout = findViewById(R.id.swipeRefreshLayout)</span><br><span class="line">        webView = findViewById(R.id.webview)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置 SwipeRefreshLayout</span></span><br><span class="line">        swipeRefreshLayout.setOnRefreshListener &#123;</span><br><span class="line">            webView.reload() <span class="comment">// 刷新网页</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置 WebView</span></span><br><span class="line">        <span class="keyword">val</span> webSettings = webView.settings</span><br><span class="line">        webSettings.javaScriptEnabled = <span class="literal">true</span></span><br><span class="line">        webSettings.domStorageEnabled = <span class="literal">true</span></span><br><span class="line">        webSettings.databaseEnabled = <span class="literal">true</span></span><br><span class="line">        webSettings.setSupportMultipleWindows(<span class="literal">true</span>)</span><br><span class="line">        webSettings.cacheMode = WebSettings.LOAD_DEFAULT</span><br><span class="line">        webView.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="literal">null</span>) <span class="comment">// 启用硬件加速</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 WebViewClient</span></span><br><span class="line">        webView.webViewClient = <span class="keyword">object</span> : WebViewClient() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(view: <span class="type">WebView</span>?, request: <span class="type">WebResourceRequest</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> url = request?.url.toString()</span><br><span class="line">                view?.loadUrl(url)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPageFinished</span><span class="params">(view: <span class="type">WebView</span>?, url: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.onPageFinished(view, url)</span><br><span class="line">                swipeRefreshLayout.isRefreshing = <span class="literal">false</span> <span class="comment">// 停止刷新动画</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载你的博客网址</span></span><br><span class="line">        webView.loadUrl(<span class="string">&quot;https://anzhiyublog.lazy-boy-acmer.cn&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated(<span class="string">&quot;Deprecated in Java&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (::webView.isInitialized &amp;&amp; webView.canGoBack()) &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;WebView&quot;</span>, <span class="string">&quot;Can go back&quot;</span>)</span><br><span class="line">            webView.goBack()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;WebView&quot;</span>, <span class="string">&quot;Not going back&quot;</span>)</span><br><span class="line">            <span class="keyword">super</span>.onBackPressed()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示欢迎提示框</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showWelcomeDialog</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">        builder.setTitle(<span class="string">&quot;\uD83E\uDD74提示&quot;</span>)</span><br><span class="line">        builder.setMessage(<span class="string">&quot;返回键已修复为可返回之前页面\n现无法跳转外部页面&quot;</span>)</span><br><span class="line"></span><br><span class="line">        builder.setPositiveButton(<span class="string">&quot;确定&quot;</span>) &#123; dialog, _ -&gt;</span><br><span class="line">            dialog.dismiss()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> dialog = builder.create()</span><br><span class="line">        dialog.show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务入队</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">enqueueTriggerTask</span><span class="params">(task: <span class="type">Runnable</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            executor.execute(task)</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;TaskManager&quot;</span>, <span class="string">&quot;Failed to enqueue task&quot;</span>, e)</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        executor.shutdown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开文件 <code>app\src\main\res\layout\activity_main.xml</code><br><img src="https://s2.loli.net/2025/01/18/VDlGNUHtMqvuFiO.png" alt="image.png"><br>粘贴以下代码</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.swiperefreshlayout.widget.SwipeRefreshLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/swipeRefreshLayout&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/webview&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.swiperefreshlayout.widget.SwipeRefreshLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>生成apk</h1><p>点击菜单栏的 <code>Build -&gt; Build Apk(s)</code></br><br>生成的安装包会在项目根目录下的<strong>app\build\outputs\apk\debug</strong>里面</br><br>至于如何修改Apk的名称和图标，大家可以自行百度或AI</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="android" scheme="https://blog.lazy-boy-acmer.cn/categories/android/"/>
    
    <category term="技术" scheme="https://blog.lazy-boy-acmer.cn/categories/android/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="android" scheme="https://blog.lazy-boy-acmer.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>npm作为图片存储</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/8134c5ac.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/8134c5ac.html</id>
    <published>2025-01-08T15:19:34.000Z</published>
    <updated>2025-08-22T02:37:23.083Z</updated>
    
    <content type="html"><![CDATA[<h1>创建文件夹</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> demo</span><br></pre></td></tr></table></figure><h1>初始化</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h1>打开编译器创建文件<code>index.js</code>并填入以下信息</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> main;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Hello</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;$&#123; name &#125;&#125;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>打开package.json文件</h1><p>现在我们来熟悉下这个文件。</p><table><thead><tr><th>字段</th><th>备注</th></tr></thead><tbody><tr><td>name</td><td>npm包的名称，也就是publish后的名称</td></tr><tr><td>version</td><td>每次publish的时候记得修改这个，必须要是新版本</td></tr><tr><td>desdescription</td><td>对这个npm包的描述</td></tr><tr><td>main</td><td>链接到这个包后，默认打开的文件</td></tr><tr><td>keywords</td><td>关键词。若是自行使用，可以不配置</td></tr><tr><td>author</td><td>作者。填写自己的用户名就行</td></tr></tbody></table><p>现在在<strong>json</strong>文件中添加以下信息</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span> <span class="string">&quot;&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>在<code>[]</code>中添加需要发布的文件或文件夹，多个文件或文件夹用<code>,</code>隔开并且每个都用<code>&quot;&quot;</code>包裹。<br>自行检查语法错误</p><h1>发布</h1><p>由于镜像源问题，我们可能会发布失败<br>我们直接在<strong>cmd</strong>中切换镜像源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><p>切换后发布</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>发布成功后我们再将镜像源切换回</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>若不切换，可能会出现 <code>npm install</code> 失败</p><h1>访问文件</h1><p>访问npm包的文件我们可以使用<a href="https://www.unpkg.com">unpkg</a>来访问<br>以下链接是访问最新发布的npm包</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//u</span>npkg.com<span class="regexp">/npm包名/</span>file</span><br></pre></td></tr></table></figure><p>若在包名后添加<code>@版本号</code>，则可以访问指定版本的npm包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 准确版本号</span></span><br><span class="line">https://unpkg.com/npm包名@1.1.1/file</span><br><span class="line"><span class="comment"># 模糊版本号(访问的是这个大版本的最新的版本号)</span></span><br><span class="line">https://unpkg.com/npm包名@1/file</span><br><span class="line"><span class="comment"># 模糊版本号(访问的是这个小版本的最新的版本号)</span></span><br><span class="line">https://unpkg.com/npm包名@1.1/file</span><br></pre></td></tr></table></figure><p>好了，今天的分享就到这里了，拜拜！</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="npm" scheme="https://blog.lazy-boy-acmer.cn/categories/npm/"/>
    
    <category term="hexo" scheme="https://blog.lazy-boy-acmer.cn/categories/npm/hexo/"/>
    
    
    <category term="npm" scheme="https://blog.lazy-boy-acmer.cn/tags/npm/"/>
    
    <category term="存储" scheme="https://blog.lazy-boy-acmer.cn/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>StarRail-忘归人</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/f6d845be.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/f6d845be.html</id>
    <published>2024-12-24T03:38:04.000Z</published>
    <updated>2025-08-22T02:37:23.082Z</updated>
    
    <content type="html"><![CDATA[<div style="background-color: #f9f9f9; padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  <h2 style="text-align: center; color: #333; font-family: 'Georgia', serif;">梦醒方知我非蝶</h2>  <p style="text-align: justify; color: #555; font-family: 'Georgia', serif; line-height: 1.8;">    睁眼 不知今夕何年<br>    缀尾以赤焰 塑身以红莲<br>    生死仿佛只在一念间<br>    梦醒方知我非蝶<br>    执念 缠绕于我指尖<br>    前尘隔山远 往事散如烟<br>    清夜 乘一叶星槎归故园<br>    望仙舟繁华似从前<br>    故人如相见 是否泪如涟<br>    只恨旧忆皆忘却<br>    归来时<br>    春色满丛 花繁露浓 暗香盈襟袖<br>    奈何<br>    世事匆匆 今朝明月 可与当年同<br>    纸扇归烬泪成空 木<br>    桃花依旧笑春风<br>    谁见昨日山河尽入梦<br>    梦魇 盘旋之后幻灭<br>    旧忆如残片 又蓦然浮现<br>    聚散不定 随月色溶解<br>    昼起才见花未眠<br>    夙愿 萦绕于我心间<br>    前尘隔山远 往事今重叠<br>    尤见 花瓣落荒原坠深渊<br>    叹命运脆弱似琴弦<br>    弦断梦可辨 业火燃罪孽<br>    忘归即最终纪念<br>    怎忘却<br>    焰噬长空 魂殇囚笼 作别长生种<br>    归来 徒留惨痛 旧友难逢 此身系转蓬<br>    朝露明灭浮光散 听涛不见山万重<br>    应是红尘蹀躞皆入梦<br>    而今 幽夜沉重<br>    云过无踪 登楼不减愁<br>    且于 黄昏载酒<br>    醉舞一回 大梦是千秋<br>    昨夜星辰昨夜风<br>    今宵肠断桃花红<br>    纵使忘归于夜亦入梦  </p></div>]]></content>
    
    
    <summary type="html">忘归人</summary>
    
    
    
    <category term="StarRail" scheme="https://blog.lazy-boy-acmer.cn/categories/StarRail/"/>
    
    
    <category term="StarRail" scheme="https://blog.lazy-boy-acmer.cn/tags/StarRail/"/>
    
    <category term="忘归人" scheme="https://blog.lazy-boy-acmer.cn/tags/%E5%BF%98%E5%BD%92%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 991 (Div. 3)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/ca0632d3.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/ca0632d3.html</id>
    <published>2024-12-06T02:25:16.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>打过的最难的div3</p></div><h1>A.Line Breaks</h1><p><a href="https://codeforces.com/contest/2050/problem/A">Line Breaks</a></p><h2 id="题目描述">题目描述</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button><button type="button" class="tab " data-href="a-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>Kostya has a text s consisting of n words made up of Latin alphabet letters. He also has two strips on which he must write the text. The first strip can hold m characters, while the second can hold as many as needed.</p><p>Kostya must choose a number x and write the first x words from s on the first strip, while all the remaining words are written on the second strip. To save space, the words are written without gaps, but each word must be entirely on one strip.</p><p>Since space on the second strip is very valuable, Kostya asks you to choose the maximum possible number x such that all words s1,s2,…,sx fit on the first strip of length m.</p></div><div class="tab-item-content" id="a-2"><p>一段文本有 $n$ 个单词，现将这段文本写在纸上，单词间无间隔，在第一页纸能写 $m$ 个字符，但是一个单词必须出现在同一页纸上。<br>问：第一页纸能写多少个单词</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><p>模拟</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m, f = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; s[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> su = <span class="number">0</span>, ct = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (su + s[i].<span class="built_in">size</span>() &lt;= m) &#123;</span><br><span class="line">      ct++;</span><br><span class="line">      su += (<span class="type">int</span>) s[i].<span class="built_in">size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Transfusion</h1><p><a href="https://codeforces.com/contest/2050/problem/B">Transfusion</a></p><h2 id="题目描述-2">题目描述</h2><div class="tabs" id="b"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="b-1">英文题面</button><button type="button" class="tab " data-href="b-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="b-1"><p>You are given an array a of length n. In one operation, you can pick an index i from 2 to n−1 inclusive, and do one of the following actions:</p><ul><li><p>Decrease $a_{i-1}$ by 1, then increase $a_{i+1}$ by 1.</p></li><li><p>Decrease $a_{i+1}$ by 1, then increase $a_{i-1}$ by 1.</p></li></ul><p>After each operation, all the values must be non-negative. Can you make all the elements equal after any number of operations?</p></div><div class="tab-item-content" id="b-2"><p>给定长度为 $n$ 的数组可以执行以下操作：</p><ul><li>$a_{i-1}=a_{i-1}-1,a_{i+1}=a_{i+1}+1$;</li><li>$a_{i-1}=a_{i-1}+1,a_{i+1}=a_{i+1}-1$;</li></ul><p>问：是否可以通过以上操作将数组的所有元素变为相等。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-2">解题思路</h2><p>可以发现每次修改的下标奇偶性相同，我们可以分别记录下奇数下标和偶数下标的 $sum$ 和 $ct$。<br>那么能实现的判断条件也很简单，如下：</p><ul><li>$\frac{sum_{奇}}{ct_{奇}} = \frac {sum_{偶}}{ct_{偶}}$</li><li>$\frac{sum_{奇}}{ct_{奇}}=0 ，\frac{sum_{偶}}{ct_{偶}} =0$</li></ul><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="type">int</span> ct[<span class="number">2</span>]&#123;&#125;, sum[<span class="number">2</span>]&#123;&#125;; </span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i];</span><br><span class="line">    sum[i % <span class="number">2</span>] += a[i];</span><br><span class="line">    ct[i % <span class="number">2</span>] ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sum[<span class="number">0</span>] % ct[<span class="number">0</span>] || sum[<span class="number">1</span>] % ct[<span class="number">1</span>] || sum[<span class="number">0</span>] / ct[<span class="number">0</span>] != sum[<span class="number">1</span>] / ct[<span class="number">1</span>]) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.Uninteresting Number</h1><p><a href="https://codeforces.com/contest/2050/problem/C">Uninteresting Number</a></p><h2 id="题目描述-3">题目描述</h2><div class="tabs" id="c"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c-1">英文题面</button><button type="button" class="tab " data-href="c-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c-1"><p>You are given a number n with a length of no more than 105.</p><p>You can perform the following operation any number of times: choose one of its digits, square it, and replace the original digit with the result. The result must be a digit (that is, if you choose the digit x, then the value of x2 must be less than 10).</p><p>Is it possible to obtain a number that is divisible by 9 through these operations?</p></div><div class="tab-item-content" id="c-2"><p>给你一个长度不超过 $10^5$ 的数字 $n$ 。</p><p>你可以多次进行下面的运算：选择其中一个数字，将其平方，然后用运算结果替换原来的数字。结果必须是一位数字(也就是说，如果您选择数字 $x$ ，那么 $x^2$ 的值必须小于 $10$ )。</p><p>通过这些运算，有可能得到一个能被 $9$ 整除的数吗？</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-3">解题思路</h2><p>数字必须是数字这一要求对变换有如下限制：我们可以将 $0$ 变换为 $0$ ，将 $1$ 变换为 $1$ ，将 $2$ 变换为 $4$ ，将 $3$ 变换为 $9$ 。任何其他数字的平方都会超过 9，因此无法变换。涉及 $0$ 和 $1$ 的变换都是无用的，因此我们有两种可能的操作：将数字 $2$ 或数字 $3$ 平方。</p><p>我们将使用 $9$ 的可除规则。它规定，当且仅当一个数字的数位之和能被 $9$ 整除时，这个数字才能被 $9$ 整除。让我们看看数字的位数之和在可能的变换中会发生怎样的变化。如果我们对 $2$ 进行平方运算，数位之和将增加 $2^2 - 2 = 2$ ；如果我们对 $3$ 进行平方运算，数位之和将增加 $3^2 - 3 = 6$ 。</p><p>我们将计算数字中 $2$ 的位数和数字中 $3$ 的位数。我们可以从可用的数位 $2$ 和 $3$ 中选择转换的个数。变换超过 8 个 2 和超过 8 个 3 的余数是没有意义的，因为它们的变换加到总和中的余数模 $9$ 会重复。</p><p>因此，最终的解法是这样的：我们计算数字的位数之和，数出 $2$ 和 $3$ 的位数。我们将遍历改变 $2$ 的位数（可能为 0，但不超过 8 位），以及改变 $3$ 的位数（可能为 0，但也不超过 8 位）。假设我们改变了 $x$ 位数 $2$ 和 $y$ 位数 $3$ ，那么这个数的位数总和就增加了 $x * 2 + y * 6$ 。如果新的和能被 $9$ 整除，那么答案就是 “是”。如果在迭代过程中从未出现过这种情况，则答案为 “否”。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>, ct1 = <span class="number">0</span>, ct2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">    sum += i - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    ct1 += (i == <span class="string">&#x27;2&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    ct2 += (i == <span class="string">&#x27;3&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= std::<span class="built_in">min</span>(<span class="number">9ll</span>, ct1); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= std::<span class="built_in">min</span>(<span class="number">9ll</span>, ct2); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((sum + i * <span class="number">2</span> + j * <span class="number">6</span>) % <span class="number">9</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Digital string maximization</h1><p><a href="https://codeforces.com/contest/2050/problem/D">Digital string maximization</a></p><h2 id="题目描述-4">题目描述</h2><div class="tabs" id="d"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="d-1">英文题面</button><button type="button" class="tab " data-href="d-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="d-1"><p>You are given a string s, consisting of digits from 0 to 9. In one operation, you can pick any digit in this string, except for 0 or the leftmost digit, decrease it by 1, and then swap it with the digit left to the picked.</p><p>For example, in one operation from the string 1023, you can get 1103 or 1022.</p><p>Find the lexicographically maximum string you can obtain after any number of operations.</p></div><div class="tab-item-content" id="d-2"><p>给你一个由 0 到 9 的数字组成的字符串 s。在一次操作中，您可以选取该字符串中除 0 或最左边数字之外的任意一个数字，将其减少 1，然后将其与左边的数字对调。</p><p>例如，从字符串 1023 中进行一次运算，可以得到 1103 或 1022。</p><p>找出任意多次运算后可以得到的词性最大的字符串。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-4">解题思路</h2><p>让我们看看数字 $s_i$ 。我们可以看到，我们不能将它向左移动超过 $s_i$ 次，因为它之后将是 $0$ 。因此，我们可以说，只有从 $i$ 到 $i+9$ 的指数上的数字才能位于指数 $i$ 上，因为最大的数字 $9$ 向左移动的次数不超过 $9$ 。</p><p>因此，我们可以对每个 $i$ 从 $s_i$ 到 $s_{i+9}$ 的所有数字进行暴力推理，选出 $j$ 中 $s_j - (j - i)$ 最大的数字；如果有多个最大选项，我们将最小化 $j$ 。之后，我们将 $s_j$ 向左移动，直到它位于索引 $i$ 上。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="type">int</span> x = s[i] - <span class="string">&#x27;0&#x27;</span>, pos = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; std::<span class="built_in">min</span>(i + <span class="number">10</span>, (<span class="type">int</span>)s.<span class="built_in">size</span>()); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[j] - <span class="string">&#x27;0&#x27;</span> - (j - i) &gt; x) &#123;</span><br><span class="line">        x = s[j] - <span class="string">&#x27;0&#x27;</span> - (j - i);</span><br><span class="line">        pos = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pos &gt; i) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(s[pos], s[pos - <span class="number">1</span>]);</span><br><span class="line">      pos--;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i] = x + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Codeforces Round 991(div3) (A-D)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder Beginner Contest 378</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/1ac0459a.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/1ac0459a.html</id>
    <published>2024-11-22T05:38:05.000Z</published>
    <updated>2025-08-22T02:37:23.079Z</updated>
    
    <content type="html"><![CDATA[<h1>A.Pairing</h1><p><a href="https://atcoder.jp/contests/abc378/tasks/abc378_a">Pairing</a></p><h2 id="题目描述">题目描述</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>There are four balls, and the color of the $i$-th ball is $A_i$.<br>Find the maximum number of times you can perform this operation: choose two balls of the same color and discard both.</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::cin &gt;&gt; x;</span><br><span class="line">    mp[x]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : mp) &#123;</span><br><span class="line">    s += y / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Garbage Collection</h1><p><a href="https://atcoder.jp/contests/abc378/tasks/abc378_b">Garbage Collection</a></p><h2 id="题目描述-2">题目描述</h2><div class="tabs" id="b"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="b-1">英文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="b-1"><p>In AtCoder City, $N$ types of garbage are collected regularly. The $i$-th type of garbage $(i=1,2,\dots,N)$ is collected on days when the date modulo $q_i$ equals $r_i$.<br>Answer $Q$ queries. In the $j$-th query $(j=1,2,\dots,Q)$, given that the $t_j$-th type of garbage is put out on day $d_j$, answer the next day on which it will be collected.<br>Here, if the $i$-th type of garbage is put out on a day when that type of garbage is collected, then the garbage will be collected on the same day.</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><blockquote><p>模拟</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;pii &gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    a[i] = &#123;u, v&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> q;</span><br><span class="line">  std::cin &gt;&gt; q;</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="type">int</span> t, d;</span><br><span class="line">    std::cin &gt;&gt; t &gt;&gt; d;</span><br><span class="line">    t--;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = a[t];</span><br><span class="line">    <span class="type">int</span> w = d / x * x + y;</span><br><span class="line">    <span class="keyword">if</span> (w &lt; d) w += x;</span><br><span class="line">    std::cout &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.Repeating</h1><p><a href="https://atcoder.jp/contests/abc378/tasks/abc378_c">Repeating</a></p><h2 id="题目描述-3">题目描述</h2><div class="tabs" id="c"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c-1">英文题面</button><button type="button" class="tab " data-href="c-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c-1"><p>You are given a sequence of $N$ positive numbers, $A = (A_1, A_2, \dots, A_N)$. Find the sequence $B = (B_1, B_2, \dots, B_N)$ of length $N$ defined as follows.</p><ul><li>For $i = 1, 2, \dots, N$, define $B_i$ as follows:<ul><li>Let $B_i$ be the most recent position before $i$ where an element equal to $A_i$ appeared. If such a position does not exist, let $B_i = -1$.<br>More precisely, if there exists a positive integer $j$ such that $A_i = A_j$ and $j &lt; i$, let $B_i$ be the largest such $j$. If no such $j$ exists, let $B_i = -1$.</li></ul></li></ul></div><div class="tab-item-content" id="c-2"><p>给你一个由 $N$ 个正数 $A = (A_1, A_2, \dots, A_N)$ 组成的数列。求长度为 $N$ 的序列 $B = (B_1, B_2, \dots, B_N)$ 的定义如下。</p><ul><li>对于 $i = 1, 2, \dots, N$ ，定义 $B_i$ 如下：<ul><li>设 $B_i$ 是在 $i$ 之前出现过与 $A_i$ 相同元素的最近位置。如果不存在这样的位置，则设为 $B_i = -1$ 。<br>更确切地说，如果存在一个正整数 $j$ ，使得 $A_i = A_j$ 和 $j &lt; i$ ，那么就让 $B_i$ 成为最大的 $j$ 。如果不存在这样的 $j$ , 则设 $B_i = -1$ .</li></ul></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-2">解题思路</h2><blockquote><p>标记之前出现过的数的位置</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) std::cin &gt;&gt; a[i];</span><br><span class="line">  b[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">  mp[a[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">find</span>(a[i]) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      b[i] = mp[a[i]];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      b[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mp[a[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) std::cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Count Simple Paths</h1><p><a href="https://atcoder.jp/contests/abc378/tasks/abc378_d">Count Simple Paths</a></p><h2 id="题目描述-4">题目描述</h2><div class="tabs" id="d"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="d-1">英文题面</button><button type="button" class="tab " data-href="d-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="d-1"><p>There is a grid of $H \times W$ cells. Let $(i, j)$ denote the cell at the $i$-th row from the top and the $j$-th column from the left.<br>Cell $(i, j)$ is empty if $S_{i,j}$ is <code>.</code>, and blocked if it is <code>#</code>.<br>Count the number of ways to start from an empty cell and make $K$ moves to adjacent cells (up, down, left, or right), without passing through blocked squares and not visiting the same cell more than once.<br>Specifically, count the number of sequences of length $K+1$, $((i_0, j_0), (i_1, j_1), \dots, (i_K, j_K))$, satisfying the following.</p><ul><li>$1 \leq i_k \leq H$, $1 \leq j_k \leq W$, and $S_{i_k, j_k}$ is <code>.</code>, for each $0 \leq k \leq K$.</li><li>$|i_{k+1} - i_k| + |j_{k+1} - j_k| = 1$ for each $0 \leq k \leq K-1$.</li><li>$(i_k, j_k) \neq (i_l, j_l)$ for each $0 \leq k &lt; l \leq K$.</li></ul></div><div class="tab-item-content" id="d-2"><p>有一个由 $H \times W$ 个单元格组成的网格。让 $(i, j)$ 表示从上往下第 $i$ 行，从左往上第 $j$ 列的单元格。<br>如果 $S_{i,j}$ 是 <code>.</code>，则单元格 $(i, j)$ 为空；如果是 <code>#</code> ，则单元格 $(i, j)$ 阻塞。<br>计算从一个空单元格开始，向相邻单元格（向上、向下、向左或向右）进行 $K$ 移动，而不经过被阻塞的方格，并且不多次访问同一单元格的方法的数目。<br>具体地说，计算满足以下条件的长度为 $K+1$ , $((i_0, j_0), (i_1, j_1), \dots, (i_K, j_K))$ 的序列的个数。</p><ul><li>$1 \leq i_k \leq H$ 、 $1 \leq j_k \leq W$ 和 $S_{i_k, j_k}$ 为 <code>.</code>，每个 $0 \leq k \leq K$ 为 <code>.</code>。</li><li>$|i_{k+1} - i_k| + |j_{k+1} - j_k| = 1$ 为每个 $0 \leq k \leq K-1$ 。</li><li>每个 $0 \leq k &lt; l \leq K$ 的 $(i_k, j_k) \neq (i_l, j_l)$ 。</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-3">解题思路</h2><blockquote><p>dfs暴搜</p></blockquote><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m, k;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector <span class="title">vis</span><span class="params">(n, std::vector&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>))</span></span>;</span><br><span class="line">  std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = ([&amp;](<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val) &#123;</span><br><span class="line">    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (val == k) &#123;</span><br><span class="line">      res++;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="type">int</span> u = x + dx[i], v = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">check</span>(u, v) &amp;&amp; !vis[u][v] &amp;&amp; s[u][v] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(u, v, val + <span class="number">1</span>);</span><br><span class="line">        vis[u][v] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(i, j, <span class="number">0</span>), vis[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Atcoder abc 378 (A-D)</summary>
    
    
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/categories/atcoder/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder Beginner Contest 377</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/8a7f580b.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/8a7f580b.html</id>
    <published>2024-10-30T09:31:35.000Z</published>
    <updated>2025-08-22T02:37:23.079Z</updated>
    
    <content type="html"><![CDATA[<h1>A.Rearranging ABC</h1><p><a href="https://atcoder.jp/contests/abc377/tasks/abc377_a">Rearranging ABC</a></p><h2 id="题目描述">题目描述</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button><button type="button" class="tab " data-href="a-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>You are given a string $S$ of length $3$ consisting of uppercase English letters.<br>Determine whether it is possible to rearrange the characters in $S$ to make it match the string <code>ABC</code>.</p></div><div class="tab-item-content" id="a-2"><p>给定字符串$s$,判断是否可以组成 $ABC$</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><blockquote><p>排个序就行了</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  std::<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">  std::cout &lt;&lt; (s == <span class="string">&quot;ABC&quot;</span> ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Avoid Rook Attack</h1><p><a href="https://atcoder.jp/contests/abc377/tasks/abc377_b">Avoid Rook Attack</a></p><h2 id="题目描述-2">题目描述</h2><div class="tabs" id="b"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="b-1">英文题面</button><button type="button" class="tab " data-href="b-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="b-1"><p>There is a grid of $64$ squares with $8$ rows and $8$ columns. Let $(i,j)$ denote the square at the $i$-th row from the top $(1\leq i\leq8)$ and $j$-th column from the left $(1\leq j\leq8)$.<br>Each square is either empty or has a piece placed on it. The state of the squares is represented by a sequence $(S_1,S_2,S_3,\ldots,S_8)$ of $8$ strings of length $8$. Square $(i,j)$ $(1\leq i\leq8,1\leq j\leq8)$ is empty if the $j$-th character of $S_i$ is <code>.</code>, and has a piece if it is <code>#</code>.<br>You want to place your piece on an <strong>empty square</strong> in such a way that it <strong>cannot be captured by any of the existing pieces</strong>.<br>A piece placed on square $(i,j)$ can capture pieces that satisfy either of the following conditions:</p><ul><li>Placed on a square in row $i$</li><li>Placed on a square in column $j$<br>For example, a piece placed on square $(4,4)$ can capture pieces placed on the squares shown in blue in the following figure:<br><img src="https://img.atcoder.jp/abc377/ee2f825f3be375e8c8eaa3c60fdf18de.png" alt=""><br>How many squares can you place your piece on?</li></ul></div><div class="tab-item-content" id="b-2"><p>给出棋盘，其中放有的位置为 <code>#</code>, 在放有棋子的上下左右四个方向不能放棋子，问有多少个位置可以放棋子.</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-2">解题思路</h2><blockquote><p>模拟下即可</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">s</span><span class="params">(<span class="number">8</span>, <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; s[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector <span class="title">a</span><span class="params">(<span class="number">8</span>, std::vector&lt;<span class="type">int</span>&gt;(<span class="number">8</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">8</span>; l++) &#123;</span><br><span class="line">          a[i][l] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">8</span>; l++) &#123;</span><br><span class="line">          a[l][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i : a) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j : i) &#123;</span><br><span class="line">      res += j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.Avoid Knight Attack</h1><p><a href="https://atcoder.jp/contests/abc377/tasks/abc377_c">Avoid Knight Attack</a></p><h2 id="题目描述-3">题目描述</h2><div class="tabs" id="c"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c-1">英文题面</button><button type="button" class="tab " data-href="c-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c-1"><p>There is a grid of $N^2$ squares with $N$ rows and $N$ columns. Let $(i,j)$ denote the square at the $i$-th row from the top $(1\leq i\leq N)$ and $j$-th column from the left $(1\leq j\leq N)$.<br>Each square is either empty or has a piece placed on it. There are $M$ pieces placed on the grid, and the $k$-th $(1\leq k\leq M)$ piece is placed on square $(a_k,b_k)$.<br>You want to place your piece on an <strong>empty square</strong> in such a way that it <strong>cannot be captured by any of the existing pieces</strong>.<br>A piece placed on square $(i,j)$ can capture pieces that satisfy any of the following conditions:</p><ul><li>Placed on square $(i+2,j+1)$</li><li>Placed on square $(i+1,j+2)$</li><li>Placed on square $(i-1,j+2)$</li><li>Placed on square $(i-2,j+1)$</li><li>Placed on square $(i-2,j-1)$</li><li>Placed on square $(i-1,j-2)$</li><li>Placed on square $(i+1,j-2)$</li><li>Placed on square $(i+2,j-1)$<br>Here, conditions involving non-existent squares are considered to never be satisfied.<br>For example, a piece placed on square $(4,4)$ can capture pieces placed on the squares shown in blue in the following figure:<br><img src="https://img.atcoder.jp/abc377/871985d4de26cef302c00cdd6f178880.png" alt=""><br>How many squares can you place your piece on?</li></ul></div><div class="tab-item-content" id="c-2"><p><img src="https://img.atcoder.jp/abc377/871985d4de26cef302c00cdd6f178880.png" alt=""><br>给定$n * n$ 的棋盘和 $m$个棋子位置,其中棋子能走的位置上图所示,问多少个位置可以放棋子,并且不被吃掉</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-3">解题思路</h2><blockquote><p>模拟，需要注意边界处理</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> dx[] = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">      dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt; x &amp;&amp; x &lt;= n &amp;&amp; <span class="number">0</span> &lt; y &amp;&amp; y &lt;= n;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::set&lt;pii &gt; se;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    std::cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    se.<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">      <span class="type">int</span> u = x + dx[j], v = y + dy[j];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">check</span>(u, v)) se.<span class="built_in">insert</span>(&#123;u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; n * n - se.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Many Segments 2</h1><p><a href="https://atcoder.jp/contests/abc377/tasks/abc377_d">Many Segments 2</a></p><h2 id="题目描述-4">题目描述</h2><div class="tabs" id="d"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="d-1">英文题面</button><button type="button" class="tab " data-href="d-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="d-1"><p>You are given two sequences of positive integers of length $N$, $L=(L_1,L_2,\ldots,L_N)$ and $R=(R_1,R_2,\ldots,R_N)$, and an integer $M$.<br>Find the number of pairs of integers $(l,r)$ that satisfy both of the following conditions:</p><ul><li>$1\le l \le r \le M$</li><li>For every $1\le i\le N$, the interval $[l,r]$ does not completely contain the interval $[L_i,R_i]$.</li></ul></div><div class="tab-item-content" id="d-2"><p>给你两个长度分别为 $N$ 、 $L=(L_1,L_2,\ldots,L_N)$ 和 $R=(R_1,R_2,\ldots,R_N)$ 的正整数序列，以及一个整数 $M$ 。<br>求满足以下两个条件的整数对 $(l,r)$ 的个数：</p><ul><li>$1\le l \le r \le M$</li><li>对于每一个 $1\le i\le N$ ，区间 $[l,r]$ 并不完全包含区间 $[L_i,R_i]$ 。</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-4">解题思路</h2><blockquote><p>考虑 $O(m)$的同时，维护一个左边界，就是当前位置能最多往前多少是刚好不完全覆盖的，最后这个左边界需要取个 <code>max</code> ，因为如果前面的左边界更右，那后面的左边界也要和前面一样。</p></blockquote><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + m, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, l, r; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    a[r] = std::<span class="built_in">max</span>(a[r], l + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    a[i] = std::<span class="built_in">max</span>(a[i], a[i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    res += i - a[i] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.Permute K times 2</h1><p><a href="https://atcoder.jp/contests/abc377/tasks/abc377_e"> Permute K times 2</a></p><h2 id="题目描述-5">题目描述</h2><div class="tabs" id="e"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="e-1">英文题面</button><button type="button" class="tab " data-href="e-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="e-1"><p>You are given a permutation $P=(P_1,P_2,\ldots,P_N)$ of $(1,2,\ldots,N)$.<br>The following operation will be performed $K$ times:</p><ul><li>For $i=1,2,\ldots,N$, <strong>simultaneously</strong> update $P_i$ to $P_{P_i}$.<br>Print $P$ after all operations.</li></ul></div><div class="tab-item-content" id="e-2"><p>给定长度为 $N$的数组 $P$,将 $P_{i}$替换为 $P_{P_{i}}$操作 $K$次,输出 $K$次操作后的数组.</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-5">解题思路</h2><blockquote><p>在替换时，某个数多替换几轮就可能回到替换前的位置，那么我们就只需要找出环的大小即可，随后再取模即可</p></blockquote><h2 id="参考代码-5">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">P</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; P[i], P[i]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> qpow = [&amp;](<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p) &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">      a = a * a % p;</span><br><span class="line">      b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (!vis[j]) &#123;</span><br><span class="line">      vis[j] = <span class="literal">true</span>, t.<span class="built_in">push_back</span>(j);</span><br><span class="line">      j = P[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> w = <span class="built_in">qpow</span>(<span class="number">2</span>, k, t.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; t.<span class="built_in">size</span>(); x++) &#123;</span><br><span class="line">      P[t[x]] = t[(x + w) % t.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cout &lt;&lt; P[i] + <span class="number">1</span> &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Atcoder abc 377 (A-E)</summary>
    
    
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/categories/atcoder/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder Beginner Contest 376</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/fd78689d.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/fd78689d.html</id>
    <published>2024-10-24T01:59:57.000Z</published>
    <updated>2025-08-22T02:37:23.079Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>建议查看中文题面，不要问为什么*(问就是，英文题面就是复制过来的，中文体面精简些),数据范围详见题目链接</p></div><h1>A.Candy Button</h1><p><a href="https://atcoder.jp/contests/abc376/tasks/abc376_a">Candy Button</a></p><h2 id="题目描述">题目描述</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button><button type="button" class="tab " data-href="a-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>There is a mysterious button. When you press this button, you receive one candy, unless less than $C$ seconds have elapsed since you last received a candy.<br>Takahashi decided to press this button $N$ times. He will press the button for the $i$-th time $T_i$ seconds from now.<br>How many candies will he receive?</p></div><div class="tab-item-content" id="a-2"><p>一个按钮，按了会发糖。</p><p>给定多次按的时间。如果这次按的时间距离上次发糖时间超过了$c$，则发个糖。问发的糖数量。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><blockquote><p>发糖的前提是距离上次发糖时间大于等于$c$</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k, ct = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt;n ; i ++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ct = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] - a[pos] &gt;= k) &#123;</span><br><span class="line">            ct ++;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Hands on Ring (Easy)</h1><p><a href="https://atcoder.jp/contests/abc376/tasks/abc376_b">Hands on Ring (Easy)</a></p><h2 id="题目描述-2">题目描述</h2><div class="tabs" id="b"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="b-1">英文题面</button><button type="button" class="tab " data-href="b-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="b-1"><p><strong>Note: This problem has almost the same setting as Problem F. Only the parts in bold in the main text and constraints differ.</strong></p><p>You are holding a ring with both hands. This ring consists of $N\ (N \geq 3)$ parts numbered $1,2,\dots,N$, where parts $i$ and $i+1$ ($1 \leq i \leq N-1$) are adjacent, and parts $1$ and $N$ are also adjacent.</p><p>Initially, your left hand is holding part $1$, and your right hand is holding part $2$. In one <em>operation</em>, you can do the following:</p><ul><li>Move one of your hands to an adjacent part of the part it is currently holding. However, you can do this only if the other hand is not on the destination part.</li></ul><p>The following figure shows the initial state and examples of operations that can and cannot be made from there. The number written on each part of the ring represents the part number, and the circles labeled L and R represent your left and right hands, respectively.</p><p><img src="https://img.atcoder.jp/abc376/bb6691e1c7281e4794b3fd94b256ba66.png" alt=""></p><p>You need to follow $Q$ instructions given to you in order. The $i$-th ($1 \leq i \leq Q$) instruction is represented by a character $H_i$ and an integer $T_i$, meaning the following:</p><ul><li>Perform some number of operations (possibly zero) so that your left hand (if $H_i$ is <code>L</code>) or your right hand (if $H_i$ is <code>R</code>) is holding part $T_i$. Here, you <strong>must not</strong> move the other hand not specified by $H_i$.</li></ul><p><strong>It is guaranteed that only achievable instructions are given.</strong></p><p>Details Under the settings of this problem, it can be proved that the positions of both hands are uniquely determined just before following the $i$-th instruction for each $i$. At that time, if we denote the positions of the left and right hands as parts $l_i$ and $r_i$, respectively, it is guaranteed that $T_i \neq r_i$ when $H_i$ is <code>L</code>, and $T_i \neq l_i$ when $H_i$ is <code>R</code>.</p><p>Find the minimum total number of operations required to follow all the instructions.</p></div><div class="tab-item-content" id="b-2"><p>$n$的环形格子。两个棋子，初始位于$0$, $1$。<br>给定 $q$个指令，每个指令指定一个棋子移动到某个格子上，期间不能移动另外一个棋子。<br>依次执行这些指令，问移动的次数。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-2">解题思路</h2><blockquote><p>简单模拟一下即可，可能我的代码有点“屎山”.</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(q --) &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        std::cin &gt;&gt; c &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;L&#x27;</span> &amp;&amp; x != l) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">if</span>(x &lt;= r) &#123;</span><br><span class="line">                    res += <span class="built_in">abs</span>(x - l);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res += (l + n - x);    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= r) &#123;</span><br><span class="line">                    res += <span class="built_in">abs</span>(x - l);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res += (x + n - l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l = x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;R&#x27;</span> &amp;&amp; x != r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= l) &#123;</span><br><span class="line">                    res += <span class="built_in">abs</span>(r - x);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res += (n - r + x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(x &lt;= l) &#123;</span><br><span class="line">                    res += <span class="built_in">abs</span>(r - x);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res += (r + n - x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.Prepare Another Box</h1><p><a href="https://atcoder.jp/contests/abc376/tasks/abc376_c">Prepare Another Box</a></p><h2 id="题目描述-3">题目描述</h2><div class="tabs" id="c"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c-1">英文题面</button><button type="button" class="tab " data-href="c-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c-1"><p>There are $N$ toys numbered from $1$ to $N$, and $N-1$ boxes numbered from $1$ to $N-1$. Toy $i\ (1 \leq i \leq N)$ has a size of $A_i$, and box $i\ (1 \leq i \leq N-1)$ has a size of $B_i$.</p><p>Takahashi wants to store all the toys in separate boxes, and he has decided to perform the following steps in order:</p><ol><li>Choose an arbitrary positive integer $x$ and purchase one box of size $x$.</li><li>Place each of the $N$ toys into one of the $N$ boxes (the $N-1$ existing boxes plus the newly purchased box). Here, each toy can only be placed in a box whose size is not less than the toy’s size, and no box can contain two or more toys.</li></ol><p>He wants to execute step $2$ by purchasing a sufficiently large box in step $1$, but larger boxes are more expensive, so he wants to purchase the smallest possible box.</p><p>Determine whether there exists a value of $x$ such that he can execute step $2$, and if it exists, find the minimum such $x$.</p></div><div class="tab-item-content" id="c-2"><p>给定 $n$个球的大小和$n - 1$个箱子的大小。现买一箱子，要求尺寸最小，使得 $n$个球恰好可以放进 $n$个箱子里,一个箱子有且只能放一个球。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-3">解题思路</h2><blockquote><p>要求找出箱子大小的最小值，那么我们可以先排个序，若最后一个箱子越大，可以放入的方法就越多，反之越少。那么我们怎么求找到这个值呢？我们只需要一个箱子我们可以去尝试每一个大小箱子，但是这不现实，于是就可以想到二分，可以大大减小时间复杂度，二分条件便是查看是否有球无法放入箱子。二分完成后，要检查二分后的答案是否满足题意。</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        std::cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; check = ([&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = b;</span><br><span class="line">        t.<span class="built_in">push_back</span>(x);</span><br><span class="line">        std::<span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; t[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = inf;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l == inf) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        std::cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Cycle</h1><p><a href="https://atcoder.jp/contests/abc376/tasks/abc376_d">Cycle</a></p><h2 id="题目描述-4">题目描述</h2><div class="tabs" id="d"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="d-1">英文题面</button><button type="button" class="tab " data-href="d-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="d-1"><p>There is a simple directed graph with $N$ vertices numbered from $1$ to $N$ and $M$ edges. The $i$-th edge $(1 \leq i \leq M)$ is a directed edge from vertex $a_i$ to vertex $b_i$.<br>Determine whether there exists a cycle that contains vertex $1$, and if it exists, find the minimum number of edges among such cycles.</p></div><div class="tab-item-content" id="d-2"><p>给定一张有向图，问包含点$1$的环的最小环点数。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-4">解题思路</h2><blockquote><p>要确保点数最小,且有回路，那么只有 $BFS$,从点 $1BFS$，每次到达点$1$时更新答案。</p></blockquote><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="function">std::vector <span class="title">a</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    a[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1ll</span>)</span></span>;</span><br><span class="line">  std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = inf;</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : a[t]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">        res = std::<span class="built_in">min</span>(res, dis[t] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(dis[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">        dis[i] = dis[t] + <span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(res &gt; n) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.Max × Sum</h1><p><a href="https://atcoder.jp/contests/abc376/tasks/abc376_e">Max × Sum</a></p><h2 id="题目描述-5">题目描述</h2><div class="tabs" id="e"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="e-1">英文题面</button><button type="button" class="tab " data-href="e-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="e-1"><p>You are given sequences of length $N$: $A = (A_1, A_2, \dots, A_N)$ and $B = (B_1, B_2, \dots, B_N)$.<br>Let $S$ be a subset of $\lbrace1, 2, \dots, N\rbrace$ of size $K$. Here, find the minimum possible value of the following expression:<br>$\displaystyle \left(\max_{i \in S} A_i\right) \times \left(\sum_{i \in S} B_i\right).$<br>You are given $T$ test cases; solve each of them.</p></div><div class="tab-item-content" id="e-2"><p>给定$n$, $k$和两数组 $A$,$B$，$S$是大小为 $k$ 的 ${1,2,…,N}$ 的子集,求 $\max_{i \in S} A_{i} * \sum_{i \in S}B_{i}$ 的最小值。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-5">解题思路</h2><blockquote><p>枚举$A_{i}$，剩下的问题就是找满足 $A_{j} \le A_{i}$的前$k-1$小的$B_{j}$的和。首先对数组 $A$进行排序，并且数组$B$与数组$A$一同变化（可以用pair）。然后依次枚举 $A_{i}$，此即为$\max_{i \in S} A_{i}$。然后找$1 \le j \le i$中最小的$k - 1$个$B_{i}$。考虑如何维护前 $k-1$小的和，因为会有不断的$B_{i}$加入，会不断淘汰较大的$B_{i}$，因此可以用优先队列维护这些 $B_{i}$在优先队列不断 <code>push</code>,<code>pop</code>时维护其里面的值的和即可。其时间复杂度为$O(n \log n)$注意枚举$A_{i}$时， $B_{i}$是一定要选的，因此要从优先队列里求出前$k - 1$小的和（但第$k$小的不能丢弃，它可能比$B_{i}$小，只是因为此时 $B_{i}$必选，因而暂时不能选它）。</p></blockquote><h2 id="参考代码-5">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">a</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i].first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i].second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [&amp;](pii aa, pii bb) &#123;</span><br><span class="line">    <span class="keyword">return</span> aa.first &lt; bb.first;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">  std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::less&lt;&gt; &gt; pq;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    pq.<span class="built_in">push</span>(a[i].second);</span><br><span class="line">    s += a[i].second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = s * a[k - <span class="number">1</span>].first;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &lt; pq.<span class="built_in">top</span>()) &#123;</span><br><span class="line">      s -= pq.<span class="built_in">top</span>();</span><br><span class="line">      pq.<span class="built_in">pop</span>();</span><br><span class="line">      pq.<span class="built_in">push</span>(y);</span><br><span class="line">      s += y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = std::<span class="built_in">min</span>(res, s * x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Atcoder abc 376 (A-E)</summary>
    
    
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/categories/atcoder/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder Beginner Contest 375</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/64713927.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/64713927.html</id>
    <published>2024-10-14T03:40:10.000Z</published>
    <updated>2025-08-22T02:37:23.079Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>建议查看中文题面，不要问为什么*(问就是，英文题面就是复制过来的，中文体面精简些),数据范围详见题目链接</p></div><h1>A.Seats</h1><p><a href="https://atcoder.jp/contests/abc375/tasks/abc375_a">Seats</a></p><h2 id="题目描述">题目描述</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button><button type="button" class="tab " data-href="a-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>There are $N$ seats in a row, numbered $1, 2, \ldots, N$.<br>The state of the seats is given by a string $S$ of length $N$ consisting of <code>#</code> and <code>.</code>. If the $i$-th character of $S$ is <code>#</code>, it means seat $i$ is occupied; if it is <code>.</code>, seat $i$ is unoccupied.<br>Find the number of integers $i$ between $1$ and $N - 2$, inclusive, that satisfy the following condition:</p><ul><li>Seats $i$ and $i + 2$ are occupied, and seat $i + 1$ is unoccupied.</li></ul></div><div class="tab-item-content" id="a-2"><p>给定字符串 $s$ 其中字符串只含有 <code>#</code> 和 <code>.</code> ,<code>#</code> 表示当前位置有人, <code>.</code>表示当前位置无人.<br>问:有多少个位置满足左右有人，当前位置无人的.</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  <span class="type">int</span> ct = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s[i] != s[i + <span class="number">1</span>] &amp;&amp; s[i + <span class="number">1</span>] == s[i - <span class="number">1</span>])</span><br><span class="line">      ct++;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Traveling Takahashi Problem</h1><p><a href="https://atcoder.jp/contests/abc375/tasks/abc375_b">Traveling Takahashi Problem</a></p><h2 id="题目描述-2">题目描述</h2><div class="tabs" id="b"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="b-1">英文题面</button><button type="button" class="tab " data-href="b-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="b-1"><p>Takahashi is at the origin on a two-dimensional coordinate plane.<br>The cost for him to move from point $(a, b)$ to point $(c, d)$ is $\sqrt{(a - c)^2 + (b - d)^2}$.<br>Find the total cost when he starts at the origin, visits $N$ points $(X_1, Y_1), \ldots, (X_N, Y_N)$ in this order, and then returns to the origin.</p></div><div class="tab-item-content" id="b-2"><p>给定$n$个点，从点 $(0,0)$ 出发依次经过这些点,然后回到原点的代价.<br>从点 $(a,b)$ 移动到点 $(c,d)$ 的代价是 $\sqrt{(a-c)^{2} + (b-d)^{2}}$</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    s += std::<span class="built_in">hypot</span>(u - x, y - v);</span><br><span class="line">    x = u, y = v;</span><br><span class="line">  &#125;</span><br><span class="line">  s += std::<span class="built_in">hypot</span>(x, y);</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">fix</span>(<span class="number">16</span>) &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.Spiral Rotation</h1><p><a href="https://atcoder.jp/contests/abc375/tasks/abc375_c">Spiral Rotation</a></p><h2 id="题目描述-3">题目描述</h2><div class="tabs" id="c"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c-1">英文题面</button><button type="button" class="tab " data-href="c-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c-1"><p>You are given a grid with $N$ rows and $N$ columns, where $N$ is an even number. Let $(i, j)$ denote the cell at the $i$-th row from the top and $j$-th column from the left.</p><p>Each cell is painted black or white. If $A_{i, j} =$ <code>#</code>, cell $(i, j)$ is black; if $A_{i, j} =$ <code>.</code>, it is white.</p><p>Find the color of each cell after performing the following operation for $i = 1, 2, \ldots, \frac{N}{2}$ in this order.</p><ul><li>For all pairs of integers $x, y$ between $i$ and $N + 1 - i$, inclusive, replace the color of cell $(y, N + 1 - x)$ with the color of cell $(x, y)$. Perform these replacements <strong>simultaneously for all such pairs $x, y$.</strong></li></ul></div><div class="tab-item-content" id="c-2"><p>题意太复杂，直接说重点，在 $N * N$ 的矩阵中,每个单元格都涂成黑色或白色。如果 $A_{i, j} =$ 则 $(i, j)$ 单元格为黑色；如果是 $A_{i, j} =$ <code>.</code>，则为黑色。.&quot;，则为白色。</p><p>依次对 $i = 1, 2, \ldots, \frac{N}{2}$ 进行以下操作:</p><p>对于 $i$ 和 $N + 1 - i$ 之间的所有整数对 $x, y$ ，将单元格 $(y, N + 1 - x)$ 的颜色替换为单元格 $(x, y)$ 的颜色。同时对所有这些单元格对 $x, y$ 进行替换。<br>最后打印这个矩阵。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><blockquote><p>稍加推理就可以发现对于每次操作 $i$都是在对以 $(i,i)$为左上角，大小为 $(N-i+1)*(N-i+1)$ 的子矩阵进行顺时针旋转 $90^{\circ}$</p></blockquote><h2 id="参考代码-3">参考代码</h2><p>TLE code</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; s[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; n / <span class="number">2</span>; a++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> t = s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a; i &lt; n - a; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = a; j &lt; n - a; j++) &#123;</span><br><span class="line">        t[i][j] = s[n - j - <span class="number">1</span>][i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AC code</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> N;</span><br><span class="line">  std::cin &gt;&gt; N;</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">A</span><span class="params">(N)</span>, <span class="title">B</span><span class="params">(N, std::string(N, <span class="string">&#x27; &#x27;</span>))</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)std::cin &gt;&gt; A[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt; N / <span class="number">2</span>; d++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; (d + <span class="number">1</span>) % <span class="number">4</span>; t++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x = d; x &lt; N - d; x++) &#123;</span><br><span class="line">        B[x][d] = A[x][d];</span><br><span class="line">        B[x][N - d - <span class="number">1</span>] = A[x][N - d - <span class="number">1</span>];</span><br><span class="line">        B[d][x] = A[d][x];</span><br><span class="line">        B[N - d - <span class="number">1</span>][x] = A[N - d - <span class="number">1</span>][x];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x = d; x &lt; N - d; x++) &#123;</span><br><span class="line">        A[d][N - x - <span class="number">1</span>] = B[x][d];</span><br><span class="line">        A[N - d - <span class="number">1</span>][N - x - <span class="number">1</span>] = B[x][N - d - <span class="number">1</span>];</span><br><span class="line">        A[x][N - d - <span class="number">1</span>] = B[d][x];</span><br><span class="line">        A[x][d] = B[N - d - <span class="number">1</span>][x];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i : A) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.ABA</h1><p><a href="https://atcoder.jp/contests/abc375/tasks/abc375_d">ABA</a></p><h2 id="题目描述-4">题目描述</h2><div class="tabs" id="d"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="d-1">英文题面</button><button type="button" class="tab " data-href="d-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="d-1"><p>You are given a string $S$ consisting of uppercase English letters.<br>Find the number of integer triples $(i, j, k)$ satisfying both of the following conditions:</p><ul><li>$1 \leq i &lt; j &lt; k \leq |S|$</li><li>The length-$3$ string formed by concatenating $S_i$, $S_j$, and $S_k$ in this order is a palindrome.</li></ul><p>Here, $|S|$ denotes the length of $S$, and $S_x$ denotes the $x$-th character of $S$.</p></div><div class="tab-item-content" id="d-2"><p>给你一个由大写英文字母组成的字符串 $S$ 。<br>求满足以下两个条件的整数三元组 $(i, j, k)$ 的个数：</p><ul><li>$1 \leq i &lt; j &lt; k \leq |S|$</li><li>将 $S_i$ 、 $S_j$ 和 $S_k$ 按此顺序连接而成的长度为 $3$ 的字符串是一个回文字符串。</li></ul><p>这里， $|S|$ 表示 $S$ 的长度， $S_x$ 表示 $S$ 的 $x$ -th字符。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-2">解题思路</h2><blockquote><p>这个其实就是前缀和维护当前位置前的每个字母个数和当前位置后的每个字母个数</p></blockquote><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  <span class="function">std::vector <span class="title">ct</span><span class="params">(<span class="number">26</span>, std::vector&lt;<span class="type">int</span>&gt;(s.size() + <span class="number">1</span>, <span class="number">0ll</span>))</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    ct[s[i] - <span class="string">&#x27;A&#x27;</span>][i]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">      ct[i][j] += ct[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">      ans += ct[j][i - <span class="number">1</span>] * (ct[j][s.<span class="built_in">size</span>() - <span class="number">1</span>] - ct[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Atcoder abc 375 (A-D)</summary>
    
    
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/categories/atcoder/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder beginner contest 374</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/8f16d66d.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/8f16d66d.html</id>
    <published>2024-10-07T06:07:03.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>建议查看中文题面，不要问为什么*(问就是，英文题面就是复制过来的，中文体面精简些)</p></div><h1>A.Takahashi san 2</h1><p><a href="https://atcoder.jp/contests/abc374/tasks/abc374_a">Takahashi san 2</a></p><h2 id="题目描述">题目描述</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button><button type="button" class="tab " data-href="a-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>KEYENCE has a culture of addressing everyone with the suffix “-san,” regardless of roles, age, or positions.<br>You are given a string $S$ consisting of lowercase English letters.<br>If $S$ ends with <code>san</code>, print <code>Yes</code>; otherwise, print <code>No</code>.</p></div><div class="tab-item-content" id="a-2"><p>判断字符串末尾是否有 <code>san</code> 这个后缀</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  std::string t = s.<span class="built_in">substr</span>(s.<span class="built_in">size</span>() - <span class="number">3</span>);</span><br><span class="line">  std::cout &lt;&lt; (t == <span class="string">&quot;san&quot;</span> ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Unvarnished Report</h1><p><a href="https://atcoder.jp/contests/abc374/tasks/abc374_b">Unvarnished Report</a></p><h2 id="题目描述-2">题目描述</h2><div class="tabs" id="b"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="b-1">英文题面</button><button type="button" class="tab " data-href="b-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="b-1"><p>You are given two strings $S$ and $T$, consisting of lowercase English letters.<br>If $S$ and $T$ are equal, print $0$; otherwise, print the position of the first character where they differ.<br>Here, if the $i$-th character exists in only one of $S$ and $T$, consider that the $i$-th characters are different.</p><p>More precisely, if $S$ and $T$ are not equal, print the smallest integer $i$ satisfying one of the following conditions:</p><ul><li>$1\leq i\leq |S|$, $1\leq i\leq |T|$, and $S_i\neq T_i$.</li><li>$|S| &lt; i \leq |T|$.</li><li>$|T| &lt; i \leq |S|$.</li></ul><p>Here, $|S|$ and $|T|$ denote the lengths of $S$ and $T$, respectively, and $S_i$ and $T_i$ denote the $i$-th characters of $S$ and $T$, respectively.</p></div><div class="tab-item-content" id="b-2"><p>给定字符串 $S$ 和 $T$,若字符串 $S$ 和字符串 $T$ 完全相等,则输出 $0$ 否则输出 $S$ 和 $T$ 第一个不相同的位置.</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><blockquote><p>首先判断两个字符串是否相同,</p><p>若相同直接输出 $0$</p><p>否则用 $for$ 遍历一次字符串</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string s, t;</span><br><span class="line">  std::cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">  <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; std::<span class="built_in">max</span>(s.<span class="built_in">size</span>(), t.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] != t[i]) &#123;</span><br><span class="line">      std::cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>C.Separated Lunch</h1><p><a href="https://atcoder.jp/contests/abc374/tasks/abc374_c">Separated Lunch</a></p><h2 id="题目描述-3">题目描述</h2><div class="tabs" id="c"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c-1">英文题面</button><button type="button" class="tab " data-href="c-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c-1"><p>As KEYENCE headquarters have more and more workers, they decided to divide the departments in the headquarters into two groups and stagger their lunch breaks.</p><p>KEYENCE headquarters have $N$ departments, and the number of people in the $i$-th department $(1\leq i\leq N)$ is $K_i$.</p><p>When assigning each department to Group $A$ or Group $B$, having each group take lunch breaks at the same time, and ensuring that the lunch break times of Group $A$ and Group $B$ do not overlap, find the minimum possible value of the maximum number of people taking a lunch break at the same time.<br>In other words, find the minimum possible value of the larger of the following: the total number of people in departments assigned to Group $A$, and the total number of people in departments assigned to Group $B$.</p></div><div class="tab-item-content" id="c-2"><p>给出一个数 $n$, 和一个长度为 $n$ 的数组 $K$, 将这个数组划分为 $A$ , $B$两个部分,使得这两个部分的和 $S_{A}$ 和 $S_{B}$ 中的最大值最小</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><blockquote><p>数据范围:<br>$2 \leq n \leq 20$,<br>$1 \leq K_{i} \leq 10^{8}$</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>瞄一眼中文题面, 有点像 $01$ 背包, 但是你可以发现数据范围好像不能用背包，有没有其他方法呢?</p><p>好像 $n$ 的范围比较小，我们可以使用 $dfs$ 来搜索每一种情况，最多为 $2^{20}$,那么怎么判断哪种情况最优?只需要满足 $S_{A}$和 $S_{B}$ 的差值最小，答案即为差值最小时的最大值。</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, w = <span class="number">0</span>;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i];</span><br><span class="line">    w += a[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> mi = inf, ans = inf;</span><br><span class="line">  std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = ([&amp;](<span class="type">int</span> u) &#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt;= n) &#123;</span><br><span class="line">      <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i]) &#123;</span><br><span class="line">          s += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mi &gt;= <span class="built_in">abs</span>(w - s - s)) &#123;</span><br><span class="line">        mi = <span class="built_in">abs</span>(w - s - s);</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, std::<span class="built_in">max</span>(s, w - s));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">    f[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Laser Marking</h1><p><a href="https://atcoder.jp/contests/abc374/tasks/abc374_d">Laser Marking</a></p><h2 id="题目描述-4">题目描述</h2><div class="tabs" id="d"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="d-1">英文题面</button><button type="button" class="tab " data-href="d-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="d-1"><p>There is a printing machine that prints line segments on the $xy$-plane by emitting a laser.</p><ul><li><p>At the start of printing, the laser position is at coordinate $(0, 0)$.</p></li><li><p>When printing a line segment, the procedure below is followed.</p><ul><li>First, move the laser position to one of the endpoints of the line segment.<ul><li>One may start drawing from either endpoint.</li></ul></li><li>Then, move the laser position in a straight line from the current endpoint to the other endpoint while emitting the laser.<ul><li>It is not allowed to stop printing in the middle of a line segment.</li></ul></li></ul></li><li><p>When not emitting the laser, the laser position can move in any direction at a speed of $S$ units per second.</p></li><li><p>When emitting the laser, the laser position can move along the line segment being printed at a speed of $T$ units per second.</p></li><li><p>The time required for operations other than moving the laser position can be ignored.</p></li></ul><p>Takahashi wants to print $N$ line segments using this printing machine.<br>The $i$-th line segment connects coordinates $(A_i, B_i)$ and $(C_i, D_i)$.<br>Some line segments may overlap, in which case he needs to print the overlapping parts for each line segment separately.</p><p>What is the minimum number of seconds required to complete printing all the line segments when he operates the printing machine optimally?</p></div><div class="tab-item-content" id="d-2"><p>在一个平面上给出 $n$ 条线段的起始点$(A_{i}, B_{i})$和终点$(C_{i}, D_{i})$ 现在要使用激光打印机打印这些线段,在打印线段时的移动速度为每秒 $T$ 个单位长度, 不打印的时候的移动速度为每秒 $S$ 个单位长度, 问打印这些线段的最短时间为多少？</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-3">解题思路</h2><blockquote><p>由于一个线段可以从两个端点中的任意一个开始打印，看来这个题又和上面一个题一样使用 $dfs$ ,循环初始到达线段,先移动到其中一个端点,再移动到另一个端点，答案记录下来，再$dfs$, $dfs$函数中的参数 $x$, $y$, $u$, $v$ 表示在此之前是从点$(x,y)$ 移动到了 $(u,v)$.其实 $dfs$ 只传当前位置就行了,只是个人方便识别.</p></blockquote><h2 id="参考代码-4">参考代码</h2><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>hypot()函数详解：<br>hypot(x, y) 返回的是浮点型数据类型,值为 $\sqrt{x^{2} + y^{2}}$ 即将$x, y$作为直角三角形的两条直角边的斜边。<br>hypot(x,y,z) 返回类型同上值为 $\sqrt{x^{2} + y^{2} + z^{2}}$</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, s, t;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; t;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">A</span><span class="params">(n)</span>, <span class="title">B</span><span class="params">(n)</span>, <span class="title">C</span><span class="params">(n)</span>, <span class="title">D</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    std::cin &gt;&gt; A[i] &gt;&gt; B[i] &gt;&gt; C[i] &gt;&gt; D[i];</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="type">double</span> ans = INFINITY, w = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> check = [&amp;]() -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (!vis[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = ([&amp;](<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> u, <span class="type">int</span> v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>()) &#123;</span><br><span class="line">      ans = std::<span class="built_in">min</span>(ans, w);</span><br><span class="line"><span class="comment">//      std::cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> t1 = std::<span class="built_in">hypot</span>(u - A[i], v - B[i]) / s;</span><br><span class="line">        <span class="keyword">auto</span> t2 = std::<span class="built_in">hypot</span>(u - C[i], v - D[i]) / s;</span><br><span class="line">        <span class="keyword">auto</span> tt = std::<span class="built_in">hypot</span>(A[i] - C[i], B[i] - D[i]) / t;</span><br><span class="line">        w += tt, w += t1;</span><br><span class="line">        <span class="built_in">dfs</span>(A[i], B[i], C[i], D[i]);</span><br><span class="line">        w -= t1, w += t2;</span><br><span class="line">        <span class="built_in">dfs</span>(C[i], D[i], A[i], B[i]);</span><br><span class="line">        w -= t2, w -= tt;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    vis[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">hypot</span>(A[i], B[i]) / s;</span><br><span class="line">    <span class="keyword">auto</span> t2 = std::<span class="built_in">hypot</span>(C[i], D[i]) / s;</span><br><span class="line">    <span class="keyword">auto</span> tt = std::<span class="built_in">hypot</span>(A[i] - C[i], B[i] - D[i]) / t;</span><br><span class="line">    w = t1 + tt;</span><br><span class="line">    <span class="built_in">dfs</span>(A[i], B[i], C[i], D[i]);</span><br><span class="line">    w = t2 + tt;</span><br><span class="line">    <span class="built_in">dfs</span>(C[i], D[i], A[i], B[i]);</span><br><span class="line">    vis[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">fix</span>(<span class="number">16</span>) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Atcoder abc 374 (A-D)</summary>
    
    
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/categories/atcoder/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 971 (Div. 4)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/d7318f12.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/d7318f12.html</id>
    <published>2024-09-04T01:18:56.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<h1>A. Minimize!</h1><p><a href="https://codeforces.com/contest/2009/problem/A">Minimize!</a></p><h2 id="题目描述">题目描述</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button><button type="button" class="tab " data-href="a-2">中文简义</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>You are given two integers a and b (a≤b). Over all possible integer values of c (a≤c≤b), find the minimum value of (c−a)+(b−c).</p></div><div class="tab-item-content" id="a-2"><p>给定数字 $a$ , $b$ ,一个数 $c$ 的取值范围为 $[a,b]$ 求 $(c-a)+(b-c)$ 的最小值</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><blockquote><p>我们对等式化简 $(c-a)+(b-c) \to b-a$ 由此可见,等式的结果与 $c$ 的值无关</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  std::cout &lt;&lt; b - a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.osu!mania</h1><p><a href="https://codeforces.com/contest/2009/problem/B">osu!mania</a></p><h2 id="题目描述-2">题目描述</h2><div class="tabs" id="b"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="b-1">英文题面</button><button type="button" class="tab " data-href="b-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="b-1"><p>You are playing your favorite rhythm game, osu!mania. The layout of your beatmap consists of $n$ rows and <code>4</code> columns. Because notes at the bottom are closer, you will process the bottommost row first and the topmost row last. Each row will contain exactly one note, represented as a ‘#’.<br>For each note 1,2,…,n, in the order of processing, output the column in which the note appears.</p></div><div class="tab-item-content" id="b-2"><p>给定 $n$ 行 <code>4</code> 列的字符串,从下向上处理字符串，输出该行字符串的 <code>#</code> 的位置</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-2">解题思路</h2><blockquote><p>中文题面说得很清楚,用<code>STL</code>中的<code>find</code>函数就可以了</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; s[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    std::cout &lt;&lt; s[i].<span class="built_in">find</span>(<span class="string">&#x27;#&#x27;</span>) + <span class="number">1</span> &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == <span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.The Legend of Freya the Frog</h1><p><a href="https://codeforces.com/contest/2009/problem/C">The Legend of Freya the Frog</a></p><h2 id="题目描述-3">题目描述</h2><div class="tabs" id="c"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c-1">英文题面</button><button type="button" class="tab " data-href="c-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c-1"><p>Freya the Frog is traveling on the 2D coordinate plane. She is currently at point (0,0) and wants to go to point (x,y). In one move, she chooses an integer d such that 0≤d≤k and jumps d spots forward in the direction she is facing.</p><p>Initially, she is facing the positive x direction. After every move, she will alternate between facing the positive x direction and the positive y direction (i.e., she will face the positive y direction on her second move, the positive x direction on her third move, and so on).</p><p>What is the minimum amount of moves she must perform to land on point (x,y)?</p></div><div class="tab-item-content" id="c-2"><p>在一个二维平面中,当前位置处于点 $(0,0)$ , 在给定一个数 $k$,每次移动的距离为 $d (0 \le d \le k) $,并且每次移动方向是在 $x$ 和 $y$ 轴正方向之间交替.<br>问需要就次移动到达点 $(x,y)$?</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-3">解题思路</h2><blockquote><p>分别考虑 $x$ 和 $y$ 两个方向，计算我们在每个方向上需要的跳转次数。我们在 $x$ 方向上需要的跳转数是 $\lceil \frac{x}{k} \rceil$ ，类似地，在 $y$ 方向上需要的跳转数是 $\lceil \frac{y}{k} \rceil$ 。现在，让我们试着将它们组合起来，求出跳转的总次数。让我们考虑以下几种情况：</p><ul><li>$\lceil \frac{y}{k} \rceil \geq \lceil \frac{x}{k} \rceil$ .在这种情况下，需要在 $y$ 方向上进行 $\lceil \frac{y}{k} \rceil - \lceil \frac{x}{k} \rceil$ 次额外跳跃。在弗莱娅执行这些额外跳跃时，她会选择 $x$ 方向的 $d = 0$ 。总共需要 $2 \cdot \lceil \frac{y}{k} \rceil$ 次跳跃。</li><li>$\lceil \frac{x}{k} \rceil &lt; \lceil \frac{y}{k} \rceil$ .我们可以使用与前一种情况相同的推理方法，但是有一个问题。由于弗莱娅一开始是朝向 $x$ 方向的，所以在最后一跳时，她不需要朝向 $y$ 方向跳。总共需要 $2 \cdot \lceil \frac{x}{k} \rceil - 1$ 次跳跃。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, k;</span><br><span class="line">  std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">  x = (x + k - <span class="number">1</span>) / k;</span><br><span class="line">  y = (y + k - <span class="number">1</span>) / k;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; std::<span class="built_in">max</span>(<span class="number">2</span> * x - <span class="number">1</span>, <span class="number">2</span> * y) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Satyam and Counting</h1><p><a href="https://codeforces.com/contest/2009/problem/D">Satyam and Counting</a></p><h2 id="题目描述-4">题目描述</h2><div class="tabs" id="d"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="d-1">英文题面</button><button type="button" class="tab " data-href="d-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="d-1"><p>Satyam is given $n$ distinct points on the 2D coordinate plane. It is guaranteed that $0 \leq y_i \leq 1$ for all given points $(x_i, y_i)$. How many different nondegenerate right triangles$^{\text{∗}}$ can be formed from choosing three different points as its vertices?<br>Two triangles $a$ and $b$ are different if there is a point $v$ such that $v$ is a vertex of $a$ but not a vertex of $b$.<br>$^{\text{∗}}$A nondegenerate right triangle has positive area and an interior $90^{\circ}$ angle.</p></div><div class="tab-item-content" id="d-2"><p>给出 $n$ 个点的坐标, 并且点的位置至多两行,数据范围:$(0 \le x_{i} \le n, 0 \le y_{i} \le 1)$,问这些点能组成多少个直角三角形?</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-4">解题思路</h2><blockquote><p>对于点 $(x,y)$形成直角三角形分为以下情况</p><ul><li>以点 $(x,1-y)$ 为三角形的直角顶点,那么这个情况的三角形的个数为点 ($(x, 1-y)$ 的个数 -1)</li><li>以点 $(x,y)$ 为三角形的直角顶点,我们就需要判断点$(x-1,1-y)$ 和点 $(x+1,1-y)$ 是否存在,若存在则这样的三角形的个数为 $1$</li></ul></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(n, <span class="number">0ll</span>)</span>, <span class="title">y</span><span class="params">(n, <span class="number">0ll</span>)</span>, <span class="title">cnt</span><span class="params">(<span class="number">2</span>, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">  <span class="function">std::vector <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, std::array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    cnt[y[i]]++;</span><br><span class="line">    vis[x[i]][y[i]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x[i]][<span class="number">1</span> - y[i]]) &#123;</span><br><span class="line">      res += cnt[<span class="number">1</span> - y[i]] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x[i] &gt; <span class="number">0</span> &amp;&amp; x[i] &lt; n &amp;&amp; vis[x[i] - <span class="number">1</span>][<span class="number">1</span> - y[i]] &amp;&amp; vis[x[i] + <span class="number">1</span>][<span class="number">1</span> - y[i]]) &#123;</span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.Klee’s SUPER DUPER LARGE Array!!!</h1><p><a href="https://codeforces.com/contest/2009/problem/E">Klee’s SUPER DUPER LARGE Array!!!</a></p><h2 id="题目描述-5">题目描述</h2><div class="tabs" id="e"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="e-1">英文题面</button><button type="button" class="tab " data-href="e-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="e-1"></div><div class="tab-item-content" id="e-2"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-5">解题思路</h2><blockquote></blockquote><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Codeforces Round 941 div.4 (A-D)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 967 (Div. 2)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/4dfb8713.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/4dfb8713.html</id>
    <published>2024-09-02T11:26:28.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<h1>A.<a href="https://codeforces.com/contest/2001/problem/A">Make All Equal</a></h1><h2 id="题目描述">题目描述</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button><button type="button" class="tab " data-href="a-2">中文简义</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>You are given a cyclic array $a_1,a_2,…,a_n$ .<br>You can perform the following operation on a at most $n−1$ times:</p><ul><li>Let m be the current size of a, you can choose any two adjacent elements where the previous one is no greater than the latter one (In particular, $a_m$ and $a_1$ are adjacent and $a_m$ is the previous one), and delete exactly one of them. In other words, choose an integer i ( $1 \le i \le m$ ) where $a_i \le a_{(i \mod m)+1}$ holds, and delete exactly one of $a_i$ or $a_{(i \mod m) + 1}$ from aa.<br>Your goal is to find the minimum number of operations needed to make all elements in aa equal.</li></ul></div><div class="tab-item-content" id="a-2"><p>题目意思是想让我们用最少的操作次数删除数组中的元素获得数组中的数字全相等的数组。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><blockquote><p>由于需要最小的操作数，我们可以直接剩下数目最多的数字，于是就可以使用 <code>STL</code> 中的 <code>map</code> 完成此题</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; x;</span><br><span class="line">    mp[x]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : mp) &#123;</span><br><span class="line">    res = std::<span class="built_in">max</span>(res, y);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; n - res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.<a href="https://codeforces.com/contest/2001/problem/B">Generate Permutation</a></h1><h2 id="题目描述-2">题目描述</h2>]]></content>
    
    
    <summary type="html">codeforces-round-967(A-B)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder Beginner Contest 367</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/9364694a.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/9364694a.html</id>
    <published>2024-08-25T11:30:34.000Z</published>
    <updated>2025-08-22T02:37:23.079Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://atcoder.jp/contests/abc367/tasks/abc367_a">Shout Everyday</a></h1><h2 id="题目">题目</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button><button type="button" class="tab " data-href="a-2">中文简义</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>In the Kingdom of AtCoder, residents are required to shout their love for takoyaki at<br>A o’clock every day.<br>Takahashi, who lives in the Kingdom of AtCoder, goes to bed at<br>B o’clock and wakes up at C o’clock every day (in the 24-hour clock). He can shout his love for takoyaki when he is awake, but cannot when he is asleep. Determine whether he can shout his love for takoyaki every day. Here, a day has 24 hours, and his sleeping time is less than 24 hours.</p></div><div class="tab-item-content" id="a-2"><p>给定一个整数时间 <code>A</code>,一个人在<code>B</code>时间睡觉,<code>C</code>时间起床(24小时制),问<code>A</code>是否不在睡觉时间</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><blockquote><p>我们可以先判断<code>B</code>，<code>C</code>这个时间段是否是跨越两天的，若是跨越两天， <code>A &lt; B &amp;&amp; A &gt; C</code>  才会不在这个时间段<br>若未跨越两天  <code>A &lt; B || A &gt; C</code> 满足不在 <code>B，C</code> 时间段</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a, b, c;</span><br><span class="line">  std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">  <span class="keyword">if</span> (b &gt; c) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= b || a &lt;= c) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= b &amp;&amp; a &lt;= c) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://atcoder.jp/contests/abc367/tasks/abc367_b">Cut .0</a></h1><h2 id="题目-2">题目</h2><div class="tabs" id="b"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="b-1">英文题面</button><button type="button" class="tab " data-href="b-2">中文简义</button></ul><div class="tab-contents"><div class="tab-item-content active" id="b-1"><p>A real number $X$ is given to the third decimal place.<br>Print the real number $X$ under the following conditions.</p><ul><li>The decimal part must not have trailing <code>0</code>s.</li><li>There must not be an unnecessary trailing decimal point.</li></ul></div><div class="tab-item-content" id="b-2"><p>一个实数 $X$ 已精确到小数点后第三位。<br>请在下列条件下打印实数 $X$ 。</p><ul><li>小数部分不能有尾数 “0”。</li><li>小数点后不能有多余的尾数。</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string s, <span class="built_in">t</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt += f;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="string">&#x27;.&#x27;</span>) f = <span class="number">1</span>;</span><br><span class="line">    t = t + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (t.<span class="built_in">back</span>() == <span class="string">&#x27;0&#x27;</span>) t.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">if</span> (t.<span class="built_in">back</span>() == <span class="string">&#x27;.&#x27;</span>) t.<span class="built_in">pop_back</span>();</span><br><span class="line">  std::cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://atcoder.jp/contests/abc367/tasks/abc367_c">Enumerate Sequences</a></h1><h2 id="题目-3">题目</h2><div class="tabs" id="c"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c-1">英文题面</button><button type="button" class="tab " data-href="c-2">中文简义</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c-1"><p>Print all integer sequences of length $N$ that satisfy the following conditions, in ascending lexicographical order.</p><ul><li>The $i$-th element is between $1$ and $R_i$, inclusive.</li><li>The sum of all elements is a multiple of $K$.</li></ul></div><div class="tab-item-content" id="c-2"><p>按升序排列打印所有满足以下条件的长度为 $N$ 的整数序列。</p><ul><li>第 $i$ 个元素介于 $1$ 和 $R_i$ 之间。</li><li>所有元素之和是 $K$ 的倍数。</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-2">解题思路</h2><blockquote><p>由于每个数都介于$1$和 $R_i$之间，我们可以遍历每个位置的每个数，显然$DFS$可以做到<br>那么回溯条件是什么呢？<br>显然是走到第$N$个数，那么答案就只需要验证下这$N$个数的和是否为$K$的倍数</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> VI = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="function">VI <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  std::vector&lt;VI&gt; ans;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">VI <span class="title">w</span><span class="params">(n, <span class="number">1ll</span>)</span></span>;</span><br><span class="line">  std::function&lt;<span class="type">void</span> (<span class="type">int</span>)&gt; dfs = ([&amp;] (<span class="type">int</span> u) &#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">      <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> i : w) res += i;</span><br><span class="line">      <span class="keyword">if</span> (res % k == <span class="number">0</span>) ans.<span class="built_in">push_back</span>(w);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[u]; i++) &#123;</span><br><span class="line">      w[u] = i;</span><br><span class="line">      <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), [&amp;] (VI aa, VI bb) &#123; <span class="keyword">return</span> aa &lt; bb; &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> q : ans) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : q) &#123;</span><br><span class="line">      std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D  <a href="https://atcoder.jp/contests/abc367/tasks/abc367_d">Pedometer</a></h1><h2 id="题目-4">题目</h2><div class="tabs" id="d"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="d-1">英文题面</button><button type="button" class="tab " data-href="d-2">中文简义</button></ul><div class="tab-contents"><div class="tab-item-content active" id="d-1"><h3 id="Problem-Statement">Problem Statement</h3><p>There are $N$ rest areas around a lake.<br>The rest areas are numbered $1$, $2$, …, $N$ in clockwise order.<br>It takes $A_i$ steps to walk clockwise from rest area $i$ to rest area $i+1$ (where rest area $N+1$ refers to rest area $1$).<br>The minimum number of steps required to walk clockwise from rest area $s$ to rest area $t$ ($s \neq t$) is a multiple of $M$.<br>Find the number of possible pairs $(s,t)$.</p></div><div class="tab-item-content" id="d-2"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-3">解题思路</h2><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> N, M;</span><br><span class="line">  std::cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) std::cin &gt;&gt; A[i], pre[i + <span class="number">1</span>] = pre[i] + A[i];</span><br><span class="line"></span><br><span class="line">  std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> L = pre[N];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    ans += cnt[(pre[i] - L % M + M) % M];</span><br><span class="line">    ans += cnt[pre[i] % M]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Atcoder abc 367(A-D)</summary>
    
    
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/categories/atcoder/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder beginner contest 373</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/117243ce.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/117243ce.html</id>
    <published>2024-08-25T11:30:34.000Z</published>
    <updated>2025-08-22T02:37:23.079Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>建议查看中文题面，不要问为什么(问就是，英文题面就是复制过来的，中文体面精简些)</p></div><h1>A September</h1><p><a href="https://atcoder.jp/contests/abc373/tasks/abc373_a">September</a></p><h2 id="题目描述">题目描述</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button><button type="button" class="tab " data-href="a-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>There are $12$ strings $S_1, S_2, \ldots, S_{12}$ consisting of lowercase English letters.</p><p>Find how many integers $i$ $(1 \leq i \leq 12)$ satisfy that the length of $S_i$ is $i$.</p></div><div class="tab-item-content" id="a-2"><p>有 $12$ 个字符串 $S_1, S_2, S_3, \cdots S_{12}$<br>问有几个字符串满足 $S_{i} = i (1 \le i \le 12)$</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><blockquote><p>太简单不需要解释</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ct = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == i + <span class="number">1</span>) ct++;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B 1D Keyboard</h1><p><a href="https://atcoder.jp/contests/abc373/tasks/abc373_b">1D Keyboard</a></p><h2 id="题目描述-2">题目描述</h2><div class="tabs" id="b"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="b-1">英文题面</button><button type="button" class="tab " data-href="b-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="b-1"><h3 id="Problem-Statement">Problem Statement</h3><p>There is a keyboard with $26$ keys arranged on a number line.</p><p>The arrangement of this keyboard is represented by a string $S$, which is a permutation of <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>. The key corresponding to the character $S_x$ is located at coordinate $x$ $(1 \leq x \leq 26)$. Here, $S_x$ denotes the $x$-th character of $S$.</p><p>You will use this keyboard to input <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> in this order, typing each letter exactly once with your right index finger. To input a character, you need to move your finger to the coordinate of the key corresponding to that character and press the key.</p><p>Initially, your finger is at the coordinate of the key corresponding to <code>A</code>. Find the minimal possible total traveled distance of your finger from pressing the key for <code>A</code> to pressing the key for <code>Z</code>. Here, pressing a key does not contribute to the distance.</p></div><div class="tab-item-content" id="b-2"><p>给定长度为 $26$ 的字符串，并且保证字符串每个英文字母只出现一次,当前第 $0$ 步时处于 $A$ 点, 问需要走多少步会使得字符串所走过的路径为 $ABC…XYZ$.简单点说就是从 $A$ 点走到 $B$ 点,再到 $C$ 点,以此类推,知道 $Z$ 点,至少需要走多少步?</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><blockquote><p>由于字符串中一个字母只会出现一次,我们就可以将每个字母的位置记录下来,然后再依次算出相邻两个点的距离,即可得出答案.</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">  std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    mp[s[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> now = mp[<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">  <span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">  mp.<span class="built_in">erase</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> [c, pos] : mp) &#123;</span><br><span class="line">    w += <span class="built_in">abs</span>(now - pos);</span><br><span class="line">    now = pos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C Max Ai+Bj</h1><p><a href="https://atcoder.jp/contests/abc373/tasks/abc373_c">Max Ai+Bj</a></p><h2 id="题目描述-3">题目描述</h2><div class="tabs" id="c"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c-1">英文题面</button><button type="button" class="tab " data-href="c-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c-1"><h3 id="Problem-Statement">Problem Statement</h3><p>You are given two integer sequences $A$ and $B$, each of length $N$. Choose integers $i, j$ $(1 \leq i, j \leq N)$ to maximize the value of $A_i + B_j$.</p></div><div class="tab-item-content" id="c-2"><h4 id="问题陈述">问题陈述</h4><p>给你两个整数序列 $A$ 和 $B$ ，每个长度为 $N$ 。请选择整数 $i, j$ $(1 \leq i, j \leq N)$ 使其长度最大化。 $(1 \leq i, j \leq N)$ 使 $A <em>{i} + B</em>{j}$ 的值最大。输出最大值。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-2">解题思路</h2><blockquote><p>选择尽量大的 $i,j$ 使得 $A_{i} + B_{j}$最大,为了使得和最大,只需要分别选择两个数组的最大值，才能使得和最大。</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">  std::<span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">  std::cout &lt;&lt; a[n - <span class="number">1</span>] + b[n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Atcoder abc 373(A-C)</summary>
    
    
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/categories/atcoder/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces-Round-974-Div-3</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/ab8ad312.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/ab8ad312.html</id>
    <published>2024-08-22T07:40:48.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<h1>A. Robin Helps</h1><p><a href="https://codeforces.com/contest/2014/problem/A">Robin Helps</a></p><h2 id="题目描述">题目描述</h2><div class="tabs" id="a"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="a-1">英文题面</button><button type="button" class="tab " data-href="a-2">中文简义</button></ul><div class="tab-contents"><div class="tab-item-content active" id="a-1"><p>There is a little bit of the outlaw in everyone, and a little bit of the hero too.  The heroic outlaw Robin Hood is famous for taking from the rich and giving to the poor.  Robin encounters n people starting from the 1\-st and ending with the n\-th. The i\-th person has ai gold. If ai≥k, Robin will take all ai gold, and if ai\=0, Robin will give 1 gold if he has any. Robin starts with 0 gold.  Find out how many people Robin gives gold to.</p></div><div class="tab-item-content" id="a-2"><p>给定 $n$ 和 $k$ ,和一个长度为 $n$ 的数组 $a$ ,金币初始值为 <code>0</code> 当 $a_{i} \ge k$ 时,会将 $a_{i}$ 全部取走(即金币数+$a_{i}$), 若 $a_{i}=0$ 并且金币数不为 <code>0</code> 那么会给他一个金币,问最后给了多少人金币?</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路">解题思路</h2><blockquote><p>其实只需要将过程模拟下即可</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; a[i];</span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt;= k) &#123;</span><br><span class="line">      s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == <span class="number">0</span> &amp;&amp; s) &#123;</span><br><span class="line">      s -= <span class="number">1</span>;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>B. Robin Hood and the Major Oak</h1><p><a href="https://codeforces.com/contest/2014/problem/B">Robin Hood and the Major Oak</a></p><h2 id="题目描述-2">题目描述</h2><div class="tabs" id="b"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="b-1">英文题面</button><button type="button" class="tab " data-href="b-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="b-1"><p>In Sherwood, the trees are our shelter, and we are all children of the forest.</p><p>The Major Oak in Sherwood is known for its majestic foliage, which provided shelter to Robin Hood and his band of merry men and women.</p><p>The Major Oak grows ii new leaves in the i-th year. It starts with 1 leaf in year 1.</p><p>Leaves last for k years on the tree. In other words, leaves grown in year i last between years i and i+k−1 inclusive.</p><p>Robin considers even numbers lucky. Help Robin determine whether the Major Oak will have an even number of leaves in year n.</p></div><div class="tab-item-content" id="b-2"><p>大橡树在第(i)年会长出两片新叶。第 1 年开始长 1 片叶子。</p><p>树叶在树上可以存活 k 年。换句话说，第 i 年长出的树叶在第 i 年和第 i+k-1 年(包括第 i+k-1 年)之间持续生长。</p><p>罗宾认为偶数是幸运数字。请帮助罗宾判断这棵橡树在第 n 年的叶子数是否为偶数。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><p>==数据范围:==</p><blockquote><p>$$<br>1 \le n \le 10^{9}, 1 \le k \le n<br>$$</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>由于一片树叶的存活期为 $k$ 我们不妨只看后面 $k$ 年的树叶, 对于第 $i$ 年的树叶数量为 $i^ {i}$ ,但是数据范围较大,容易 <code>TLE</code> 或者是爆  <code>longlong</code> ,怎么办呢? 我们可以观察出一个性质: 相同奇偶性的底数和指数的结果奇偶性不变,那么就可以将这个问题化解为 $[n-k+1, n]$ 这个区间的所有数的和</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="type">int</span> l = n - k + <span class="number">1</span>, r = n;</span><br><span class="line">  <span class="type">int</span> s = (l + r) * k / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (s &amp; <span class="number">1</span>) std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>C. Robin Hood in Town</h1><p><a href="https://codeforces.com/contest/2014/problem/C">Robin Hood in Town</a></p><h2 id="题目描述-3">题目描述</h2><div class="tabs" id="c"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c-1">英文题面</button><button type="button" class="tab " data-href="c-2">中文题面</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c-1"><p>There are <strong>n</strong> people living in the town. Just now, the wealth of the <strong>i</strong>-th person was <strong>a</strong>i gold. But guess what? The richest person has found an extra pot of gold!</p><p>More formally, find an <strong>a</strong>j**=<strong>m</strong>a<strong>x</strong>(<strong>a</strong>1**,<strong>a</strong>2**,<strong>…</strong>,<strong>a</strong>n**), change <strong>a</strong>j to <strong>a</strong>j**+**x, where <strong>x</strong> is a non-negative integer number of gold found in the pot. If there are multiple maxima, it can be any one of them.</p><p>A person is unhappy if their wealth is <strong>strictly less than half</strong> of the average wealth<strong>∗</strong>.</p><p>If <strong>strictly more than half</strong> of the total population <strong>n</strong> are unhappy, Robin Hood will appear by popular demand.</p><p>Determine the minimum value of <strong>x</strong> for Robin Hood to appear, or output <strong>−</strong>1 if it is impossible.</p></div><div class="tab-item-content" id="c-2"><p>给定长度为 $n$ 的数组 $a$ ,现在要将数 $x$ 加在数组中的最大值上,使得整个数组中小于平均值的一半的数目大于 $\frac{n}{2}$ ,问数 $x$ 的最小值为多少?</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="解题思路-3">解题思路</h2><blockquote><p>打眼一看,二分没问题了<br>已知是将 $x$ 加在最大值上,那么我们可以将数组进行排序,为了使得满足条件 $a_{i}&lt;\frac{\sum_{i=1}^{n}a_{i}}{n<em>2}$ 的数目大于 $\frac{n}{2}$ 那么就只需要在排序好的数组中找到前 $\frac{n}{2}$ 个最小值,只要这其中的最大值都比 $\frac{\sum_{i=1}^{n}a_{i}}{n</em>2}$ 小,就可以满足条件.</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, s = <span class="number">0</span>;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; a[i], s += a[i];</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">  std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; check = ([&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> t = (s + x * <span class="number">1.0</span> ) / (n * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> a[n / <span class="number">2</span>] &lt; t;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e16</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Codeforces Round 974(A-C)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder beginner contest 339</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/1a1edf65.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/1a1edf65.html</id>
    <published>2024-08-15T10:43:36.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<h1>A  <a href="https://atcoder.jp/contests/abc339/tasks/abc339_a">TLD</a></h1><h2 id="题目描述">题目描述</h2><blockquote><p>给定字符串<code>s</code>,输出字符串中<code>.</code>(点)后面的字符,若有多个<code>.</code>输出最后一个<code>.</code>的信息.</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>有多种解法,可以暴力循环一次,或者用<code>find()</code>函数查找</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line">[[maybe_unused]] <span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>, t = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((pos = s.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>, pos)) != <span class="number">-1</span>)</span><br><span class="line">        t = pos, pos++;</span><br><span class="line">    std::cout &lt;&lt; s.<span class="built_in">substr</span>(t + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://atcoder.jp/contests/abc339/tasks/abc339_b">Langton’s Takahashi </a></h1><h2 id="题目描述-2">题目描述</h2><blockquote><p>给三个数<code>n</code>,<code>m</code>和<code>k</code>,其中<code>n</code> <code>m</code>代表<code>n * m</code>的矩阵,<code>k</code>代表操作数<br>起始点在矩阵的<code>(1,1)</code>,朝向为正上方<br>对于每次操作:</p><ol><li>当前位置为<code>.</code> 则将当前位置改为<code>#</code> 并且向右转,向前走一步.</li><li>当前位置为<code>#</code> 则将当前位置改为<code>.</code> 并且向左转,向前走一步.<br>打印出矩阵作为结果</li></ol></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>使用矩阵模拟下过程即可<br>对于样例<code>3  4  5</code>模拟下<br>初始状态<code>x = 1, y = 1</code>朝向正上方<br>$$\begin{matrix}<br>.&amp;.&amp;.\<br>.&amp;.&amp;.\<br>.&amp;.&amp;.\<br>.&amp;.&amp;.\<br>\end{matrix}<br>$$<br>第一步,由于当前位置<code>(1,1)</code>为<code>.</code>那么就需要将当前位置变为<code>#</code>,并向右转,走一步到<code>(1,2)</code>,朝向右<br>$$\begin{matrix}<br>#&amp;.&amp;.\<br>.&amp;.&amp;.\<br>.&amp;.&amp;.\<br>.&amp;.&amp;.\<br>\end{matrix}<br>$$<br>第二步,由于当前位置<code>(1,2)</code>为<code>.</code>那么就需要将当前位置变为<code>#</code>,并向右转,走一步到<code>(2,2)</code>,朝向下<br>$$\begin{matrix}<br>#&amp;#&amp;.\<br>.&amp;.&amp;.\<br>.&amp;.&amp;.\<br>.&amp;.&amp;.\<br>\end{matrix}<br>$$<br>第三步,由于当前位置<code>(2,2)</code>为<code>.</code>那么就需要将当前位置变为<code>#</code>,并向右转,走一步到<code>(2,2)</code>,朝向左<br>$$\begin{matrix}<br>#&amp;#&amp;.\<br>.&amp;#&amp;.\<br>.&amp;.&amp;.\<br>.&amp;.&amp;.\<br>\end{matrix}<br>$$<br>第四步,由于当前位置<code>(2,1)</code>为<code>.</code>那么就需要将当前位置变为<code>#</code>,并向右转,走一步到<code>(1,1)</code>,朝向上<br>$$\begin{matrix}<br>#&amp;#&amp;.\<br>#&amp;#&amp;.\<br>.&amp;.&amp;.\<br>.&amp;.&amp;.\<br>\end{matrix}<br>$$<br>第五步,由于当前位置<code>(1,1)</code>为<code>#</code>那么就需要将当前位置变为<code>.</code>,并向左转,走一步到<code>(1,3)</code>,朝向左<br>,此处能到<code>(1,3)</code>是因为矩阵相当于上下,左右连通的.<br>$$\begin{matrix}<br>.&amp;#&amp;.\<br>#&amp;#&amp;.\<br>.&amp;.&amp;.\<br>.&amp;.&amp;.\<br>\end{matrix}<br>$$<br>最后就得到了这样的矩阵.对于朝向的转换就需要一定的技巧,合理运用模<code>(mod)</code>的运算.</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line">[[maybe_unused]] <span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">s</span><span class="params">(n, std::string(m, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">            dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[x][y] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            s[x][y] = <span class="string">&#x27;#&#x27;</span>, t = (t + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[x][y] = <span class="string">&#x27;.&#x27;</span>, t = (t + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">        x = (x + n + dx[t]) % n;</span><br><span class="line">        y = (y + m + dy[t]) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Atcoder abc 339(A-B)</summary>
    
    
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/categories/atcoder/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder beginner contest 338</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/6d19eff3.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/6d19eff3.html</id>
    <published>2024-08-15T10:37:21.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://atcoder.jp/contests/abc338/tasks/abc338_a">Capitalized?</a></h1><h2 id="题目描述">题目描述</h2><blockquote><p>给定一个字符串<code>s</code>, 让我们判断是否满足首字母大写,其他字母小写的规则.</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>直接用库函数<code>islower()</code>和<code>isupper()</code>模拟一下</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e18</span> + <span class="number">50</span>, MOD = <span class="number">10007</span>;</span><br><span class="line">[[maybe_unused]] <span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">islower</span>(s[<span class="number">0</span>])) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(s[i])) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>B <a href="https://atcoder.jp/contests/abc338/tasks/abc338_b">Frequency</a></h1><h2 id="题目描述-2">题目描述</h2><blockquote><p>给定一字符串<code>s</code>, 输出出现次数最多字符,若有多个输出字典序较小的.</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>我们可以用数据结构<code>map</code>来存储,并记录最大的数.<br>由于<code>map</code>会自动将键按从小到大排序,那么我们就只需要遍历一次<code>map</code>的数据,当遍历到次数与最大值相同时,直接输出字符即可.<br>同样,用其他的方法计数也可行</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e18</span> + <span class="number">50</span>, MOD = <span class="number">10007</span>;</span><br><span class="line">[[maybe_unused]] <span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> ma = <span class="number">0</span>;</span><br><span class="line">    std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: s)</span><br><span class="line">        mp[i]++, ma = std::<span class="built_in">max</span>(ma, mp[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: mp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.second == ma) &#123;</span><br><span class="line">            std::cout &lt;&lt; i.first &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://atcoder.jp/contests/abc338/tasks/abc338_c">Leftover Recipes</a></h1><h2 id="题目描述-3">题目描述</h2><blockquote><p>我们现在有<code>n</code>中配料,分别有$q_i$, 我们需要完成两种菜,这两个菜所用的配料分别$a_i,b_i$<br>问:我们最多能做多少个菜?</p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>假设我们做<code>x</code>个<code>A</code>菜,<code>y</code>个<code>B</code>菜,所花费的各个材料为$a_{i}<em>x + b_i</em>y$,由于<code>n</code>的数据范围较小,我们可以直接暴力循环$x\le10^6$ ,然后判断下$p_i&lt;a_i*x$和$b_i$就行了</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e18</span> + <span class="number">50</span>, MOD = <span class="number">10007</span>;</span><br><span class="line">[[maybe_unused]] <span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> a = q, b = q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; q[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; b[i];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">1e6</span>; x++)&#123;</span><br><span class="line">        <span class="type">int</span> y = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i] &lt; <span class="number">1ll</span> * a[i] * x)</span><br><span class="line">                y = -INF;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b[i] &gt; <span class="number">0</span>)</span><br><span class="line">                y = std::<span class="built_in">min</span>(y, (q[i] - a[i] * x) / b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, x + y);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Atcoder abc 338(A-C)</summary>
    
    
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/categories/atcoder/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder beginner contest 331</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/14c55757.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/14c55757.html</id>
    <published>2024-08-15T10:33:03.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://atcoder.jp/contests/abc331/tasks/abc331_a">Tomorrow</a></h1><h2 id="题目大意">题目大意</h2><blockquote><p>一年由 <code>M</code>个月组成,从 <code>1</code>月到 <code>M</code>月，每个月由 <code>D</code>天组成，从 <code>1</code>天到 <code>D</code>天。<br>问:在该日历中，年 <code>y</code>、月 <code>m</code>、日 <code>d</code>的下一天的日期？</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> M, D;</span><br><span class="line">    std::cin &gt;&gt; M &gt;&gt; D;</span><br><span class="line">    <span class="type">int</span> y, m, d;</span><br><span class="line">    std::cin &gt;&gt; y &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    d ++;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; D)&#123;</span><br><span class="line">        d -= D;</span><br><span class="line">        m ++;</span><br><span class="line">        <span class="keyword">if</span>(m &gt; M)&#123;</span><br><span class="line">            m -= M;</span><br><span class="line">            y ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://atcoder.jp/contests/abc331/tasks/abc331_b">Buy One Carton of Milk</a></h1><h2 id="题目大意-2">题目大意</h2><blockquote><p>一包 <code>6</code>个蛋 <code>S</code>元, 一包 <code>8</code>个蛋 <code>M</code>元,一包 <code>12</code>个蛋 <code>L</code>元<br>问:购买任意数量的每包鸡蛋时, 求至少购买 <code>N</code>个鸡蛋所需的最小价格?</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>由于数据量比较小,我们可以直接三重循环暴力跑一遍.</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s, m, l;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; m &gt;&gt; l;</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt;=<span class="number">100</span> ; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">100</span>; j ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">100</span>; k ++)&#123;</span><br><span class="line">                <span class="type">int</span> w = i * s + j * m + l * k;</span><br><span class="line">                <span class="keyword">if</span>(i * <span class="number">6</span> + <span class="number">8</span> * j + <span class="number">12</span> * k &gt;= n)</span><br><span class="line">                    ans = std::<span class="built_in">min</span> (ans, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Sum-of-Numbers-Greater-Than-Me">C <a href="https://atcoder.jp/contests/abc331/tasks/abc331_c">Sum of Numbers Greater Than Me</a></h2><h2 id="题目大意-3">题目大意</h2><blockquote><p>给一个大小为 <code>N</code>的数组 <code>A</code>,<br>问: 数组 <code>A</code>中所有大于 <code>A[i]</code>的元素之和.</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p><code>B</code>数组为输入的数组, 现有 <code>s</code>记录数组元素的总和,数组 <code>A</code>记录 <code>B</code>数组中大小为 <code>i</code>的<br>元素个数为 <code>A[i]</code>个,我们在遍历一次 <code>A</code>数组,只要 <code>A[i] &gt; 0</code>就可以将 <code>A[i]</code>赋值为 <code>s - A[i] * i</code><br>当然,同时 <code>s -= i * A[i]</code><br>最后,再遍历一次数组 <code>B</code>,输出 <code>A[B[i]]</code>.</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s = <span class="number">0</span>, ans = <span class="number">0</span>,x;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1e6</span> + <span class="number">50</span>, <span class="number">0ll</span>)</span>, <span class="title">b</span><span class="params">(n, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">        std::cin &gt;&gt; b[i], a[b[i]] ++, s += b[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">1000000</span> ;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">            s -= a[i] * i;</span><br><span class="line">            a[i] = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">        std::cout &lt;&lt; a[b[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Atcoder abc331(A-C)</summary>
    
    
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/categories/atcoder/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="atcoder" scheme="https://blog.lazy-boy-acmer.cn/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>myself算法模板</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/ae4759ab.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/ae4759ab.html</id>
    <published>2024-08-08T16:01:45.000Z</published>
    <updated>2025-08-22T02:37:23.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快读-int128">快读(__int128)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">i128 <span class="title">read</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    i128 x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span> ();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = - <span class="number">1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(i128 x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span> (<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x = - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">        <span class="built_in">print</span> (x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span> (x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组">树状数组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n_ = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_)</span> </span>&#123;</span><br><span class="line">        n = n_;</span><br><span class="line">        a.<span class="built_in">assign</span>(n, T&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x + <span class="number">1</span>; i &lt;= n; i += i &amp; -i) &#123;</span><br><span class="line">            a[i - <span class="number">1</span>] = a[i - <span class="number">1</span>] + v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        T ans&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">            ans = ans + a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">const</span> T &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        T cur&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; std::__lg(n); i; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + i &lt;= n &amp;&amp; cur + a[x + i - <span class="number">1</span>] &lt;= k) &#123;</span><br><span class="line">                x += i;</span><br><span class="line">                cur = cur + a[x - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快速幂">快速幂</h2><blockquote><p>$计算a^{b}\mod p$</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;  </span><br><span class="line">    a %= p;  </span><br><span class="line">    <span class="keyword">while</span> (b) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;  </span><br><span class="line">        a = a * a % p;  </span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数乘法">大数乘法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bigMul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span> </span>&#123;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c =  </span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">int</span>) a * b -  </span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">int</span>) ((<span class="type">long</span> <span class="type">double</span>) a / p * b + <span class="number">0.5L</span>) * p;  </span><br><span class="line">    <span class="keyword">if</span> (c &lt; p) <span class="keyword">return</span> c;  </span><br><span class="line">    <span class="keyword">return</span> c + p;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集-DSU">并查集(DSU)</h2><h3 id="普通DSU">普通DSU</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        f.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0ll</span>);</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0ll</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">combine</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">        f[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="可查询集合大小的DSU">可查询集合大小的DSU</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) x = f[x] = f[f[x]];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="欧拉筛">欧拉筛</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; minp, primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    minp.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    primes.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            minp[i] = i;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * p &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            minp[i * p] = p;</span><br><span class="line">            <span class="keyword">if</span> (p == minp[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路问题">[[最短路问题]]</h2><h3 id="朴素Dijkstra">朴素Dijkstra</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dijkstra</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; &amp;a)</span> </span>&#123;<span class="comment">//求1到各个点的最短路</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>, INF)</span></span>;</span><br><span class="line">        dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;<span class="comment">//注意此处只需要遍历n-1次</span></span><br><span class="line">            <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//查找未经过,并且路径最短的点</span></span><br><span class="line">                <span class="keyword">if</span> (!f[j] &amp;&amp; (pos == <span class="number">-1</span> || dis[j] &lt; dis[pos]))</span><br><span class="line">                    pos = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                dis[j] = std::<span class="built_in">min</span>(dis[pos] + a[pos][j], dis[j]);</span><br><span class="line">            f[pos] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="堆优化Dijkstra">堆优化Dijkstra</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dijkstra</span> &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, std::vector&lt;std::vector&lt;pii&gt; &gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;&gt; &gt; q;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>, INF)</span></span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dis[<span class="number">1</span>] = <span class="number">0ll</span>;</span><br><span class="line">        q.<span class="built_in">emplace</span>(dis[<span class="number">1</span>], <span class="number">1</span>);<span class="comment">//&#123;1-x的距离,节点编号</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (f[y]) <span class="keyword">continue</span>;</span><br><span class="line">            f[y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i: a[y]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [v, w] = i; <span class="comment">//&#123;x能到的节点x, x-v的距离&#125;</span></span><br><span class="line">                <span class="keyword">if</span> (dis[v] &gt; w + x) &#123;</span><br><span class="line">                    dis[v] = w + x;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(dis[v], v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="存在负权边的BellmanFord-k条路径的最短路">存在负权边的BellmanFord(k条路径的最短路)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125; E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bellmanford</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; <span class="title">bellmanford</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> m, std::vector&lt;E&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>, INF)</span></span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = dis;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [u, v, w] = a[j];</span><br><span class="line">                dis[v] = std::<span class="built_in">min</span>(t[u] + w, dis[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="存在负权边的spfa">存在负权边的spfa</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spfa</span> &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; <span class="title">spfa</span><span class="params">(<span class="type">int</span> n, <span class="type">const</span> std::vector&lt;std::vector&lt;pii&gt; &gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>, INF)</span></span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        std::queue&lt;pii&gt; q;<span class="comment">//其实这里可以只需要queue&lt;int&gt;</span></span><br><span class="line">        dis[<span class="number">1</span>] = <span class="number">0</span>, f[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">emplace</span>(dis[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            f[y] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w]: a[y]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[v] &gt; dis[y] + w) &#123;</span><br><span class="line">                    dis[v] = dis[y] + w;</span><br><span class="line">                    <span class="keyword">if</span> (!f[v]) &#123;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(dis[v], v);</span><br><span class="line">                        f[v] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Floyd-多源汇最短路">Floyd(多源汇最短路)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Floyd</span> &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">static</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">floyd</span>(<span class="type">int</span> n, std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; &amp;a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                    <span class="keyword">if</span> (i != j)</span><br><span class="line">                        a[i][j] = std::<span class="built_in">min</span>(a[i][j], a[i][k] + a[k][j]);</span><br><span class="line">                    <span class="keyword">else</span> a[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//特别注意i==j的情况</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="图论">[[图论]]</h2><h3 id="Prime">Prime</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Prime</span> &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getMST</span><span class="params">(<span class="type">int</span> n, std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>, INF)</span></span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span> (!f[j] &amp;&amp; (pos == <span class="number">-1</span> || dis[pos] &gt; dis[j]))</span><br><span class="line">                    pos = j;</span><br><span class="line">            f[pos] = <span class="literal">true</span>;</span><br><span class="line">            res += dis[pos];</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; dis[pos] == INF)</span><br><span class="line">                <span class="keyword">return</span> INF + INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                dis[j] = std::<span class="built_in">min</span>(dis[j], a[pos][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Kruskal">Kruskal</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">E</span> &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E &amp;a, <span class="type">const</span> E &amp;b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n&#123;&#125;, m&#123;&#125;;</span><br><span class="line">    std::vector&lt;E&gt; a;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        a.<span class="built_in">assign</span>(m, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v, w;</span><br><span class="line">            std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            a[i] = &#123;u, v, w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetMST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        f.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0ll</span>);</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0ll</span>);</span><br><span class="line">        std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [u, v, w] = a[i];</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">find</span>(u), y = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">                cnt++, res += w;</span><br><span class="line">                f[y] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt != n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> INF + INF;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="图论-2">[[图论]]</h2><h3 id="染色法-判断是否为二分图">染色法(判断是否为二分图)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">drawBinaryGraph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n&#123;&#125;, m&#123;&#125;;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; a;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        a.<span class="built_in">assign</span>(n + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        color.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            a[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            a[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        color[u] = c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = a[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!color[t]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">dfs</span>(t, <span class="number">3</span> - c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[t] == c)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBinaryGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> t = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!color[i])</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>)) &#123;</span><br><span class="line">                    t = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="匈牙利算法">匈牙利算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hungary</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> n1, n2, m;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; l;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">  std::vector&lt;<span class="type">bool</span>&gt; f;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;</span><br><span class="line">    l.<span class="built_in">assign</span>(n1 + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    r.<span class="built_in">assign</span>(n2 + <span class="number">1</span>, <span class="number">0ll</span>);</span><br><span class="line">    f.<span class="built_in">assign</span>(n2 + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="type">int</span> u, v;</span><br><span class="line">      std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">      l[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; l[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">int</span> j = l[x][i];</span><br><span class="line">      <span class="keyword">if</span>(!f[j]) &#123;</span><br><span class="line">        f[j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(r[j] == <span class="number">0</span> || <span class="built_in">find</span>(r[j])) &#123;</span><br><span class="line">          r[j] = x;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxMatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">      std::<span class="built_in">fill</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">find</span>(i))</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="数论">数论</h2><h3 id="组合数">组合数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span>  ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">    ans = ans * (n - m + i) / i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">自己的模板(由于站主水平低，可能模板比较少)</summary>
    
    
    
    <category term="算法模板" scheme="https://blog.lazy-boy-acmer.cn/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="算法" scheme="https://blog.lazy-boy-acmer.cn/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法学习" scheme="https://blog.lazy-boy-acmer.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>jiangly算法模板收集</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/b469c355.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/b469c355.html</id>
    <published>2024-08-08T15:52:44.000Z</published>
    <updated>2025-08-22T02:37:23.083Z</updated>
    
    <content type="html"><![CDATA[<h1>声明</h1><blockquote><p><strong>2024.03.31</strong> Update：新增《Splay（其三）》。</p></blockquote><p>历史更新记录</p><blockquote><p><strong>2024.02.21</strong> Update：文件层级重构，新增《后缀自动机（SuffixAutomaton 旧版）》、《回文自动机（PAM）》</p><p>龙年快乐~</p></blockquote><blockquote><p><strong>2023.12.29</strong> Update：新增《树状数组（Fenwick 新版）》。</p></blockquote><blockquote><p><strong>2023.12.16</strong> Update：新增《库函数重载》《二项式（Binomial 任意模数计算）》《线性基（Basis）》《线段树（其四）》《Splay（其二）》。</p><p>欢迎通过各种渠道向我投稿~</p></blockquote><blockquote><p>2023.11.02 Update：最新版本都更新在 <a href="https://github.com/hh2048/XCPC/tree/main/03%20-%20jiangly%E6%A8%A1%E6%9D%BF%E6%94%B6%E9%9B%86">GitHub</a> 了，但是注意到有些群u貌似不方便Fan Qiang，于是现在跟进上了 GitHub 的项目进度。</p></blockquote><p>自用！非本人原创，仅作整理归档。大部分代码来自于 <a href="https://codeforces.com/submissions/jiangly">CodeForces Jiangly</a> 的提交，部分来自于GYM、牛客、Atcoder。<a href="https://www.cnblogs.com/WIDA/p/17633758.html">文章博客链接</a>，<a href="https://github.com/hh2048/XCPC/tree/main/03%20-%20jiangly%E6%A8%A1%E6%9D%BF%E6%94%B6%E9%9B%86">文章 GitHub 链接</a>。</p><p>灵感参考链接：<a href="https://github.com/beiyouwuyanzu/cf_code_jiangly">beiyouwuyanzu/cf_code_jiangly</a></p><hr><h1>目录</h1><p>目录</p><ul><li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E4%B8%80%E6%9D%82%E7%B1%BB">一、杂类</a><ul><li><a href="#01---int128-%E8%BE%93%E5%87%BA%E6%B5%81%E8%87%AA%E5%AE%9A%E4%B9%89">01 - int128 输出流自定义</a></li><li><a href="#02---%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">02 - 常用库函数重载</a></li></ul></li><li><a href="#%E4%BA%8C%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C">二、图与网络</a><ul><li><a href="#01---%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%BC%A9%E7%82%B9scc">01 - 强连通分量缩点（SCC）</a></li><li><a href="#02---%E5%89%B2%E8%BE%B9%E4%B8%8E%E5%89%B2%E8%BE%B9%E7%BC%A9%E7%82%B9ebcc">02 - 割边与割边缩点（EBCC）</a></li><li><a href="#03---%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%9D%83%E5%8C%B9%E9%85%8Dmaxassignment-%E5%9F%BA%E4%BA%8Ekm%E4%B9%85%E8%BF%9C">03 - 二分图最大权匹配（MaxAssignment 基于KM）【久远】</a></li><li><a href="#04---%E4%B8%80%E8%88%AC%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8Dgraph-%E5%B8%A6%E8%8A%B1%E6%A0%91%E7%AE%97%E6%B3%95%E4%B9%85%E8%BF%9C">04 - 一般图最大匹配（Graph 带花树算法）【久远】</a></li><li><a href="#05---twosat2-sat">05 - TwoSat（2-Sat）</a></li><li><a href="#06a---%E6%9C%80%E5%A4%A7%E6%B5%81flow-%E6%97%A7%E7%89%88%E5%85%B6%E4%B8%80%E6%95%B4%E6%95%B0%E5%BA%94%E7%94%A8">06A - 最大流（Flow 旧版其一，整数应用）</a></li><li><a href="#06b---%E6%9C%80%E5%A4%A7%E6%B5%81flow-%E6%97%A7%E7%89%88%E5%85%B6%E4%BA%8C%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BA%94%E7%94%A8">06B - 最大流（Flow 旧版其二，浮点数应用）</a></li><li><a href="#06c---%E6%9C%80%E5%A4%A7%E6%B5%81maxflow-%E6%96%B0%E7%89%88">06C - 最大流（MaxFlow 新版）</a></li><li><a href="#07a---%E8%B4%B9%E7%94%A8%E6%B5%81mcfgraph-%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E5%8F%AF%E8%A1%8C%E6%B5%81">07A - 费用流（MCFGraph 最小费用可行流）</a></li><li><a href="#07b---%E8%B4%B9%E7%94%A8%E6%B5%81mcfgraph-%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81">07B - 费用流（MCFGraph 最小费用最大流）</a></li><li><a href="#08---%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86hld">08 - 树链剖分（HLD）</a></li></ul></li><li><a href="#%E4%B8%89%E6%95%B0%E8%AE%BA%E5%87%A0%E4%BD%95%E5%A4%9A%E9%A1%B9%E5%BC%8F">三、数论、几何、多项式</a><ul><li><a href="#01---%E5%BF%AB%E9%80%9F%E5%B9%82">01 - 快速幂</a></li><li><a href="#02---%E6%AC%A7%E6%8B%89%E7%AD%9B">02 - 欧拉筛</a></li><li><a href="#03---%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E7%AD%9B%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E5%8F%8D%E6%BC%94">03 - 莫比乌斯函数筛（莫比乌斯函数/反演）</a></li><li><a href="#04---%E6%B1%82%E8%A7%A3%E5%8D%95%E4%B8%AA%E6%95%B0%E7%9A%84%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">04 - 求解单个数的欧拉函数</a></li><li><a href="#05---%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97exgcd">05 - 扩展欧几里得（exGCD）</a></li><li><a href="#06---%E7%BB%84%E5%90%88%E6%95%B0combmint--mlong">06 - 组合数（Comb+MInt &amp; MLong）</a></li><li><a href="#07---%E4%BA%8C%E9%A1%B9%E5%BC%8Fbinomial-%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0%E8%AE%A1%E7%AE%97">07 - 二项式（Binomial 任意模数计算）</a></li><li><a href="#08---%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3miller-rabin--pollard-rho">08 - 素数测试与因式分解（Miller-Rabin &amp; Pollard-Rho）</a></li><li><a href="#09---%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95">09 - 平面几何</a></li><li><a href="#10---%E9%9D%99%E6%80%81%E5%87%B8%E5%8C%85">10 - 静态凸包</a></li><li><a href="#11a---%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9B%B8%E5%85%B3poly-%E6%97%A7%E7%89%88">11A - 多项式相关（Poly 旧版）</a></li><li><a href="#11b---%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9B%B8%E5%85%B3polymint--mlong-%E6%96%B0%E7%89%88">11B - 多项式相关（Poly+MInt &amp; MLong 新版）</a></li></ul></li><li><a href="#%E5%9B%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">四、数据结构</a><ul><li><a href="#01a---%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84fenwick-%E6%97%A7%E7%89%88">01A - 树状数组（Fenwick 旧版）</a></li><li><a href="#01b---%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84fenwick-%E6%96%B0%E7%89%88">01B - 树状数组（Fenwick 新版）</a></li><li><a href="#02---%E5%B9%B6%E6%9F%A5%E9%9B%86dsu">02 - 并查集（DSU）</a></li><li><a href="#03a---%E7%BA%BF%E6%AE%B5%E6%A0%91segmenttree-%E5%9F%BA%E7%A1%80%E5%8C%BA%E9%97%B4%E5%8A%A0%E4%B9%98">03A - 线段树（SegmentTree 基础区间加乘）</a></li><li><a href="#03b---%E7%BA%BF%E6%AE%B5%E6%A0%91segmenttreeinfo-%E6%9F%A5%E6%89%BE%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7">03B - 线段树（SegmentTree+Info 查找前驱后继）</a></li><li><a href="#03c---%E7%BA%BF%E6%AE%B5%E6%A0%91segmenttreeinfomerge-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6">03C - 线段树（SegmentTree+Info+Merge 区间合并）</a></li><li><a href="#04a---%E6%87%92%E6%A0%87%E8%AE%B0%E7%BA%BF%E6%AE%B5%E6%A0%91lazysegmenttree-%E5%9F%BA%E7%A1%80%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9">04A - 懒标记线段树（LazySegmentTree 基础区间修改）</a></li><li><a href="#04b---%E6%87%92%E6%A0%87%E8%AE%B0%E7%BA%BF%E6%AE%B5%E6%A0%91lazysegmenttree-%E6%9F%A5%E6%89%BE%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7">04B - 懒标记线段树（LazySegmentTree 查找前驱后继）</a></li><li><a href="#04c---%E6%87%92%E6%A0%87%E8%AE%B0%E7%BA%BF%E6%AE%B5%E6%A0%91lazysegmenttree-%E4%BA%8C%E5%88%86%E4%BF%AE%E6%94%B9">04C - 懒标记线段树（LazySegmentTree 二分修改）</a></li><li><a href="#05a---%E5%8F%96%E6%A8%A1%E7%B1%BBmlong--mint">05A - 取模类（MLong &amp; MInt）</a></li><li><a href="#05b---%E5%8F%96%E6%A8%A1%E7%B1%BBmlong--mint-%E6%96%B0%E7%89%88">05B - 取模类（MLong &amp; MInt 新版）</a></li><li><a href="#06---%E7%8A%B6%E5%8E%8Brmqrmq">06 - 状压RMQ（RMQ）</a></li><li><a href="#07---splay">07 - Splay</a></li><li><a href="#08---%E5%85%B6%E4%BB%96%E5%B9%B3%E8%A1%A1%E6%A0%91">08 - 其他平衡树</a></li><li><a href="#09---%E5%88%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97frac">09 - 分数四则运算（Frac）</a></li><li><a href="#10---%E7%BA%BF%E6%80%A7%E5%9F%BAbasis">10 - 线性基（Basis）</a></li></ul></li><li><a href="#%E4%BA%94%E5%AD%97%E7%AC%A6%E4%B8%B2">五、字符串</a><ul><li><a href="#01---%E9%A9%AC%E6%8B%89%E8%BD%A6manacher">01 - 马拉车（Manacher）</a></li><li><a href="#02---z%E5%87%BD%E6%95%B0">02 - Z函数</a></li><li><a href="#03---%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84sa">03 - 后缀数组（SA）</a></li><li><a href="#04a---%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BAsuffixautomaton-%E6%97%A7%E7%89%88">04A - 后缀自动机（SuffixAutomaton 旧版）</a></li><li><a href="#04b---%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BAsam-%E6%96%B0%E7%89%88">04B - 后缀自动机（SAM 新版）</a></li><li><a href="#05---%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BApam">05 - 回文自动机（PAM）</a></li><li><a href="#06a---ac%E8%87%AA%E5%8A%A8%E6%9C%BAac-%E6%97%A7%E7%89%88">06A - AC自动机（AC 旧版）</a></li><li><a href="#06b---ac%E8%87%AA%E5%8A%A8%E6%9C%BAahocorasick-%E6%96%B0%E7%89%88">06B - AC自动机（AhoCorasick 新版）</a></li><li><a href="#07---%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E6%A8%A1%E5%BA%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E4%BE%8B%E9%A2%98">07 - 随机生成模底 字符串哈希（例题）</a></li></ul></li></ul><hr><h1>一、杂类</h1><h2 id="01-int128-输出流自定义">01 - int128 输出流自定义</h2><p><a href="https://codeforces.com/contest/1806/submission/198413531">2023-03-20</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, i128 n) &#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        s += <span class="string">&#x27;0&#x27;</span> + n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="02-常用库函数重载">02 - 常用库函数重载</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">ceilDiv</span><span class="params">(i64 n, i64 m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (n + m - <span class="number">1</span>) / m;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n / m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">i64 <span class="title">floorDiv</span><span class="params">(i64 n, i64 m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n / m;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (n - m + <span class="number">1</span>) / m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chmax</span><span class="params">(T &amp;a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        a = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i128 <span class="title">gcd</span><span class="params">(i128 a, i128 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>二、图与网络</h1><h2 id="01-强连通分量缩点（SCC）">01 - 强连通分量缩点（SCC）</h2><p><a href="https://codeforces.com/contest/1835/submission/210147209">2023-06-18</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SCC</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dfn, low, bel;</span><br><span class="line">    <span class="type">int</span> cur, cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">SCC</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">SCC</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        adj.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">        dfn.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">        bel.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        stk.<span class="built_in">clear</span>();</span><br><span class="line">        cur = cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = cur++;</span><br><span class="line">        stk.<span class="built_in">push_back</span>(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : adj[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(y);</span><br><span class="line">                low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bel[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                y = stk.<span class="built_in">back</span>();</span><br><span class="line">                bel[y] = cnt;</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="02-割边与割边缩点（EBCC）">02 - 割边与割边缩点（EBCC）</h2><p><a href="https://codeforces.com/contest/118/submission/205426518">2023-05-11</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EBCC</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dfn, low, bel;</span><br><span class="line">    <span class="type">int</span> cur, cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">EBCC</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">EBCC</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        adj.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">        dfn.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">        bel.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        stk.<span class="built_in">clear</span>();</span><br><span class="line">        cur = cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = cur++;</span><br><span class="line">        stk.<span class="built_in">push_back</span>(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : adj[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == p) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dfn[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                E.<span class="built_in">emplace</span>(x, y);</span><br><span class="line">                <span class="built_in">dfs</span>(y, x);</span><br><span class="line">                low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bel[y] == <span class="number">-1</span> &amp;&amp; dfn[y] &lt; dfn[x]) &#123;</span><br><span class="line">                E.<span class="built_in">emplace</span>(x, y);</span><br><span class="line">                low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                y = stk.<span class="built_in">back</span>();</span><br><span class="line">                bel[y] = cnt;</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> bel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; siz;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; cnte;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Graph <span class="title">compress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Graph g;</span><br><span class="line">        g.n = cnt;</span><br><span class="line">        g.siz.<span class="built_in">resize</span>(cnt);</span><br><span class="line">        g.cnte.<span class="built_in">resize</span>(cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.siz[bel[i]]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : adj[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bel[i] &lt; bel[j]) &#123;</span><br><span class="line">                    g.edges.<span class="built_in">emplace_back</span>(bel[i], bel[j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    g.cnte[bel[i]]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="03-二分图最大权匹配（MaxAssignment-基于KM）【久远】">03 - 二分图最大权匹配（MaxAssignment 基于KM）【久远】</h2><p><a href="https://atcoder.jp/contests/abc247/submissions/30867023">2022-04-10</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MaxAssignment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">T <span class="title">solve</span><span class="params">(<span class="type">int</span> nx, <span class="type">int</span> ny, std::vector&lt;std::vector&lt;T&gt;&gt; a)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt;= ny);</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">int</span>(a.<span class="built_in">size</span>()) == nx);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nx; ++i) &#123;</span><br><span class="line">                <span class="built_in">assert</span>(<span class="built_in">int</span>(a[i].<span class="built_in">size</span>()) == ny);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> x : a[i])</span><br><span class="line">                    <span class="built_in">assert</span>(x &gt;= <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> update = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ny; ++y) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lx[x] + ly[y] - a[x][y] &lt; slack[y]) &#123;</span><br><span class="line">                        slack[y] = lx[x] + ly[y] - a[x][y];</span><br><span class="line">                        slackx[y] = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            costs.<span class="built_in">resize</span>(nx + <span class="number">1</span>);</span><br><span class="line">            costs[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            lx.<span class="built_in">assign</span>(nx, std::numeric_limits&lt;T&gt;::<span class="built_in">max</span>());</span><br><span class="line">            ly.<span class="built_in">assign</span>(ny, <span class="number">0</span>);</span><br><span class="line">            xy.<span class="built_in">assign</span>(nx, <span class="number">-1</span>);</span><br><span class="line">            yx.<span class="built_in">assign</span>(ny, <span class="number">-1</span>);</span><br><span class="line">            slackx.<span class="built_in">resize</span>(ny);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> cur = <span class="number">0</span>; cur &lt; nx; ++cur) &#123;</span><br><span class="line">                std::queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">                visx.<span class="built_in">assign</span>(nx, <span class="literal">false</span>);</span><br><span class="line">                visy.<span class="built_in">assign</span>(ny, <span class="literal">false</span>);</span><br><span class="line">                slack.<span class="built_in">assign</span>(ny, std::numeric_limits&lt;T&gt;::<span class="built_in">max</span>());</span><br><span class="line">                p.<span class="built_in">assign</span>(nx, <span class="number">-1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; nx; ++x) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (xy[x] == <span class="number">-1</span>) &#123;</span><br><span class="line">                        que.<span class="built_in">push</span>(x);</span><br><span class="line">                        visx[x] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">update</span>(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> ex, ey;</span><br><span class="line">                <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">while</span> (!found) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; !found) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">                        que.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ny; ++y) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (a[x][y] == lx[x] + ly[y] &amp;&amp; !visy[y]) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (yx[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                                    ex = x;</span><br><span class="line">                                    ey = y;</span><br><span class="line">                                    found = <span class="literal">true</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                que.<span class="built_in">push</span>(yx[y]);</span><br><span class="line">                                p[yx[y]] = x;</span><br><span class="line">                                visy[y] = visx[yx[y]] = <span class="literal">true</span>;</span><br><span class="line">                                <span class="built_in">update</span>(yx[y]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (found)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                    T delta = std::numeric_limits&lt;T&gt;::<span class="built_in">max</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ny; ++y)</span><br><span class="line">                        <span class="keyword">if</span> (!visy[y])</span><br><span class="line">                            delta = std::<span class="built_in">min</span>(delta, slack[y]);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; nx; ++x)</span><br><span class="line">                        <span class="keyword">if</span> (visx[x])</span><br><span class="line">                            lx[x] -= delta;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ny; ++y) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (visy[y]) &#123;</span><br><span class="line">                            ly[y] += delta;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            slack[y] -= delta;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ny; ++y) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!visy[y] &amp;&amp; slack[y] == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (yx[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                                ex = slackx[y];</span><br><span class="line">                                ey = y;</span><br><span class="line">                                found = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            que.<span class="built_in">push</span>(yx[y]);</span><br><span class="line">                            p[yx[y]] = slackx[y];</span><br><span class="line">                            visy[y] = visx[yx[y]] = <span class="literal">true</span>;</span><br><span class="line">                            <span class="built_in">update</span>(yx[y]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                costs[cur + <span class="number">1</span>] = costs[cur];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = ex, y = ey, ty; x != <span class="number">-1</span>; x = p[x], y = ty) &#123;</span><br><span class="line">                    costs[cur + <span class="number">1</span>] += a[x][y];</span><br><span class="line">                    <span class="keyword">if</span> (xy[x] != <span class="number">-1</span>)</span><br><span class="line">                        costs[cur + <span class="number">1</span>] -= a[x][xy[x]];</span><br><span class="line">                    ty = xy[x];</span><br><span class="line">                    xy[x] = y;</span><br><span class="line">                    yx[y] = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> costs[nx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">assignment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> xy;</span><br><span class="line">        &#125;</span><br><span class="line">        std::pair&lt;std::vector&lt;T&gt;, std::vector&lt;T&gt;&gt; <span class="built_in">labels</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(lx, ly);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::vector&lt;T&gt; <span class="title">weights</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> costs;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::vector&lt;T&gt; lx, ly, slack, costs;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; xy, yx, p, slackx;</span><br><span class="line">        std::vector&lt;<span class="type">bool</span>&gt; visx, visy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="04-一般图最大匹配（Graph-带花树算法）【久远】">04 - 一般图最大匹配（Graph 带花树算法）【久远】</h2><p><a href="https://codeforces.com/contest/1615/submission/140509278">2021-12-24</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; e;</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">e</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">findMatching</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">match</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">vis</span><span class="params">(n)</span>, <span class="title">link</span><span class="params">(n)</span>, <span class="title">f</span><span class="params">(n)</span>, <span class="title">dep</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// disjoint set union</span></span><br><span class="line">        <span class="keyword">auto</span> find = [&amp;](<span class="type">int</span> u) &#123;</span><br><span class="line">            <span class="keyword">while</span> (f[u] != u)</span><br><span class="line">                u = f[u] = f[f[u]];</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> lca = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v) &#123;</span><br><span class="line">            u = <span class="built_in">find</span>(u);</span><br><span class="line">            v = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">while</span> (u != v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dep[u] &lt; dep[v])</span><br><span class="line">                    std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">                u = <span class="built_in">find</span>(link[match[u]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        std::queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">auto</span> blossom = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> p) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">find</span>(u) != p) &#123;</span><br><span class="line">                link[u] = v;</span><br><span class="line">                v = match[u];</span><br><span class="line">                <span class="keyword">if</span> (vis[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">                f[u] = f[v] = p;</span><br><span class="line">                u = link[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find an augmenting path starting from u and augment (if exist)</span></span><br><span class="line">        <span class="keyword">auto</span> augment = [&amp;](<span class="type">int</span> u) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// vis = 0 corresponds to inner vertices, vis = 1 corresponds to outer vertices</span></span><br><span class="line">            std::<span class="built_in">fill</span>(vis.<span class="built_in">begin</span>(), vis.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">            </span><br><span class="line">            que.<span class="built_in">push</span>(u);</span><br><span class="line">            vis[u] = <span class="number">1</span>;</span><br><span class="line">            dep[u] = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                        </span><br><span class="line">                        vis[v] = <span class="number">0</span>;</span><br><span class="line">                        link[v] = u;</span><br><span class="line">                        dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// found an augmenting path</span></span><br><span class="line">                        <span class="keyword">if</span> (match[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> x = v, y = u, temp; y != <span class="number">-1</span>; x = temp, y = x == <span class="number">-1</span> ? <span class="number">-1</span> : link[x]) &#123;</span><br><span class="line">                                temp = match[y];</span><br><span class="line">                                match[x] = y;</span><br><span class="line">                                match[y] = x;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        vis[match[v]] = <span class="number">1</span>;</span><br><span class="line">                        dep[match[v]] = dep[u] + <span class="number">2</span>;</span><br><span class="line">                        que.<span class="built_in">push</span>(match[v]);</span><br><span class="line">                        </span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[v] == <span class="number">1</span> &amp;&amp; <span class="built_in">find</span>(v) != <span class="built_in">find</span>(u)) &#123;</span><br><span class="line">                        <span class="comment">// found a blossom</span></span><br><span class="line">                        <span class="type">int</span> p = <span class="built_in">lca</span>(u, v);</span><br><span class="line">                        <span class="built_in">blossom</span>(u, v, p);</span><br><span class="line">                        <span class="built_in">blossom</span>(v, u, p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find a maximal matching greedily (decrease constant)</span></span><br><span class="line">        <span class="keyword">auto</span> greedy = [&amp;]() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) &#123;</span><br><span class="line">                <span class="keyword">if</span> (match[u] != <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (match[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                        match[u] = v;</span><br><span class="line">                        match[v] = u;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">greedy</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u)</span><br><span class="line">            <span class="keyword">if</span> (match[u] == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">augment</span>(u);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> match;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="05-TwoSat（2-Sat）">05 - TwoSat（2-Sat）</h2><p><a href="https://atcoder.jp/contests/arc161/submissions/46031530">2023-09-29</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TwoSat</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; e;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; ans;</span><br><span class="line">    <span class="built_in">TwoSat</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">e</span>(<span class="number">2</span> * n), <span class="built_in">ans</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addClause</span><span class="params">(<span class="type">int</span> u, <span class="type">bool</span> f, <span class="type">int</span> v, <span class="type">bool</span> g)</span> </span>&#123;</span><br><span class="line">        e[<span class="number">2</span> * u + !f].<span class="built_in">push_back</span>(<span class="number">2</span> * v + g);</span><br><span class="line">        e[<span class="number">2</span> * v + !g].<span class="built_in">push_back</span>(<span class="number">2</span> * u + f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">satisfiable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">id</span><span class="params">(<span class="number">2</span> * n, <span class="number">-1</span>)</span>, <span class="title">dfn</span><span class="params">(<span class="number">2</span> * n, <span class="number">-1</span>)</span>, <span class="title">low</span><span class="params">(<span class="number">2</span> * n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; tarjan = [&amp;](<span class="type">int</span> u) &#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(u);</span><br><span class="line">            dfn[u] = low[u] = now++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfn[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">tarjan</span>(v);</span><br><span class="line">                    low[u] = std::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    low[u] = std::<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">                <span class="type">int</span> v;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    v = stk.<span class="built_in">back</span>();</span><br><span class="line">                    stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                    id[v] = cnt;</span><br><span class="line">                &#125; <span class="keyword">while</span> (v != u);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i) <span class="keyword">if</span> (dfn[i] == <span class="number">-1</span>) <span class="built_in">tarjan</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[<span class="number">2</span> * i] == id[<span class="number">2</span> * i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ans[i] = id[<span class="number">2</span> * i] &gt; id[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">answer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="06A-最大流（Flow-旧版其一，整数应用）">06A - 最大流（Flow 旧版其一，整数应用）</h2><p><a href="https://codeforces.com/contest/1717/submission/170688062">2022-09-03</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Flow</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        T cap;</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> to, T cap) : <span class="built_in">to</span>(to), <span class="built_in">cap</span>(cap) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;Edge&gt; e;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; cur, h;</span><br><span class="line">    <span class="built_in">Flow</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">g</span>(n) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        h.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        std::queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        h[s] = <span class="number">0</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : g[u]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (v == t) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    que.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t, T f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> r = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; i &lt; <span class="built_in">int</span>(g[u].<span class="built_in">size</span>()); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> j = g[u][i];</span><br><span class="line">            <span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> a = <span class="built_in">dfs</span>(v, t, std::<span class="built_in">min</span>(r, c));</span><br><span class="line">                e[j].cap -= a;</span><br><span class="line">                e[j ^ <span class="number">1</span>].cap += a;</span><br><span class="line">                r -= a;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f - r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, T c)</span> </span>&#123;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">        e.<span class="built_in">emplace_back</span>(v, c);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">        e.<span class="built_in">emplace_back</span>(u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">maxFlow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">bfs</span>(s, t)) &#123;</span><br><span class="line">            cur.<span class="built_in">assign</span>(n, <span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">dfs</span>(s, t, std::numeric_limits&lt;T&gt;::<span class="built_in">max</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="06B-最大流（Flow-旧版其二，浮点数应用）">06B - 最大流（Flow 旧版其二，浮点数应用）</h2><p><a href="https://cf.dianhsu.com/gym/104288/submission/201412765">2022-04-09</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Flow</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        T cap;</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> to, T cap) : <span class="built_in">to</span>(to), <span class="built_in">cap</span>(cap) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;Edge&gt; e;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; cur, h;</span><br><span class="line">    <span class="built_in">Flow</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">g</span>(n) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        h.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        std::queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        h[s] = <span class="number">0</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : g[u]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (v == t) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    que.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t, T f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> r = f;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; i &lt; <span class="built_in">int</span>(g[u].<span class="built_in">size</span>()); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> j = g[u][i];</span><br><span class="line">            <span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> a = <span class="built_in">dfs</span>(v, t, std::<span class="built_in">min</span>(r, c));</span><br><span class="line">                res += a;</span><br><span class="line">                e[j].cap -= a;</span><br><span class="line">                e[j ^ <span class="number">1</span>].cap += a;</span><br><span class="line">                r -= a;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, T c)</span> </span>&#123;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">        e.<span class="built_in">emplace_back</span>(v, c);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">        e.<span class="built_in">emplace_back</span>(u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">maxFlow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">bfs</span>(s, t)) &#123;</span><br><span class="line">            cur.<span class="built_in">assign</span>(n, <span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">dfs</span>(s, t, <span class="number">1E100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="06C-最大流（MaxFlow-新版）">06C - 最大流（MaxFlow 新版）</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=62915815">2023-07-21</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf = <span class="number">1E9</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MaxFlow</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        T cap;</span><br><span class="line">        _Edge(<span class="type">int</span> to, T cap) : <span class="built_in">to</span>(to), <span class="built_in">cap</span>(cap) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;_Edge&gt; e;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; cur, h;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MaxFlow</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">MaxFlow</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        e.<span class="built_in">clear</span>();</span><br><span class="line">        g.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">        cur.<span class="built_in">resize</span>(n);</span><br><span class="line">        h.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        h.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        std::queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        h[s] = <span class="number">0</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : g[u]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (v == t) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    que.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t, T f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> r = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; i &lt; <span class="built_in">int</span>(g[u].<span class="built_in">size</span>()); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> j = g[u][i];</span><br><span class="line">            <span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> a = <span class="built_in">dfs</span>(v, t, std::<span class="built_in">min</span>(r, c));</span><br><span class="line">                e[j].cap -= a;</span><br><span class="line">                e[j ^ <span class="number">1</span>].cap += a;</span><br><span class="line">                r -= a;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f - r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, T c)</span> </span>&#123;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">        e.<span class="built_in">emplace_back</span>(v, c);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">        e.<span class="built_in">emplace_back</span>(u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">flow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">bfs</span>(s, t)) &#123;</span><br><span class="line">            cur.<span class="built_in">assign</span>(n, <span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">dfs</span>(s, t, std::numeric_limits&lt;T&gt;::<span class="built_in">max</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">minCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            c[i] = (h[i] != <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> from;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        T cap;</span><br><span class="line">        T flow;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::vector&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::vector&lt;Edge&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            Edge x;</span><br><span class="line">            x.from = e[i + <span class="number">1</span>].to;</span><br><span class="line">            x.to = e[i].to;</span><br><span class="line">            x.cap = e[i].cap + e[i + <span class="number">1</span>].cap;</span><br><span class="line">            x.flow = e[i + <span class="number">1</span>].cap;</span><br><span class="line">            a.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="07A-费用流（MCFGraph-最小费用可行流）">07A - 费用流（MCFGraph 最小费用可行流）</h2><p><a href="https://codeforces.com/contest/1766/submission/184974697">2022-12-12</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MCFGraph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, c, f;</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f) : <span class="built_in">v</span>(v), <span class="built_in">c</span>(c), <span class="built_in">f</span>(f) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Edge&gt; e;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    std::vector&lt;i64&gt; h, dis;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; pre;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        dis.<span class="built_in">assign</span>(n, std::numeric_limits&lt;i64&gt;::<span class="built_in">max</span>());</span><br><span class="line">        pre.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        std::priority_queue&lt;std::pair&lt;i64, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;i64, <span class="type">int</span>&gt;&gt;, std::greater&lt;std::pair&lt;i64, <span class="type">int</span>&gt;&gt;&gt; que;</span><br><span class="line">        dis[s] = <span class="number">0</span>;</span><br><span class="line">        que.<span class="built_in">emplace</span>(<span class="number">0</span>, s);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            i64 d = que.<span class="built_in">top</span>().first;</span><br><span class="line">            <span class="type">int</span> u = que.<span class="built_in">top</span>().second;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (dis[u] &lt; d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : g[u]) &#123;</span><br><span class="line">                <span class="type">int</span> v = e[i].v;</span><br><span class="line">                <span class="type">int</span> c = e[i].c;</span><br><span class="line">                <span class="type">int</span> f = e[i].f;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; dis[v] &gt; d + h[u] - h[v] + f) &#123;</span><br><span class="line">                    dis[v] = d + h[u] - h[v] + f;</span><br><span class="line">                    pre[v] = i;</span><br><span class="line">                    que.<span class="built_in">emplace</span>(dis[v], v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[t] != std::numeric_limits&lt;i64&gt;::<span class="built_in">max</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MCFGraph</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">g</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            g[u].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">            e.<span class="built_in">emplace_back</span>(v, <span class="number">0</span>, f);</span><br><span class="line">            g[v].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">            e.<span class="built_in">emplace_back</span>(u, c, -f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g[u].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">            e.<span class="built_in">emplace_back</span>(v, c, f);</span><br><span class="line">            g[v].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">            e.<span class="built_in">emplace_back</span>(u, <span class="number">0</span>, -f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, i64&gt; <span class="title">flow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        i64 cost = <span class="number">0</span>;</span><br><span class="line">        h.<span class="built_in">assign</span>(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">dijkstra</span>(s, t)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) h[i] += dis[i];</span><br><span class="line">            <span class="type">int</span> aug = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = t; i != s; i = e[pre[i] ^ <span class="number">1</span>].v) aug = std::<span class="built_in">min</span>(aug, e[pre[i]].c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = t; i != s; i = e[pre[i] ^ <span class="number">1</span>].v) &#123;</span><br><span class="line">                e[pre[i]].c -= aug;</span><br><span class="line">                e[pre[i] ^ <span class="number">1</span>].c += aug;</span><br><span class="line">            &#125;</span><br><span class="line">            flow += aug;</span><br><span class="line">            cost += <span class="built_in">i64</span>(aug) * h[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(flow, cost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="07B-费用流（MCFGraph-最小费用最大流）">07B - 费用流（MCFGraph 最小费用最大流）</h2><p>代码同上，但是需要注释掉建边限制。以下为参考：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f)</span> &#123; <span class="comment">// 可行流</span></span><br><span class="line">    <span class="keyword">if</span> (f &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        g[u].push_back(e.size());</span><br><span class="line">        e.emplace_back(v, <span class="number">0</span>, f);</span><br><span class="line">        g[v].push_back(e.size());</span><br><span class="line">        e.emplace_back(u, c, -f);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        g[u].push_back(e.size());</span><br><span class="line">        e.emplace_back(v, c, f);</span><br><span class="line">        g[v].push_back(e.size());</span><br><span class="line">        e.emplace_back(u, <span class="number">0</span>, -f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f)</span> &#123; <span class="comment">// 最大流</span></span><br><span class="line">    g[u].push_back(e.size());</span><br><span class="line">    e.emplace_back(v, c, f);</span><br><span class="line">    g[v].push_back(e.size());</span><br><span class="line">    e.emplace_back(u, <span class="number">0</span>, -f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="08-树链剖分（HLD）">08 - 树链剖分（HLD）</h2><p><a href="https://codeforces.com/contest/1863/submission/221214363">2023-08-31</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HLD</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; siz, top, dep, parent, in, out, seq;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">HLD</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">HLD</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        siz.<span class="built_in">resize</span>(n);</span><br><span class="line">        top.<span class="built_in">resize</span>(n);</span><br><span class="line">        dep.<span class="built_in">resize</span>(n);</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        in.<span class="built_in">resize</span>(n);</span><br><span class="line">        out.<span class="built_in">resize</span>(n);</span><br><span class="line">        seq.<span class="built_in">resize</span>(n);</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        adj.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> root = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        top[root] = root;</span><br><span class="line">        dep[root] = <span class="number">0</span>;</span><br><span class="line">        parent[root] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(root);</span><br><span class="line">        <span class="built_in">dfs2</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[u] != <span class="number">-1</span>) &#123;</span><br><span class="line">            adj[u].<span class="built_in">erase</span>(std::<span class="built_in">find</span>(adj[u].<span class="built_in">begin</span>(), adj[u].<span class="built_in">end</span>(), parent[u]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        siz[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : adj[u]) &#123;</span><br><span class="line">            parent[v] = u;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span> (siz[v] &gt; siz[adj[u][<span class="number">0</span>]]) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(v, adj[u][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        in[u] = cur++;</span><br><span class="line">        seq[in[u]] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            top[v] = v == adj[u][<span class="number">0</span>] ? top[u] : v;</span><br><span class="line">            <span class="built_in">dfs2</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        out[u] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">                u = parent[top[u]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = parent[top[v]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dep[u] + dep[v] - <span class="number">2</span> * dep[<span class="built_in">lca</span>(u, v)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[u] &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> d = dep[u] - k;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (dep[top[u]] &gt; d) &#123;</span><br><span class="line">            u = parent[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> seq[in[u] - dep[u] + d];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAncester</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in[u] &lt;= in[v] &amp;&amp; in[v] &lt; out[u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rootedParent</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isAncester</span>(u, v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(adj[u].<span class="built_in">begin</span>(), adj[u].<span class="built_in">end</span>(), v, [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> in[x] &lt; in[y];</span><br><span class="line">        &#125;) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rootedSize</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isAncester</span>(v, u)) &#123;</span><br><span class="line">            <span class="keyword">return</span> siz[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - siz[<span class="built_in">rootedParent</span>(u, v)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rootedLca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lca</span>(a, b) ^ <span class="built_in">lca</span>(b, c) ^ <span class="built_in">lca</span>(c, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1>三、数论、几何、多项式</h1><h2 id="01-快速幂">01 - 快速幂</h2><p><a href="https://atcoder.jp/contests/tenka1-2017/submissions/46411797">2023-10-09</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a, i64 b, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a = <span class="number">1LL</span> * a * a % p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res = <span class="number">1LL</span> * res * a % p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="02-欧拉筛">02 - 欧拉筛</h2><p><a href="https://cf.dianhsu.com/gym/104479/submission/220987267">2023-08-29</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; minp, primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    minp.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    primes.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            minp[i] = i;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * p &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            minp[i * p] = p;</span><br><span class="line">            <span class="keyword">if</span> (p == minp[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="03-莫比乌斯函数筛（莫比乌斯函数-反演）">03 - 莫比乌斯函数筛（莫比乌斯函数/反演）</h2><p><a href="https://atcoder.jp/contests/tupc2022/submissions/39391116">2023-03-04</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">int</span>, Z&gt; fMu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1E7</span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; minp, primes;</span><br><span class="line">std::vector&lt;Z&gt; mu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    minp.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    mu.<span class="built_in">resize</span>(n);</span><br><span class="line">    primes.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            minp[i] = i;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * p &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            minp[i * p] = p;</span><br><span class="line">            <span class="keyword">if</span> (p == minp[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * p] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Z <span class="title">sumMu</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= N) &#123;</span><br><span class="line">        <span class="keyword">return</span> mu[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fMu.<span class="built_in">count</span>(n)) &#123;</span><br><span class="line">        <span class="keyword">return</span> fMu[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        ans -= (r - l + <span class="number">1</span>) * <span class="built_in">sumMu</span>(n / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sieve</span>(N);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> L, R;</span><br><span class="line">    std::cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    L -= <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    Z ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= R; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = R / (R / l);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= L) &#123;</span><br><span class="line">            r = std::<span class="built_in">min</span>(r, L / (L / l));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans += (<span class="built_in">power</span>(<span class="built_in">Z</span>(<span class="number">2</span>), R / l - L / l) - <span class="number">1</span>) * (<span class="built_in">sumMu</span>(r) - <span class="built_in">sumMu</span>(l - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="04-求解单个数的欧拉函数">04 - 求解单个数的欧拉函数</h2><p><a href="https://atcoder.jp/contests/tenka1-2017/submissions/46411797">2023-10-09</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="05-扩展欧几里得（exGCD）">05 - 扩展欧几里得（exGCD）</h2><p><a href="https://atcoder.jp/contests/tenka1-2017/submissions/46411797">2023-10-09</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="06-组合数（Comb-MInt-MLong）">06 - 组合数（Comb+MInt &amp; MLong）</h2><p><a href="https://codeforces.com/contest/1864/submission/220584872">2023-08-26</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Comb</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Z&gt; _fac;</span><br><span class="line">    std::vector&lt;Z&gt; _invfac;</span><br><span class="line">    std::vector&lt;Z&gt; _inv;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Comb</span>() : n&#123;<span class="number">0</span>&#125;, _fac&#123;<span class="number">1</span>&#125;, _invfac&#123;<span class="number">1</span>&#125;, _inv&#123;<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">Comb</span>(<span class="type">int</span> n) : <span class="built_in">Comb</span>() &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        m = std::<span class="built_in">min</span>(m, Z::<span class="built_in">getMod</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= n) <span class="keyword">return</span>;</span><br><span class="line">        _fac.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">        _invfac.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">        _inv.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            _fac[i] = _fac[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        _invfac[m] = _fac[m].<span class="built_in">inv</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt; n; i--) &#123;</span><br><span class="line">            _invfac[i - <span class="number">1</span>] = _invfac[i] * i;</span><br><span class="line">            _inv[i] = _invfac[i] * _fac[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        n = m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Z <span class="title">fac</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="built_in">init</span>(<span class="number">2</span> * m);</span><br><span class="line">        <span class="keyword">return</span> _fac[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">invfac</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="built_in">init</span>(<span class="number">2</span> * m);</span><br><span class="line">        <span class="keyword">return</span> _invfac[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="built_in">init</span>(<span class="number">2</span> * m);</span><br><span class="line">        <span class="keyword">return</span> _inv[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">binom</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fac</span>(n) * <span class="built_in">invfac</span>(m) * <span class="built_in">invfac</span>(n - m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; comb;</span><br></pre></td></tr></table></figure><h2 id="07-二项式（Binomial-任意模数计算）">07 - 二项式（Binomial 任意模数计算）</h2><p><a href="https://codeforces.com/contest/896/submission/219861532">2023-08-22</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">factorize</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; factors;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; <span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(i) * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; n % i == <span class="number">0</span>; n /= i)</span><br><span class="line">                ++t;</span><br><span class="line">            factors.<span class="built_in">emplace_back</span>(i, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        factors.<span class="built_in">emplace_back</span>(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> factors;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> base, i64 exp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; exp &gt; <span class="number">0</span>; base *= base, exp /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res *= base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> base, i64 exp, <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % mod;</span><br><span class="line">    <span class="keyword">for</span> (; exp &gt; <span class="number">0</span>; base = <span class="number">1LL</span> * base * base % mod, exp /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="number">1LL</span> * res * base % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inverse</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> g = m, r = a, x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> q = g / r;</span><br><span class="line">        g %= r;</span><br><span class="line">        std::<span class="built_in">swap</span>(g, r);</span><br><span class="line">        x -= q * y;</span><br><span class="line">        std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + m : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solveModuloEquations</span><span class="params">(<span class="type">const</span> std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; e.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        m *= e[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; e.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> p = e[i].first;</span><br><span class="line">        res = (res + <span class="number">1LL</span> * e[i].second * (m / p) * <span class="built_in">inverse</span>(m / p, p)) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1E5</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Binomial</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; factors;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; pk;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; prod;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> i64 <span class="title">exponent</span><span class="params">(i64 n, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        i64 res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (n /= p; n &gt; <span class="number">0</span>; n /= p) &#123;</span><br><span class="line">            res += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">product</span><span class="params">(i64 n, std::<span class="type">size_t</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p = factors[i].first;</span><br><span class="line">        <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n /= p) &#123;</span><br><span class="line">            res = <span class="number">1LL</span> * res * <span class="built_in">power</span>(prod[i].<span class="built_in">back</span>(), n / pk[i], pk[i]) % pk[i] * prod[i][n % pk[i]] % pk[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Binomial</span>(<span class="type">int</span> mod) : <span class="built_in">mod</span>(mod), <span class="built_in">factors</span>(<span class="built_in">factorize</span>(mod)) &#123;</span><br><span class="line">        pk.<span class="built_in">resize</span>(factors.<span class="built_in">size</span>());</span><br><span class="line">        prod.<span class="built_in">resize</span>(factors.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; factors.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = factors[i].first;</span><br><span class="line">            <span class="type">int</span> k = factors[i].second;</span><br><span class="line">            pk[i] = <span class="built_in">power</span>(p, k);</span><br><span class="line">            prod[i].<span class="built_in">resize</span>(std::<span class="built_in">min</span>(N + <span class="number">1</span>, pk[i]));</span><br><span class="line">            prod[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; prod[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j % p == <span class="number">0</span>) &#123;</span><br><span class="line">                    prod[i][j] = prod[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    prod[i][j] = <span class="number">1LL</span> * prod[i][j - <span class="number">1</span>] * j % pk[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(i64 n, i64 m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m || m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(factors.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; factors.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = factors[i].first;</span><br><span class="line">            <span class="type">int</span> k = factors[i].second;</span><br><span class="line">            <span class="type">int</span> e = <span class="built_in">exponent</span>(n, p) - <span class="built_in">exponent</span>(m, p) - <span class="built_in">exponent</span>(n - m, p);</span><br><span class="line">            <span class="keyword">if</span> (e &gt;= k) &#123;</span><br><span class="line">                ans[i] = std::<span class="built_in">make_pair</span>(pk[i], <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> pn = <span class="built_in">product</span>(n, i);</span><br><span class="line">                <span class="type">int</span> pm = <span class="built_in">product</span>(m, i);</span><br><span class="line">                <span class="type">int</span> pd = <span class="built_in">product</span>(n - m, i);</span><br><span class="line">                <span class="type">int</span> res = <span class="number">1LL</span> * pn * <span class="built_in">inverse</span>(pm, pk[i]) % pk[i] * <span class="built_in">inverse</span>(pd, pk[i]) % pk[i] * <span class="built_in">power</span>(p, e) % pk[i];</span><br><span class="line">                ans[i] = std::<span class="built_in">make_pair</span>(pk[i], res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solveModuloEquations</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="08-素数测试与因式分解（Miller-Rabin-Pollard-Rho）">08 - 素数测试与因式分解（Miller-Rabin &amp; Pollard-Rho）</h2><p><a href="https://cf.dianhsu.com/gym/104354/submission/206130894">2023-05-16</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">mul</span><span class="params">(i64 a, i64 b, i64 m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;__int128&gt;(a) * b % m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">i64 <span class="title">power</span><span class="params">(i64 a, i64 b, i64 m)</span> </span>&#123;</span><br><span class="line">    i64 res = <span class="number">1</span> % m;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul</span>(a, a, m))</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="built_in">mul</span>(res, a, m);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(i64 n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> A[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>&#125;;</span><br><span class="line">    <span class="type">int</span> s = __builtin_ctzll(n - <span class="number">1</span>);</span><br><span class="line">    i64 d = (n - <span class="number">1</span>) &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : A) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        i64 x = <span class="built_in">power</span>(a, d, n);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            x = <span class="built_in">mul</span>(x, x, n);</span><br><span class="line">            <span class="keyword">if</span> (x == n - <span class="number">1</span>) &#123;</span><br><span class="line">                ok = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ok)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::vector&lt;i64&gt; <span class="title">factorize</span><span class="params">(i64 n)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;i64&gt; p;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(i64)&gt; f = [&amp;](i64 n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i)</span><br><span class="line">                <span class="keyword">for</span> (; n % i == <span class="number">0</span>; n /= i)</span><br><span class="line">                    p.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">                p.<span class="built_in">push_back</span>(n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isprime</span>(n)) &#123;</span><br><span class="line">            p.<span class="built_in">push_back</span>(n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> g = [&amp;](i64 x) &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">mul</span>(x, x, n) + <span class="number">1</span>) % n;</span><br><span class="line">        &#125;;</span><br><span class="line">        i64 x0 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            i64 x = x0;</span><br><span class="line">            i64 y = x0;</span><br><span class="line">            i64 d = <span class="number">1</span>;</span><br><span class="line">            i64 power = <span class="number">1</span>, lam = <span class="number">0</span>;</span><br><span class="line">            i64 v = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (d == <span class="number">1</span>) &#123;</span><br><span class="line">                y = <span class="built_in">g</span>(y);</span><br><span class="line">                ++lam;</span><br><span class="line">                v = <span class="built_in">mul</span>(v, std::<span class="built_in">abs</span>(x - y), n);</span><br><span class="line">                <span class="keyword">if</span> (lam % <span class="number">127</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    d = std::<span class="built_in">gcd</span>(v, n);</span><br><span class="line">                    v = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (power == lam) &#123;</span><br><span class="line">                    x = y;</span><br><span class="line">                    power *= <span class="number">2</span>;</span><br><span class="line">                    lam = <span class="number">0</span>;</span><br><span class="line">                    d = std::<span class="built_in">gcd</span>(v, n);</span><br><span class="line">                    v = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d != n) &#123;</span><br><span class="line">                <span class="built_in">f</span>(d);</span><br><span class="line">                <span class="built_in">f</span>(n / d);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++x0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f</span>(n);</span><br><span class="line">    std::<span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="09-平面几何">09 - 平面几何</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=62808640">2023-07-17</a></p><p>长度过长，点击查看</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    T x;</span><br><span class="line">    T y;</span><br><span class="line">    <span class="built_in">Point</span>(T x_ = <span class="number">0</span>, T y_ = <span class="number">0</span>) : <span class="built_in">x</span>(x_), <span class="built_in">y</span>(y_) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    <span class="keyword">operator</span> <span class="built_in">Point</span>&lt;U&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>&lt;U&gt;(<span class="built_in">U</span>(x), <span class="built_in">U</span>(y));</span><br><span class="line">    &#125;</span><br><span class="line">    Point &amp;<span class="keyword">operator</span>+=(Point p) &amp; &#123;</span><br><span class="line">        x += p.x;</span><br><span class="line">        y += p.y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Point &amp;<span class="keyword">operator</span>-=(Point p) &amp; &#123;</span><br><span class="line">        x -= p.x;</span><br><span class="line">        y -= p.y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Point &amp;<span class="keyword">operator</span>*=(T v) &amp; &#123;</span><br><span class="line">        x *= v;</span><br><span class="line">        y *= v;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(-x, -y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>+(Point a, Point b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a += b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>-(Point a, Point b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a -= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>*(Point a, T b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a *= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>*(T a, Point b) &#123;</span><br><span class="line">        <span class="keyword">return</span> b *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(Point a, Point b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Point &amp;p) &#123;</span><br><span class="line">        <span class="keyword">return</span> is &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, Point p) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">dot</span><span class="params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">cross</span><span class="params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">square</span><span class="params">(Point&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>(p, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">(Point&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">double</span>(<span class="built_in">square</span>(p)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">length</span><span class="params">(Point&lt;<span class="type">long</span> <span class="type">double</span>&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">square</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    Point&lt;T&gt; a;</span><br><span class="line">    Point&lt;T&gt; b;</span><br><span class="line">    <span class="built_in">Line</span>(Point&lt;T&gt; a_ = <span class="built_in">Point</span>&lt;T&gt;(), Point&lt;T&gt; b_ = <span class="built_in">Point</span>&lt;T&gt;()) : <span class="built_in">a</span>(a_), <span class="built_in">b</span>(b_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">Point&lt;T&gt; <span class="title">rotate</span><span class="params">(Point&lt;T&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(-a.y, a.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(Point&lt;T&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &gt; <span class="number">0</span> || (a.y == <span class="number">0</span> &amp;&amp; a.x &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pointOnLineLeft</span><span class="params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cross</span>(l.b - l.a, p - l.a) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">Point&lt;T&gt; <span class="title">lineIntersection</span><span class="params">(Line&lt;T&gt; l1, Line&lt;T&gt; l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l<span class="number">1.</span>a + (l<span class="number">1.</span>b - l<span class="number">1.</span>a) * (<span class="built_in">cross</span>(l<span class="number">2.</span>b - l<span class="number">2.</span>a, l<span class="number">1.</span>a - l<span class="number">2.</span>a) / <span class="built_in">cross</span>(l<span class="number">2.</span>b - l<span class="number">2.</span>a, l<span class="number">1.</span>a - l<span class="number">1.</span>b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pointOnSegment</span><span class="params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cross</span>(p - l.a, l.b - l.a) == <span class="number">0</span> &amp;&amp; std::<span class="built_in">min</span>(l.a.x, l.b.x) &lt;= p.x &amp;&amp; p.x &lt;= std::<span class="built_in">max</span>(l.a.x, l.b.x)</span><br><span class="line">    &amp;&amp; std::<span class="built_in">min</span>(l.a.y, l.b.y) &lt;= p.y &amp;&amp; p.y &lt;= std::<span class="built_in">max</span>(l.a.y, l.b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pointInPolygon</span><span class="params">(Point&lt;T&gt; a, std::vector&lt;Point&lt;T&gt;&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pointOnSegment</span>(a, <span class="built_in">Line</span>(p[i], p[(i + <span class="number">1</span>) % n]))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> u = p[i];</span><br><span class="line">        <span class="keyword">auto</span> v = p[(i + <span class="number">1</span>) % n];</span><br><span class="line">        <span class="keyword">if</span> (u.x &lt; a.x &amp;&amp; v.x &gt;= a.x &amp;&amp; <span class="built_in">pointOnLineLeft</span>(a, <span class="built_in">Line</span>(v, u))) &#123;</span><br><span class="line">            t ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u.x &gt;= a.x &amp;&amp; v.x &lt; a.x &amp;&amp; <span class="built_in">pointOnLineLeft</span>(a, <span class="built_in">Line</span>(u, v))) &#123;</span><br><span class="line">            t ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> t == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 : not intersect</span></span><br><span class="line"><span class="comment">// 1 : strictly intersect</span></span><br><span class="line"><span class="comment">// 2 : overlap</span></span><br><span class="line"><span class="comment">// 3 : intersect at endpoint</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">std::tuple&lt;<span class="type">int</span>, Point&lt;T&gt;, Point&lt;T&gt;&gt; <span class="built_in">segmentIntersection</span>(Line&lt;T&gt; l1, Line&lt;T&gt; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">max</span>(l<span class="number">1.</span>a.x, l<span class="number">1.</span>b.x) &lt; std::<span class="built_in">min</span>(l<span class="number">2.</span>a.x, l<span class="number">2.</span>b.x)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="built_in">Point</span>&lt;T&gt;(), <span class="built_in">Point</span>&lt;T&gt;()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">min</span>(l<span class="number">1.</span>a.x, l<span class="number">1.</span>b.x) &gt; std::<span class="built_in">max</span>(l<span class="number">2.</span>a.x, l<span class="number">2.</span>b.x)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="built_in">Point</span>&lt;T&gt;(), <span class="built_in">Point</span>&lt;T&gt;()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">max</span>(l<span class="number">1.</span>a.y, l<span class="number">1.</span>b.y) &lt; std::<span class="built_in">min</span>(l<span class="number">2.</span>a.y, l<span class="number">2.</span>b.y)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="built_in">Point</span>&lt;T&gt;(), <span class="built_in">Point</span>&lt;T&gt;()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">min</span>(l<span class="number">1.</span>a.y, l<span class="number">1.</span>b.y) &gt; std::<span class="built_in">max</span>(l<span class="number">2.</span>a.y, l<span class="number">2.</span>b.y)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="built_in">Point</span>&lt;T&gt;(), <span class="built_in">Point</span>&lt;T&gt;()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cross</span>(l<span class="number">1.</span>b - l<span class="number">1.</span>a, l<span class="number">2.</span>b - l<span class="number">2.</span>a) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cross</span>(l<span class="number">1.</span>b - l<span class="number">1.</span>a, l<span class="number">2.</span>a - l<span class="number">1.</span>a) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="built_in">Point</span>&lt;T&gt;(), <span class="built_in">Point</span>&lt;T&gt;()&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> maxx1 = std::<span class="built_in">max</span>(l<span class="number">1.</span>a.x, l<span class="number">1.</span>b.x);</span><br><span class="line">            <span class="keyword">auto</span> minx1 = std::<span class="built_in">min</span>(l<span class="number">1.</span>a.x, l<span class="number">1.</span>b.x);</span><br><span class="line">            <span class="keyword">auto</span> maxy1 = std::<span class="built_in">max</span>(l<span class="number">1.</span>a.y, l<span class="number">1.</span>b.y);</span><br><span class="line">            <span class="keyword">auto</span> miny1 = std::<span class="built_in">min</span>(l<span class="number">1.</span>a.y, l<span class="number">1.</span>b.y);</span><br><span class="line">            <span class="keyword">auto</span> maxx2 = std::<span class="built_in">max</span>(l<span class="number">2.</span>a.x, l<span class="number">2.</span>b.x);</span><br><span class="line">            <span class="keyword">auto</span> minx2 = std::<span class="built_in">min</span>(l<span class="number">2.</span>a.x, l<span class="number">2.</span>b.x);</span><br><span class="line">            <span class="keyword">auto</span> maxy2 = std::<span class="built_in">max</span>(l<span class="number">2.</span>a.y, l<span class="number">2.</span>b.y);</span><br><span class="line">            <span class="keyword">auto</span> miny2 = std::<span class="built_in">min</span>(l<span class="number">2.</span>a.y, l<span class="number">2.</span>b.y);</span><br><span class="line">            <span class="function">Point&lt;T&gt; <span class="title">p1</span><span class="params">(std::max(minx1, minx2), std::max(miny1, miny2))</span></span>;</span><br><span class="line">            <span class="function">Point&lt;T&gt; <span class="title">p2</span><span class="params">(std::min(maxx1, maxx2), std::min(maxy1, maxy2))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">pointOnSegment</span>(p1, l1)) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(p<span class="number">1.</span>y, p<span class="number">2.</span>y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="number">3</span>, p1, p2&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="number">2</span>, p1, p2&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> cp1 = <span class="built_in">cross</span>(l<span class="number">2.</span>a - l<span class="number">1.</span>a, l<span class="number">2.</span>b - l<span class="number">1.</span>a);</span><br><span class="line">    <span class="keyword">auto</span> cp2 = <span class="built_in">cross</span>(l<span class="number">2.</span>a - l<span class="number">1.</span>b, l<span class="number">2.</span>b - l<span class="number">1.</span>b);</span><br><span class="line">    <span class="keyword">auto</span> cp3 = <span class="built_in">cross</span>(l<span class="number">1.</span>a - l<span class="number">2.</span>a, l<span class="number">1.</span>b - l<span class="number">2.</span>a);</span><br><span class="line">    <span class="keyword">auto</span> cp4 = <span class="built_in">cross</span>(l<span class="number">1.</span>a - l<span class="number">2.</span>b, l<span class="number">1.</span>b - l<span class="number">2.</span>b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((cp1 &gt; <span class="number">0</span> &amp;&amp; cp2 &gt; <span class="number">0</span>) || (cp1 &lt; <span class="number">0</span> &amp;&amp; cp2 &lt; <span class="number">0</span>) || (cp3 &gt; <span class="number">0</span> &amp;&amp; cp4 &gt; <span class="number">0</span>) || (cp3 &lt; <span class="number">0</span> &amp;&amp; cp4 &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="built_in">Point</span>&lt;T&gt;(), <span class="built_in">Point</span>&lt;T&gt;()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Point p = <span class="built_in">lineIntersection</span>(l1, l2);</span><br><span class="line">    <span class="keyword">if</span> (cp1 != <span class="number">0</span> &amp;&amp; cp2 != <span class="number">0</span> &amp;&amp; cp3 != <span class="number">0</span> &amp;&amp; cp4 != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>, p, p&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">3</span>, p, p&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">segmentInPolygon</span><span class="params">(Line&lt;T&gt; l, std::vector&lt;Point&lt;T&gt;&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">pointInPolygon</span>(l.a, p)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">pointInPolygon</span>(l.b, p)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> u = p[i];</span><br><span class="line">        <span class="keyword">auto</span> v = p[(i + <span class="number">1</span>) % n];</span><br><span class="line">        <span class="keyword">auto</span> w = p[(i + <span class="number">2</span>) % n];</span><br><span class="line">        <span class="keyword">auto</span> [t, p1, p2] = <span class="built_in">segmentIntersection</span>(l, <span class="built_in">Line</span>(u, v));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pointOnSegment</span>(v, l) &amp;&amp; v != l.a &amp;&amp; v != l.b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">cross</span>(v - u, w - v) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 != u &amp;&amp; p1 != v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">pointOnLineLeft</span>(l.a, <span class="built_in">Line</span>(v, u))</span><br><span class="line">                    || <span class="built_in">pointOnLineLeft</span>(l.b, <span class="built_in">Line</span>(v, u))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 == v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l.a == v) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">pointOnLineLeft</span>(u, l)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">pointOnLineLeft</span>(w, l)</span><br><span class="line">                            &amp;&amp; <span class="built_in">pointOnLineLeft</span>(w, <span class="built_in">Line</span>(u, v))) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">pointOnLineLeft</span>(w, l)</span><br><span class="line">                            || <span class="built_in">pointOnLineLeft</span>(w, <span class="built_in">Line</span>(u, v))) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l.b == v) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">pointOnLineLeft</span>(u, <span class="built_in">Line</span>(l.b, l.a))) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">pointOnLineLeft</span>(w, <span class="built_in">Line</span>(l.b, l.a))</span><br><span class="line">                            &amp;&amp; <span class="built_in">pointOnLineLeft</span>(w, <span class="built_in">Line</span>(u, v))) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">pointOnLineLeft</span>(w, <span class="built_in">Line</span>(l.b, l.a))</span><br><span class="line">                            || <span class="built_in">pointOnLineLeft</span>(w, <span class="built_in">Line</span>(u, v))) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">pointOnLineLeft</span>(u, l)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">pointOnLineLeft</span>(w, <span class="built_in">Line</span>(l.b, l.a))</span><br><span class="line">                            || <span class="built_in">pointOnLineLeft</span>(w, <span class="built_in">Line</span>(u, v))) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">pointOnLineLeft</span>(w, l)</span><br><span class="line">                            || <span class="built_in">pointOnLineLeft</span>(w, <span class="built_in">Line</span>(u, v))) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">std::vector&lt;Point&lt;T&gt;&gt; <span class="built_in">hp</span>(std::vector&lt;Line&lt;T&gt;&gt; lines) &#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(lines.<span class="built_in">begin</span>(), lines.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> l1, <span class="keyword">auto</span> l2) &#123;</span><br><span class="line">        <span class="keyword">auto</span> d1 = l<span class="number">1.</span>b - l<span class="number">1.</span>a;</span><br><span class="line">        <span class="keyword">auto</span> d2 = l<span class="number">2.</span>b - l<span class="number">2.</span>a;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sgn</span>(d1) != <span class="built_in">sgn</span>(d2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sgn</span>(d1) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cross</span>(d1, d2) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::deque&lt;Line&lt;T&gt;&gt; ls;</span><br><span class="line">    std::deque&lt;Point&lt;T&gt;&gt; ps;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> l : lines) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ls.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ls.<span class="built_in">push_back</span>(l);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!ps.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">pointOnLineLeft</span>(ps.<span class="built_in">back</span>(), l)) &#123;</span><br><span class="line">            ps.<span class="built_in">pop_back</span>();</span><br><span class="line">            ls.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!ps.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">pointOnLineLeft</span>(ps[<span class="number">0</span>], l)) &#123;</span><br><span class="line">            ps.<span class="built_in">pop_front</span>();</span><br><span class="line">            ls.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cross</span>(l.b - l.a, ls.<span class="built_in">back</span>().b - ls.<span class="built_in">back</span>().a) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dot</span>(l.b - l.a, ls.<span class="built_in">back</span>().b - ls.<span class="built_in">back</span>().a) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">pointOnLineLeft</span>(ls.<span class="built_in">back</span>().a, l)) &#123;</span><br><span class="line">                    <span class="built_in">assert</span>(ls.<span class="built_in">size</span>() == <span class="number">1</span>);</span><br><span class="line">                    ls[<span class="number">0</span>] = l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ps.<span class="built_in">push_back</span>(<span class="built_in">lineIntersection</span>(ls.<span class="built_in">back</span>(), l));</span><br><span class="line">        ls.<span class="built_in">push_back</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!ps.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">pointOnLineLeft</span>(ps.<span class="built_in">back</span>(), ls[<span class="number">0</span>])) &#123;</span><br><span class="line">        ps.<span class="built_in">pop_back</span>();</span><br><span class="line">        ls.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ls.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ps.<span class="built_in">push_back</span>(<span class="built_in">lineIntersection</span>(ls[<span class="number">0</span>], ls.<span class="built_in">back</span>()));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">vector</span>(ps.<span class="built_in">begin</span>(), ps.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-静态凸包">10 - 静态凸包</h2><p><a href="https://cf.dianhsu.com/gym/104288/submission/201412835">2023-04-09</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    i64 x;</span><br><span class="line">    i64 y;</span><br><span class="line">    <span class="built_in">Point</span>(i64 x = <span class="number">0</span>, i64 y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(a.x + b.x, a.y + b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>-(<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(a.x - b.x, a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">dot</span><span class="params">(<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">cross</span><span class="params">(<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">norm</span><span class="params">(std::vector&lt;Point&gt; &amp;h)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">int</span>(h.<span class="built_in">size</span>()); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[j].y &lt; h[i].y || (h[j].y == h[i].y &amp;&amp; h[j].x &lt; h[i].x)) &#123;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">rotate</span>(h.<span class="built_in">begin</span>(), h.<span class="built_in">begin</span>() + i, h.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">const</span> Point &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &gt; <span class="number">0</span> || (a.y == <span class="number">0</span> &amp;&amp; a.x &gt; <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;Point&gt; <span class="title">getHull</span><span class="params">(std::vector&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Point&gt; h, l;</span><br><span class="line">    std::<span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.x != b.x) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    p.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()), p.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : p) &#123;</span><br><span class="line">        <span class="keyword">while</span> (h.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">cross</span>(a - h.<span class="built_in">back</span>(), a - h[h.<span class="built_in">size</span>() - <span class="number">2</span>]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">cross</span>(a - l.<span class="built_in">back</span>(), a - l[l.<span class="built_in">size</span>() - <span class="number">2</span>]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            l.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        l.<span class="built_in">push_back</span>(a);</span><br><span class="line">        h.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    l.<span class="built_in">pop_back</span>();</span><br><span class="line">    std::<span class="built_in">reverse</span>(h.<span class="built_in">begin</span>(), h.<span class="built_in">end</span>());</span><br><span class="line">    h.<span class="built_in">pop_back</span>();</span><br><span class="line">    l.<span class="built_in">insert</span>(l.<span class="built_in">end</span>(), h.<span class="built_in">begin</span>(), h.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11A-多项式相关（Poly-旧版）">11A - 多项式相关（Poly 旧版）</h2><p><a href="https://atcoder.jp/contests/arc155/submissions/38664055">2023-02-06</a></p><p>长度过长，点击查看</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; rev;</span><br><span class="line">std::vector&lt;Z&gt; roots&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dft</span><span class="params">(std::vector&lt;Z&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int</span>(rev.<span class="built_in">size</span>()) != n) &#123;</span><br><span class="line">        <span class="type">int</span> k = __builtin_ctz(n) - <span class="number">1</span>;</span><br><span class="line">        rev.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) &lt;&lt; k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rev[i] &lt; i) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int</span>(roots.<span class="built_in">size</span>()) &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> k = __builtin_ctz(roots.<span class="built_in">size</span>());</span><br><span class="line">        roots.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) &#123;</span><br><span class="line">            Z e = <span class="built_in">power</span>(<span class="built_in">Z</span>(<span class="number">3</span>), (P - <span class="number">1</span>) &gt;&gt; (k + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>); i &lt; (<span class="number">1</span> &lt;&lt; k); i++) &#123;</span><br><span class="line">                roots[<span class="number">2</span> * i] = roots[i];</span><br><span class="line">                roots[<span class="number">2</span> * i + <span class="number">1</span>] = roots[i] * e;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; k *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                Z u = a[i + j];</span><br><span class="line">                Z v = a[i + j + k] * roots[k + j];</span><br><span class="line">                a[i + j] = u + v;</span><br><span class="line">                a[i + j + k] = u - v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">idft</span><span class="params">(std::vector&lt;Z&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    std::<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">dft</span>(a);</span><br><span class="line">    Z inv = (<span class="number">1</span> - P) / n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] *= inv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Poly</span> &#123;</span><br><span class="line">    std::vector&lt;Z&gt; a;</span><br><span class="line">    <span class="built_in">Poly</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Poly</span><span class="params">(<span class="type">int</span> size, std::function&lt;Z(<span class="type">int</span>)&gt; f = [](<span class="type">int</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;)</span> : a(size) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            a[i] = <span class="built_in">f</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Poly</span>(<span class="type">const</span> std::vector&lt;Z&gt; &amp;a) : <span class="built_in">a</span>(a) &#123;&#125;</span><br><span class="line">    <span class="built_in">Poly</span>(<span class="type">const</span> std::initializer_list&lt;Z&gt; &amp;a) : <span class="built_in">a</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    Z <span class="keyword">operator</span>[](<span class="type">int</span> idx) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[idx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">mulxk</span><span class="params">(<span class="type">int</span> k)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> b = a;</span><br><span class="line">        b.<span class="built_in">insert</span>(b.<span class="built_in">begin</span>(), k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Poly</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">modxk</span><span class="params">(<span class="type">int</span> k)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        k = std::<span class="built_in">min</span>(k, <span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Poly</span>(std::<span class="built_in">vector</span>&lt;Z&gt;(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">divxk</span><span class="params">(<span class="type">int</span> k)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Poly</span>(std::<span class="built_in">vector</span>&lt;Z&gt;(a.<span class="built_in">begin</span>() + k, a.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Poly <span class="keyword">operator</span>+(<span class="type">const</span> Poly &amp;a, <span class="type">const</span> Poly &amp;b) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;Z&gt; <span class="title">res</span><span class="params">(std::max(a.size(), b.size()))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(res.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">            res[i] = a[i] + b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Poly</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Poly <span class="keyword">operator</span>-(<span class="type">const</span> Poly &amp;a, <span class="type">const</span> Poly &amp;b) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;Z&gt; <span class="title">res</span><span class="params">(std::max(a.size(), b.size()))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(res.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">            res[i] = a[i] - b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Poly</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Poly <span class="keyword">operator</span>-(<span class="type">const</span> Poly &amp;a) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;Z&gt; <span class="title">res</span><span class="params">(a.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(res.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">            res[i] = -a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Poly</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Poly <span class="keyword">operator</span>*(Poly a, Poly b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">size</span>() == <span class="number">0</span> || b.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">size</span>() &lt; <span class="number">128</span>) &#123;</span><br><span class="line">            <span class="function">Poly <span class="title">c</span><span class="params">(a.size() + b.size() - <span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    c[i + j] += a[i] * b[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (sz &lt; tot) &#123;</span><br><span class="line">            sz *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a.a.<span class="built_in">resize</span>(sz);</span><br><span class="line">        b.a.<span class="built_in">resize</span>(sz);</span><br><span class="line">        <span class="built_in">dft</span>(a.a);</span><br><span class="line">        <span class="built_in">dft</span>(b.a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">            a.a[i] = a[i] * b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">idft</span>(a.a);</span><br><span class="line">        a.<span class="built_in">resize</span>(tot);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Poly <span class="keyword">operator</span>*(Z a, Poly b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(b.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">            b[i] *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Poly <span class="keyword">operator</span>*(Poly a, Z b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(a.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">            a[i] *= b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly &amp;<span class="keyword">operator</span>+=(Poly b) &#123;</span><br><span class="line">        <span class="built_in">return</span> (*<span class="keyword">this</span>) = (*<span class="keyword">this</span>) + b;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly &amp;<span class="keyword">operator</span>-=(Poly b) &#123;</span><br><span class="line">        <span class="built_in">return</span> (*<span class="keyword">this</span>) = (*<span class="keyword">this</span>) - b;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly &amp;<span class="keyword">operator</span>*=(Poly b) &#123;</span><br><span class="line">        <span class="built_in">return</span> (*<span class="keyword">this</span>) = (*<span class="keyword">this</span>) * b;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly &amp;<span class="keyword">operator</span>*=(Z b) &#123;</span><br><span class="line">        <span class="built_in">return</span> (*<span class="keyword">this</span>) = (*<span class="keyword">this</span>) * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">deriv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::vector&lt;Z&gt; <span class="title">res</span><span class="params">(size() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            res[i] = (i + <span class="number">1</span>) * a[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Poly</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">integr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;Z&gt; <span class="title">res</span><span class="params">(size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res[i + <span class="number">1</span>] = a[i] / (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Poly</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">inv</span><span class="params">(<span class="type">int</span> m)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Poly x&#123;a[<span class="number">0</span>].<span class="built_in">inv</span>()&#125;;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; m) &#123;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">            x = (x * (Poly&#123;<span class="number">2</span>&#125; - <span class="built_in">modxk</span>(k) * x)).<span class="built_in">modxk</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">modxk</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">log</span><span class="params">(<span class="type">int</span> m)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">deriv</span>() * <span class="built_in">inv</span>(m)).<span class="built_in">integr</span>().<span class="built_in">modxk</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">exp</span><span class="params">(<span class="type">int</span> m)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Poly x&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; m) &#123;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">            x = (x * (Poly&#123;<span class="number">1</span>&#125; - x.<span class="built_in">log</span>(k) + <span class="built_in">modxk</span>(k))).<span class="built_in">modxk</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">modxk</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">pow</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="built_in">size</span>() &amp;&amp; a[i].<span class="built_in">val</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="built_in">size</span>() || <span class="number">1LL</span> * i * k &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>(std::<span class="built_in">vector</span>&lt;Z&gt;(m));</span><br><span class="line">        &#125;</span><br><span class="line">        Z v = a[i];</span><br><span class="line">        <span class="keyword">auto</span> f = <span class="built_in">divxk</span>(i) * v.<span class="built_in">inv</span>();</span><br><span class="line">        <span class="keyword">return</span> (f.<span class="built_in">log</span>(m - i * k) * k).<span class="built_in">exp</span>(m - i * k).<span class="built_in">mulxk</span>(i * k) * <span class="built_in">power</span>(v, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">sqrt</span><span class="params">(<span class="type">int</span> m)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Poly x&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; m) &#123;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">            x = (x + (<span class="built_in">modxk</span>(k) * x.<span class="built_in">inv</span>(k)).<span class="built_in">modxk</span>(k)) * ((P + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">modxk</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">mulT</span><span class="params">(Poly b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = b.<span class="built_in">size</span>();</span><br><span class="line">        std::<span class="built_in">reverse</span>(b.a.<span class="built_in">begin</span>(), b.a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ((*<span class="keyword">this</span>) * b).<span class="built_in">divxk</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;Z&gt; <span class="title">eval</span><span class="params">(std::vector&lt;Z&gt; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;Z&gt;(x.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = std::<span class="built_in">max</span>(<span class="built_in">int</span>(x.<span class="built_in">size</span>()), <span class="built_in">size</span>());</span><br><span class="line">        <span class="function">std::vector&lt;Poly&gt; <span class="title">q</span><span class="params">(<span class="number">4</span> * n)</span></span>;</span><br><span class="line">        <span class="function">std::vector&lt;Z&gt; <span class="title">ans</span><span class="params">(x.size())</span></span>;</span><br><span class="line">        x.<span class="built_in">resize</span>(n);</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                q[p] = Poly&#123;<span class="number">1</span>, -x[l]&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line">                <span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line">                q[p] = q[<span class="number">2</span> * p] * q[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">const</span> Poly &amp;)&gt; work = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Poly &amp;num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l &lt; <span class="built_in">int</span>(ans.<span class="built_in">size</span>())) &#123;</span><br><span class="line">                    ans[l] = num[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">work</span>(<span class="number">2</span> * p, l, m, num.<span class="built_in">mulT</span>(q[<span class="number">2</span> * p + <span class="number">1</span>]).<span class="built_in">modxk</span>(m - l));</span><br><span class="line">                <span class="built_in">work</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, num.<span class="built_in">mulT</span>(q[<span class="number">2</span> * p]).<span class="built_in">modxk</span>(r - m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">work</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="built_in">mulT</span>(q[<span class="number">1</span>].<span class="built_in">inv</span>(n)));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11B-多项式相关（Poly-MInt-MLong-新版）">11B - 多项式相关（Poly+MInt &amp; MLong 新版）</h2><p><a href="https://atcoder.jp/contests/arc163/submissions/45737810">2023-09-20</a></p><p>长度过长，点击查看</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; rev;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> P&gt;</span><br><span class="line">std::vector&lt;MInt&lt;P&gt;&gt; roots&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> P&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> MInt&lt;P&gt; <span class="title">findPrimitiveRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MInt&lt;P&gt; i = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> k = __builtin_ctz(P - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">power</span>(i, (P - <span class="number">1</span>) / <span class="number">2</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">power</span>(i, (P - <span class="number">1</span>) &gt;&gt; k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> P&gt;</span><br><span class="line"><span class="keyword">constexpr</span> MInt&lt;P&gt; primitiveRoot = <span class="built_in">findPrimitiveRoot</span>&lt;P&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> MInt&lt;<span class="number">998244353</span>&gt; primitiveRoot&lt;<span class="number">998244353</span>&gt; &#123;<span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> P&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">dft</span><span class="params">(std::vector&lt;MInt&lt;P&gt;&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int</span>(rev.<span class="built_in">size</span>()) != n) &#123;</span><br><span class="line">        <span class="type">int</span> k = __builtin_ctz(n) - <span class="number">1</span>;</span><br><span class="line">        rev.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) &lt;&lt; k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rev[i] &lt; i) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (roots&lt;P&gt;.<span class="built_in">size</span>() &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> k = __builtin_ctz(roots&lt;P&gt;.<span class="built_in">size</span>());</span><br><span class="line">        roots&lt;P&gt;.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = <span class="built_in">power</span>(primitiveRoot&lt;P&gt;, <span class="number">1</span> &lt;&lt; (__builtin_ctz(P - <span class="number">1</span>) - k - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>); i &lt; (<span class="number">1</span> &lt;&lt; k); i++) &#123;</span><br><span class="line">                roots&lt;P&gt;[<span class="number">2</span> * i] = roots&lt;P&gt;[i];</span><br><span class="line">                roots&lt;P&gt;[<span class="number">2</span> * i + <span class="number">1</span>] = roots&lt;P&gt;[i] * e;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; k *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                MInt&lt;P&gt; u = a[i + j];</span><br><span class="line">                MInt&lt;P&gt; v = a[i + j + k] * roots&lt;P&gt;[k + j];</span><br><span class="line">                a[i + j] = u + v;</span><br><span class="line">                a[i + j + k] = u - v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> P&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">idft</span><span class="params">(std::vector&lt;MInt&lt;P&gt;&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    std::<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">dft</span>(a);</span><br><span class="line">    MInt&lt;P&gt; inv = (<span class="number">1</span> - P) / n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] *= inv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> P = <span class="number">998244353</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Poly : <span class="keyword">public</span> std::vector&lt;MInt&lt;P&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Value = MInt&lt;P&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Poly</span>() : std::<span class="built_in">vector</span>&lt;Value&gt;() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="title">Poly</span><span class="params">(<span class="type">int</span> n)</span> : std::vector&lt;Value&gt;(n) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="title">Poly</span><span class="params">(<span class="type">const</span> std::vector&lt;Value&gt; &amp;a)</span> : std::vector&lt;Value&gt;(a) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Poly</span><span class="params">(<span class="type">const</span> std::initializer_list&lt;Value&gt; &amp;a)</span> : std::vector&lt;Value&gt;(a) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIt</span>, <span class="keyword">class</span> = std::_RequireInputIter&lt;InputIt&gt;&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="built_in">Poly</span>(InputIt first, InputIt last) : std::<span class="built_in">vector</span>&lt;Value&gt;(first, last) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="built_in">Poly</span>(<span class="type">int</span> n, F f) : std::<span class="built_in">vector</span>&lt;Value&gt;(n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            (*<span class="keyword">this</span>)[i] = <span class="built_in">f</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Poly <span class="title">shift</span><span class="params">(<span class="type">int</span> k)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> b = *<span class="keyword">this</span>;</span><br><span class="line">            b.<span class="built_in">insert</span>(b.<span class="built_in">begin</span>(), k, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">size</span>() &lt;= -k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>(<span class="keyword">this</span>-&gt;<span class="built_in">begin</span>() + (-k), <span class="keyword">this</span>-&gt;<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Poly <span class="title">trunc</span><span class="params">(<span class="type">int</span> k)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Poly f = *<span class="keyword">this</span>;</span><br><span class="line">        f.<span class="built_in">resize</span>(k);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Poly <span class="keyword">operator</span>+(<span class="type">const</span> Poly &amp;a, <span class="type">const</span> Poly &amp;b) &#123;</span><br><span class="line">        <span class="function">Poly <span class="title">res</span><span class="params">(std::max(a.size(), b.size()))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] += b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Poly <span class="keyword">operator</span>-(<span class="type">const</span> Poly &amp;a, <span class="type">const</span> Poly &amp;b) &#123;</span><br><span class="line">        <span class="function">Poly <span class="title">res</span><span class="params">(std::max(a.size(), b.size()))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] -= b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Poly <span class="keyword">operator</span>-(<span class="type">const</span> Poly &amp;a) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;Value&gt; <span class="title">res</span><span class="params">(a.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(res.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">            res[i] = -a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Poly</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Poly <span class="keyword">operator</span>*(Poly a, Poly b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">size</span>() == <span class="number">0</span> || b.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; tot) &#123;</span><br><span class="line">            n *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (((P - <span class="number">1</span>) &amp; (n - <span class="number">1</span>)) != <span class="number">0</span> || b.<span class="built_in">size</span>() &lt; <span class="number">128</span>) &#123;</span><br><span class="line">            <span class="function">Poly <span class="title">c</span><span class="params">(a.size() + b.size() - <span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    c[i + j] += a[i] * b[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        a.<span class="built_in">resize</span>(n);</span><br><span class="line">        b.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="built_in">dft</span>(a);</span><br><span class="line">        <span class="built_in">dft</span>(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            a[i] *= b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">idft</span>(a);</span><br><span class="line">        a.<span class="built_in">resize</span>(tot);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Poly <span class="keyword">operator</span>*(Value a, Poly b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(b.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">            b[i] *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Poly <span class="keyword">operator</span>*(Poly a, Value b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(a.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">            a[i] *= b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Poly <span class="keyword">operator</span>/(Poly a, Value b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(a.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">            a[i] /= b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Poly &amp;<span class="keyword">operator</span>+=(Poly b) &#123;</span><br><span class="line">        <span class="built_in">return</span> (*<span class="keyword">this</span>) = (*<span class="keyword">this</span>) + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Poly &amp;<span class="keyword">operator</span>-=(Poly b) &#123;</span><br><span class="line">        <span class="built_in">return</span> (*<span class="keyword">this</span>) = (*<span class="keyword">this</span>) - b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Poly &amp;<span class="keyword">operator</span>*=(Poly b) &#123;</span><br><span class="line">        <span class="built_in">return</span> (*<span class="keyword">this</span>) = (*<span class="keyword">this</span>) * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Poly &amp;<span class="keyword">operator</span>*=(Value b) &#123;</span><br><span class="line">        <span class="built_in">return</span> (*<span class="keyword">this</span>) = (*<span class="keyword">this</span>) * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Poly &amp;<span class="keyword">operator</span>/=(Value b) &#123;</span><br><span class="line">        <span class="built_in">return</span> (*<span class="keyword">this</span>) = (*<span class="keyword">this</span>) / b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Poly <span class="title">deriv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Poly <span class="title">res</span><span class="params">(<span class="keyword">this</span>-&gt;size() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            res[i] = (i + <span class="number">1</span>) * (*<span class="keyword">this</span>)[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Poly <span class="title">integr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">Poly <span class="title">res</span><span class="params">(<span class="keyword">this</span>-&gt;size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res[i + <span class="number">1</span>] = (*<span class="keyword">this</span>)[i] / (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Poly <span class="title">inv</span><span class="params">(<span class="type">int</span> m)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Poly x&#123;(*<span class="keyword">this</span>)[<span class="number">0</span>].<span class="built_in">inv</span>()&#125;;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; m) &#123;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">            x = (x * (Poly&#123;<span class="number">2</span>&#125; - <span class="built_in">trunc</span>(k) * x)).<span class="built_in">trunc</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">trunc</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Poly <span class="title">log</span><span class="params">(<span class="type">int</span> m)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">deriv</span>() * <span class="built_in">inv</span>(m)).<span class="built_in">integr</span>().<span class="built_in">trunc</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Poly <span class="title">exp</span><span class="params">(<span class="type">int</span> m)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Poly x&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; m) &#123;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">            x = (x * (Poly&#123;<span class="number">1</span>&#125; - x.<span class="built_in">log</span>(k) + <span class="built_in">trunc</span>(k))).<span class="built_in">trunc</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">trunc</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Poly <span class="title">pow</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="keyword">this</span>-&gt;<span class="built_in">size</span>() &amp;&amp; (*<span class="keyword">this</span>)[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="keyword">this</span>-&gt;<span class="built_in">size</span>() || <span class="number">1LL</span> * i * k &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>(m);</span><br><span class="line">        &#125;</span><br><span class="line">        Value v = (*<span class="keyword">this</span>)[i];</span><br><span class="line">        <span class="keyword">auto</span> f = <span class="built_in">shift</span>(-i) * v.<span class="built_in">inv</span>();</span><br><span class="line">        <span class="keyword">return</span> (f.<span class="built_in">log</span>(m - i * k) * k).<span class="built_in">exp</span>(m - i * k).<span class="built_in">shift</span>(i * k) * <span class="built_in">power</span>(v, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Poly <span class="title">sqrt</span><span class="params">(<span class="type">int</span> m)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Poly x&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; m) &#123;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">            x = (x + (<span class="built_in">trunc</span>(k) * x.<span class="built_in">inv</span>(k)).<span class="built_in">trunc</span>(k)) * CInv&lt;<span class="number">2</span>, P&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">trunc</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Poly <span class="title">mulT</span><span class="params">(Poly b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Poly</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = b.<span class="built_in">size</span>();</span><br><span class="line">        std::<span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ((*<span class="keyword">this</span>) * b).<span class="built_in">shift</span>(-(n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> std::vector&lt;Value&gt; <span class="title">eval</span><span class="params">(std::vector&lt;Value&gt; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;Value&gt;(x.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = std::<span class="built_in">max</span>(x.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">size</span>());</span><br><span class="line">        <span class="function">std::vector&lt;Poly&gt; <span class="title">q</span><span class="params">(<span class="number">4</span> * n)</span></span>;</span><br><span class="line">        <span class="function">std::vector&lt;Value&gt; <span class="title">ans</span><span class="params">(x.size())</span></span>;</span><br><span class="line">        x.<span class="built_in">resize</span>(n);</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                q[p] = Poly&#123;<span class="number">1</span>, -x[l]&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line">                <span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line">                q[p] = q[<span class="number">2</span> * p] * q[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">const</span> Poly &amp;)&gt; work = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Poly &amp;num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l &lt; <span class="built_in">int</span>(ans.<span class="built_in">size</span>())) &#123;</span><br><span class="line">                    ans[l] = num[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">work</span>(<span class="number">2</span> * p, l, m, num.<span class="built_in">mulT</span>(q[<span class="number">2</span> * p + <span class="number">1</span>]).<span class="built_in">resize</span>(m - l));</span><br><span class="line">                <span class="built_in">work</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, num.<span class="built_in">mulT</span>(q[<span class="number">2</span> * p]).<span class="built_in">resize</span>(r - m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">work</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="built_in">mulT</span>(q[<span class="number">1</span>].<span class="built_in">inv</span>(n)));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> P </span>= <span class="number">998244353</span>&gt;</span><br><span class="line"><span class="function">Poly&lt;P&gt; <span class="title">berlekampMassey</span><span class="params">(<span class="type">const</span> Poly&lt;P&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    Poly&lt;P&gt; c;</span><br><span class="line">    Poly&lt;P&gt; oldC;</span><br><span class="line">    <span class="type">int</span> f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> delta = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            delta -= c[j - <span class="number">1</span>] * s[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">-1</span>) &#123;</span><br><span class="line">            c.<span class="built_in">resize</span>(i + <span class="number">1</span>);</span><br><span class="line">            f = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> d = oldC;</span><br><span class="line">            d *= <span class="number">-1</span>;</span><br><span class="line">            d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">            MInt&lt;P&gt; df1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= d.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                df1 += d[j - <span class="number">1</span>] * s[f + <span class="number">1</span> - j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert</span>(df1 != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">auto</span> coef = delta / df1;</span><br><span class="line">            d *= coef;</span><br><span class="line">            <span class="function">Poly&lt;P&gt; <span class="title">zeros</span><span class="params">(i - f - <span class="number">1</span>)</span></span>;</span><br><span class="line">            zeros.<span class="built_in">insert</span>(zeros.<span class="built_in">end</span>(), d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">            d = zeros;</span><br><span class="line">            <span class="keyword">auto</span> temp = c;</span><br><span class="line">            c += d;</span><br><span class="line">            <span class="keyword">if</span> (i - temp.<span class="built_in">size</span>() &gt; f - oldC.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                oldC = temp;</span><br><span class="line">                f = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c *= <span class="number">-1</span>;</span><br><span class="line">    c.<span class="built_in">insert</span>(c.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> P </span>= <span class="number">998244353</span>&gt;</span><br><span class="line"><span class="function">MInt&lt;P&gt; <span class="title">linearRecurrence</span><span class="params">(Poly&lt;P&gt; p, Poly&lt;P&gt; q, i64 n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = q.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> newq = q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i += <span class="number">2</span>) &#123;</span><br><span class="line">            newq[i] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> newp = p * newq;</span><br><span class="line">        newq = q * newq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            p[i] = newp[i * <span class="number">2</span> + n % <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            q[i] = newq[i * <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">0</span>] / q[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Comb</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Z&gt; _fac;</span><br><span class="line">    std::vector&lt;Z&gt; _invfac;</span><br><span class="line">    std::vector&lt;Z&gt; _inv;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Comb</span>() : n&#123;<span class="number">0</span>&#125;, _fac&#123;<span class="number">1</span>&#125;, _invfac&#123;<span class="number">1</span>&#125;, _inv&#123;<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">Comb</span>(<span class="type">int</span> n) : <span class="built_in">Comb</span>() &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        m = std::<span class="built_in">min</span>(m, Z::<span class="built_in">getMod</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= n) <span class="keyword">return</span>;</span><br><span class="line">        _fac.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">        _invfac.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">        _inv.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            _fac[i] = _fac[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        _invfac[m] = _fac[m].<span class="built_in">inv</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt; n; i--) &#123;</span><br><span class="line">            _invfac[i - <span class="number">1</span>] = _invfac[i] * i;</span><br><span class="line">            _inv[i] = _invfac[i] * _fac[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        n = m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Z <span class="title">fac</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="built_in">init</span>(<span class="number">2</span> * m);</span><br><span class="line">        <span class="keyword">return</span> _fac[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">invfac</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="built_in">init</span>(<span class="number">2</span> * m);</span><br><span class="line">        <span class="keyword">return</span> _invfac[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="built_in">init</span>(<span class="number">2</span> * m);</span><br><span class="line">        <span class="keyword">return</span> _inv[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">binom</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fac</span>(n) * <span class="built_in">invfac</span>(m) * <span class="built_in">invfac</span>(n - m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; comb;</span><br><span class="line"></span><br><span class="line"><span class="function">Poly&lt;P&gt; <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Poly</span>(n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> f = <span class="built_in">get</span>(n, m - <span class="number">1</span>);</span><br><span class="line">        Z p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f[n - i] += comb.<span class="built_in">binom</span>(n, i) * p;</span><br><span class="line">            p *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">get</span>(n, m / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> fm = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fm[i] *= comb.<span class="built_in">fac</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">pw</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pw[i] = pw[i - <span class="number">1</span>] * (m / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pw[i] *= comb.<span class="built_in">invfac</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    fm = fm.<span class="built_in">mulT</span>(pw);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fm[i] *= comb.<span class="built_in">invfac</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f + fm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>四、数据结构</h1><h2 id="01A-树状数组（Fenwick-旧版）">01A - 树状数组（Fenwick 旧版）</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=63382128">2023-08-11</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        a.<span class="built_in">assign</span>(n, <span class="built_in">T</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x + <span class="number">1</span>; i &lt;= n; i += i &amp; -i) &#123;</span><br><span class="line">            a[i - <span class="number">1</span>] += v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">T</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">            ans += a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(T k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; std::__lg(n); i; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + i &lt;= n &amp;&amp; k &gt;= a[x + i - <span class="number">1</span>]) &#123;</span><br><span class="line">                x += i;</span><br><span class="line">                k -= a[x - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="01B-树状数组（Fenwick-新版）">01B - 树状数组（Fenwick 新版）</h2><p><a href="https://codeforces.com/contest/1915/submission/239262801">2023-12-28</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n_ = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_)</span> </span>&#123;</span><br><span class="line">        n = n_;</span><br><span class="line">        a.<span class="built_in">assign</span>(n, T&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x + <span class="number">1</span>; i &lt;= n; i += i &amp; -i) &#123;</span><br><span class="line">            a[i - <span class="number">1</span>] = a[i - <span class="number">1</span>] + v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        T ans&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">            ans = ans + a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">const</span> T &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        T cur&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; std::__lg(n); i; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + i &lt;= n &amp;&amp; cur + a[x + i - <span class="number">1</span>] &lt;= k) &#123;</span><br><span class="line">                x += i;</span><br><span class="line">                cur = cur + a[x - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="02-并查集（DSU）">02 - 并查集（DSU）</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=63239142">2023-08-04</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="03A-线段树（SegmentTree-基础区间加乘）">03A - 线段树（SegmentTree 基础区间加乘）</h2><p><a href="https://cf.dianhsu.com/gym/104417/submission/223800089">2023-10-18</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tag, sum;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> n_) : <span class="built_in">n</span>(n_), <span class="built_in">tag</span>(<span class="number">4</span> * n, <span class="number">1</span>), <span class="built_in">sum</span>(<span class="number">4</span> * n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        sum[p] = (sum[<span class="number">2</span> * p] + sum[<span class="number">2</span> * p + <span class="number">1</span>]) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        tag[p] = <span class="number">1LL</span> * tag[p] * v % P;</span><br><span class="line">        sum[p] = <span class="number">1LL</span> * sum[p] * v % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">mul</span>(<span class="number">2</span> * p, tag[p]);</span><br><span class="line">        <span class="built_in">mul</span>(<span class="number">2</span> * p + <span class="number">1</span>, tag[p]);</span><br><span class="line">        tag[p] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">query</span>(<span class="number">2</span> * p, l, m, x, y) + <span class="built_in">query</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y)) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeMul</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">mul</span>(p, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">rangeMul</span>(<span class="number">2</span> * p, l, m, x, y, v);</span><br><span class="line">        <span class="built_in">rangeMul</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, v);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeMul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">rangeMul</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            sum[p] = (sum[p] + v) % P;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">2</span> * p, l, m, x, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="03B-线段树（SegmentTree-Info-查找前驱后继）">03B - 线段树（SegmentTree+Info 查找前驱后继）</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=63382128">2023-08-11</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    <span class="built_in">SegmentTree</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> n_, Info v_ = <span class="built_in">Info</span>()) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_, v_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SegmentTree</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(init_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, Info v_ = Info())</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>(n_, v_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">        n = init_.<span class="built_in">size</span>();</span><br><span class="line">        info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; std::__lg(n), <span class="built_in">Info</span>());</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                info[p] = init_[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[<span class="number">2</span> * p] + info[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p, l, m, x, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p, l, m, x, y) + <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x || !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findFirst</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x || !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findLast</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findLast</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findLast</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    i64 sum = <span class="number">0</span>;</span><br><span class="line">    i64 ans = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line">    Info c;</span><br><span class="line">    c.cnt = a.cnt + b.cnt;</span><br><span class="line">    c.sum = a.sum + b.sum;</span><br><span class="line">    c.ans = a.ans + b.ans + a.cnt * b.sum - a.sum * b.cnt;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="03C-线段树（SegmentTree-Info-Merge-区间合并）">03C - 线段树（SegmentTree+Info+Merge 区间合并）</h2><p><a href="https://codeforces.com/contest/1672/submission/154766851">2022-04-23</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    <span class="built_in">SegmentTree</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> n_, Info v_ = <span class="built_in">Info</span>()) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_, v_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SegmentTree</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(init_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, Info v_ = Info())</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>(n_, v_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">        n = init_.<span class="built_in">size</span>();</span><br><span class="line">        info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; std::__lg(n), <span class="built_in">Info</span>());</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                info[p] = init_[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[<span class="number">2</span> * p] + info[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p, l, m, x, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p, l, m, x, y) + <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x || !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findFirst</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x || !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findLast</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findLast</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findLast</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x == b.x) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;a.x, a.cnt + b.cnt&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.cnt &gt; b.cnt) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;a.x, a.cnt - b.cnt&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;b.x, b.cnt - a.cnt&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="04A-懒标记线段树（LazySegmentTree-基础区间修改）">04A - 懒标记线段树（LazySegmentTree 基础区间修改）</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=62804432">2023-07-17</a></p><p>长度过长，点击查看</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>, <span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LazySegmentTree</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    std::vector&lt;Tag&gt; tag;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">info</span>(<span class="number">4</span> &lt;&lt; std::__lg(n)), <span class="built_in">tag</span>(<span class="number">4</span> &lt;&lt; std::__lg(n)) &#123;&#125;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>(std::vector&lt;Info&gt; init) : <span class="built_in">LazySegmentTree</span>(init.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                info[p] = init[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[<span class="number">2</span> * p] + info[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        info[p].<span class="built_in">apply</span>(v);</span><br><span class="line">        tag[p].<span class="built_in">apply</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">apply</span>(<span class="number">2</span> * p, tag[p]);</span><br><span class="line">        <span class="built_in">apply</span>(<span class="number">2</span> * p + <span class="number">1</span>, tag[p]);</span><br><span class="line">        tag[p] = <span class="built_in">Tag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p, l, m, x, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p, l, m, x, y) + <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeApply</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(p, v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">rangeApply</span>(<span class="number">2</span> * p, l, m, x, y, v);</span><br><span class="line">        <span class="built_in">rangeApply</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, v);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeApply</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeApply</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">half</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (info[p].act == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((info[p].min + <span class="number">1</span>) / <span class="number">2</span> == (info[p].max + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(p, &#123;-(info[p].min + <span class="number">1</span>) / <span class="number">2</span>&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">half</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line">        <span class="built_in">half</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">half</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">half</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> i64 inf = <span class="number">1E18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    i64 add = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Tag t)</span> </span>&#123;</span><br><span class="line">        add += t.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    i64 min = inf;</span><br><span class="line">    i64 max = -inf;</span><br><span class="line">    i64 sum = <span class="number">0</span>;</span><br><span class="line">    i64 act = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Tag t)</span> </span>&#123;</span><br><span class="line">        min += t.add;</span><br><span class="line">        max += t.add;</span><br><span class="line">        sum += act * t.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line">    Info c;</span><br><span class="line">    c.min = std::<span class="built_in">min</span>(a.min, b.min);</span><br><span class="line">    c.max = std::<span class="built_in">max</span>(a.max, b.max);</span><br><span class="line">    c.sum = a.sum + b.sum;</span><br><span class="line">    c.act = a.act + b.act;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="04B-懒标记线段树（LazySegmentTree-查找前驱后继）">04B - 懒标记线段树（LazySegmentTree 查找前驱后继）</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=62804432">2023-07-17</a></p><p>长度过长，点击查看</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>, <span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LazySegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    std::vector&lt;Tag&gt; tag;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>(<span class="type">int</span> n_, Info v_ = <span class="built_in">Info</span>()) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_, v_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">LazySegmentTree</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(init_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, Info v_ = Info())</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>(n_, v_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">        n = init_.<span class="built_in">size</span>();</span><br><span class="line">        info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; std::__lg(n), <span class="built_in">Info</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; std::__lg(n), <span class="built_in">Tag</span>());</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                info[p] = init_[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[<span class="number">2</span> * p] + info[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        info[p].<span class="built_in">apply</span>(v);</span><br><span class="line">        tag[p].<span class="built_in">apply</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">apply</span>(<span class="number">2</span> * p, tag[p]);</span><br><span class="line">        <span class="built_in">apply</span>(<span class="number">2</span> * p + <span class="number">1</span>, tag[p]);</span><br><span class="line">        tag[p] = <span class="built_in">Tag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p, l, m, x, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p, l, m, x, y) + <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeApply</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(p, v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">rangeApply</span>(<span class="number">2</span> * p, l, m, x, y, v);</span><br><span class="line">        <span class="built_in">rangeApply</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, v);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeApply</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeApply</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x || !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findFirst</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x || !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findLast</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findLast</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findLast</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    i64 a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Tag t)</span> </span>&#123;</span><br><span class="line">        a = std::<span class="built_in">min</span>(a, b + t.a);</span><br><span class="line">        b += t.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    i64 x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Tag t)</span> </span>&#123;</span><br><span class="line">        x += t.a;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = (x % k + k) % k;</span><br><span class="line">        &#125;</span><br><span class="line">        x += t.b - t.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a.x + b.x&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="04C-懒标记线段树（LazySegmentTree-二分修改）">04C - 懒标记线段树（LazySegmentTree 二分修改）</h2><p><a href="https://atcoder.jp/contests/joi2023yo2/submissions/39363123">2023-03-03</a></p><p>长度过长，点击查看</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf = <span class="number">1E9</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>, <span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LazySegmentTree</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    std::vector&lt;Tag&gt; tag;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">info</span>(<span class="number">4</span> &lt;&lt; std::__lg(n)), <span class="built_in">tag</span>(<span class="number">4</span> &lt;&lt; std::__lg(n)) &#123;&#125;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>(std::vector&lt;Info&gt; init) : <span class="built_in">LazySegmentTree</span>(init.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                info[p] = init[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[<span class="number">2</span> * p] + info[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        info[p].<span class="built_in">apply</span>(v);</span><br><span class="line">        tag[p].<span class="built_in">apply</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">apply</span>(<span class="number">2</span> * p, tag[p]);</span><br><span class="line">        <span class="built_in">apply</span>(<span class="number">2</span> * p + <span class="number">1</span>, tag[p]);</span><br><span class="line">        tag[p] = <span class="built_in">Tag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p, l, m, x, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p, l, m, x, y) + <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeApply</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(p, v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">rangeApply</span>(<span class="number">2</span> * p, l, m, x, y, v);</span><br><span class="line">        <span class="built_in">rangeApply</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, v);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeApply</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeApply</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maintainL</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (info[p].difl &gt; <span class="number">0</span> &amp;&amp; info[p].maxlowl &lt; pre) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p].max = info[p].maxlowl;</span><br><span class="line">            info[p].maxl = info[p].maxr = l;</span><br><span class="line">            info[p].maxlowl = info[p].maxlowr = -inf;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">maintainL</span>(<span class="number">2</span> * p, l, m, pre);</span><br><span class="line">        pre = std::<span class="built_in">max</span>(pre, info[<span class="number">2</span> * p].max);</span><br><span class="line">        <span class="built_in">maintainL</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, pre);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maintainL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maintainL</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maintainR</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> suf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (info[p].difr &gt; <span class="number">0</span> &amp;&amp; info[p].maxlowr &lt; suf) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p].max = info[p].maxlowl;</span><br><span class="line">            info[p].maxl = info[p].maxr = l;</span><br><span class="line">            info[p].maxlowl = info[p].maxlowr = -inf;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">maintainR</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, suf);</span><br><span class="line">        suf = std::<span class="built_in">max</span>(suf, info[<span class="number">2</span> * p + <span class="number">1</span>].max);</span><br><span class="line">        <span class="built_in">maintainR</span>(<span class="number">2</span> * p, l, m, suf);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maintainR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maintainR</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Tag t)</span> &amp; </span>&#123;</span><br><span class="line">        add += t.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> maxl = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> maxr = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> difl = inf;</span><br><span class="line">    <span class="type">int</span> difr = inf;</span><br><span class="line">    <span class="type">int</span> maxlowl = -inf;</span><br><span class="line">    <span class="type">int</span> maxlowr = -inf;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Tag t)</span> &amp; </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="number">-1</span>) &#123;</span><br><span class="line">            max += t.add;</span><br><span class="line">        &#125;</span><br><span class="line">        difl += t.add;</span><br><span class="line">        difr += t.add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line">    Info c;</span><br><span class="line">    <span class="keyword">if</span> (a.max &gt; b.max) &#123;</span><br><span class="line">        c.max = a.max;</span><br><span class="line">        c.maxl = a.maxl;</span><br><span class="line">        c.maxr = a.maxr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.max &lt; b.max) &#123;</span><br><span class="line">        c.max = b.max;</span><br><span class="line">        c.maxl = b.maxl;</span><br><span class="line">        c.maxr = b.maxr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c.max = a.max;</span><br><span class="line">        c.maxl = a.maxl;</span><br><span class="line">        c.maxr = b.maxr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    c.difl = std::<span class="built_in">min</span>(a.difl, b.difl);</span><br><span class="line">    c.difr = std::<span class="built_in">min</span>(a.difr, b.difr);</span><br><span class="line">    <span class="keyword">if</span> (a.max != <span class="number">-1</span>) &#123;</span><br><span class="line">        c.difl = std::<span class="built_in">min</span>(c.difl, a.max - b.maxlowl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b.max != <span class="number">-1</span>) &#123;</span><br><span class="line">        c.difr = std::<span class="built_in">min</span>(c.difr, b.max - a.maxlowr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a.max == <span class="number">-1</span>) &#123;</span><br><span class="line">        c.maxlowl = std::<span class="built_in">max</span>(a.maxlowl, b.maxlowl);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c.maxlowl = a.maxlowl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b.max == <span class="number">-1</span>) &#123;</span><br><span class="line">        c.maxlowr = std::<span class="built_in">max</span>(a.maxlowr, b.maxlowr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c.maxlowr = b.maxlowr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="05A-取模类（MLong-MInt）">05A - 取模类（MLong &amp; MInt）</h2><p><a href="https://codeforces.com/contest/1697/submission/160317720">2022-06-12</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="comment">// assume -P &lt;= x &lt; 2P</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">norm</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= P) &#123;</span><br><span class="line">        x -= P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T a, i64 b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Z</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">Z</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x)) &#123;&#125;</span><br><span class="line">    <span class="built_in">Z</span>(i64 x) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x % P)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    Z <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">norm</span>(P - x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, P - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">i64</span>(x) * rhs.x % P;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>/=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>*(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>+(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>-(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>/(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Z &amp;a) &#123;</span><br><span class="line">        i64 v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">Z</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> Z &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="05B-取模类（MLong-MInt-新版）">05B - 取模类（MLong &amp; MInt 新版）</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=63433564">2023-08-14</a></p><p>根据输入内容动态修改 MOD 的方法：<code>Z::setMod(p);</code> 。</p><p>长度过长，点击查看</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">power</span><span class="params">(T a, i64 b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> i64 <span class="title">mul</span><span class="params">(i64 a, i64 b, i64 p)</span> </span>&#123;</span><br><span class="line">    i64 res = a * b - <span class="built_in">i64</span>(<span class="number">1.L</span> * a * b / p) * p;</span><br><span class="line">    res %= p;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;i64 P&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MLong</span> &#123;</span><br><span class="line">    i64 x;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MLong</span><span class="params">()</span> : x&#123;</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MLong</span><span class="params">(i64 x)</span> : x&#123;</span><span class="built_in">norm</span>(x % <span class="built_in">getMod</span>())&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> i64 Mod;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> i64 <span class="title">getMod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> P;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">void</span> <span class="title">setMod</span><span class="params">(i64 Mod_)</span> </span>&#123;</span><br><span class="line">        Mod = Mod_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">norm</span><span class="params">(i64 x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x += <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="built_in">getMod</span>()) &#123;</span><br><span class="line">            x -= <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">i64</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        MLong res;</span><br><span class="line">        res.x = <span class="built_in">norm</span>(<span class="built_in">getMod</span>() - x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MLong <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, <span class="built_in">getMod</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>*=(MLong rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">mul</span>(x, rhs.x, <span class="built_in">getMod</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>+=(MLong rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>-=(MLong rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>/=(MLong rhs) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>*(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>+(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>-(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>/(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, MLong &amp;a) &#123;</span><br><span class="line">        i64 v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">MLong</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> MLong &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>==(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() == rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() != rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">i64 MLong&lt;<span class="number">0LL</span>&gt;::Mod = <span class="built_in">i64</span>(<span class="number">1E18</span>) + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> P&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MInt</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">()</span> : x&#123;</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">(i64 x)</span> : x&#123;</span><span class="built_in">norm</span>(x % <span class="built_in">getMod</span>())&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> Mod;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> <span class="title">getMod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> P;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">void</span> <span class="title">setMod</span><span class="params">(<span class="type">int</span> Mod_)</span> </span>&#123;</span><br><span class="line">        Mod = Mod_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">norm</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x += <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="built_in">getMod</span>()) &#123;</span><br><span class="line">            x -= <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        MInt res;</span><br><span class="line">        res.x = <span class="built_in">norm</span>(<span class="built_in">getMod</span>() - x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, <span class="built_in">getMod</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>*=(MInt rhs) &amp; &#123;</span><br><span class="line">        x = <span class="number">1LL</span> * x * rhs.x % <span class="built_in">getMod</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>+=(MInt rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>-=(MInt rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>/=(MInt rhs) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>*(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>+(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>/(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, MInt &amp;a) &#123;</span><br><span class="line">        i64 v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">MInt</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> MInt &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>==(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() == rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() != rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">int</span> MInt&lt;<span class="number">0</span>&gt;::Mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> V, <span class="type">int</span> P&gt;</span><br><span class="line"><span class="keyword">constexpr</span> MInt&lt;P&gt; CInv = <span class="built_in">MInt</span>&lt;P&gt;(V).<span class="built_in">inv</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> P = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">using</span> Z = MInt&lt;P&gt;;</span><br></pre></td></tr></table></figure><h2 id="06-状压RMQ（RMQ）">06 - 状压RMQ（RMQ）</h2><p><a href="https://atcoder.jp/contests/joi2022ho/submissions/39351739">2023-03-02</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cmp</span> = std::less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> RMQ &#123;</span><br><span class="line">    <span class="type">const</span> Cmp cmp = <span class="built_in">Cmp</span>();</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> B = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;std::vector&lt;T&gt;&gt; a;</span><br><span class="line">    std::vector&lt;T&gt; pre, suf, ini;</span><br><span class="line">    std::vector&lt;u64&gt; stk;</span><br><span class="line">    <span class="built_in">RMQ</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">RMQ</span>(<span class="type">const</span> std::vector&lt;T&gt; &amp;v) &#123;</span><br><span class="line">        <span class="built_in">init</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        n = v.<span class="built_in">size</span>();</span><br><span class="line">        pre = suf = ini = v;</span><br><span class="line">        stk.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> M = (n - <span class="number">1</span>) / B + <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> lg = std::__lg(M);</span><br><span class="line">        a.<span class="built_in">assign</span>(lg + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;T&gt;(M));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            a[<span class="number">0</span>][i] = v[i * B];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; B &amp;&amp; i * B + j &lt; n; j++) &#123;</span><br><span class="line">                a[<span class="number">0</span>][i] = std::<span class="built_in">min</span>(a[<span class="number">0</span>][i], v[i * B + j], cmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % B) &#123;</span><br><span class="line">                pre[i] = std::<span class="built_in">min</span>(pre[i], pre[i - <span class="number">1</span>], cmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % B != B - <span class="number">1</span>) &#123;</span><br><span class="line">                suf[i] = std::<span class="built_in">min</span>(suf[i], suf[i + <span class="number">1</span>], cmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lg; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + (<span class="number">2</span> &lt;&lt; j) &lt;= M; i++) &#123;</span><br><span class="line">                a[j + <span class="number">1</span>][i] = std::<span class="built_in">min</span>(a[j][i], a[j][i + (<span class="number">1</span> &lt;&lt; j)], cmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> l = i * B;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r = std::<span class="built_in">min</span>(<span class="number">1U</span> * n, l + B);</span><br><span class="line">            u64 s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; r; j++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (s &amp;&amp; <span class="built_in">cmp</span>(v[j], v[std::__lg(s) + l])) &#123;</span><br><span class="line">                    s ^= <span class="number">1ULL</span> &lt;&lt; std::__lg(s);</span><br><span class="line">                &#125;</span><br><span class="line">                s |= <span class="number">1ULL</span> &lt;&lt; (j - l);</span><br><span class="line">                stk[j] = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l / B != (r - <span class="number">1</span>) / B) &#123;</span><br><span class="line">            T ans = std::<span class="built_in">min</span>(suf[l], pre[r - <span class="number">1</span>], cmp);</span><br><span class="line">            l = l / B + <span class="number">1</span>;</span><br><span class="line">            r = r / B;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> k = std::__lg(r - l);</span><br><span class="line">                ans = std::<span class="built_in">min</span>(&#123;ans, a[k][l], a[k][r - (<span class="number">1</span> &lt;&lt; k)]&#125;, cmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> x = B * (l / B);</span><br><span class="line">            <span class="keyword">return</span> ini[__builtin_ctzll(stk[r - <span class="number">1</span>] &gt;&gt; (l - x)) + l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="07-Splay">07 - Splay</h2><p><a href="https://atcoder.jp/contests/joi2023ho/submissions/38901674">2023-02-15</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node *l = <span class="literal">nullptr</span>;</span><br><span class="line">    Node *r = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    i64 sum = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">add</span><span class="params">(Node *t, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    Node *x = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        *x = *t;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;cnt += <span class="number">1</span>;</span><br><span class="line">    x-&gt;sum += v;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; m) &#123;</span><br><span class="line">        x-&gt;l = <span class="built_in">add</span>(x-&gt;l, l, m, p, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;r = <span class="built_in">add</span>(x-&gt;r, m, r, p, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(Node *tl, Node *tr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = (tr ? tr-&gt;cnt : <span class="number">0</span>) - (tl ? tl-&gt;cnt : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">find</span>(tl ? tl-&gt;l : tl, tr ? tr-&gt;l : tr, l, m, x);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        res = <span class="built_in">find</span>(tl ? tl-&gt;r : tl, tr ? tr-&gt;r : tr, m, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, i64&gt; <span class="title">get</span><span class="params">(Node *t, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= y || r &lt;= x || !t) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0LL</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;t-&gt;cnt, t-&gt;sum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> [cl, sl] = <span class="built_in">get</span>(t-&gt;l, l, m, x, y);</span><br><span class="line">    <span class="keyword">auto</span> [cr, sr] = <span class="built_in">get</span>(t-&gt;r, m, r, x, y);</span><br><span class="line">    <span class="keyword">return</span> &#123;cl + cr, sl + sr&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    Tree *ch[<span class="number">2</span>] = &#123;&#125;;</span><br><span class="line">    Tree *p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pos</span><span class="params">(Tree *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t-&gt;p-&gt;ch[<span class="number">1</span>] == t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Tree *t, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    t-&gt;val += v;</span><br><span class="line">    t-&gt;add += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Tree *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;ch[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">add</span>(t-&gt;ch[<span class="number">0</span>], t-&gt;add);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;ch[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">add</span>(t-&gt;ch[<span class="number">1</span>], t-&gt;add);</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(Tree *t)</span> </span>&#123;</span><br><span class="line">    Tree *q = t-&gt;p;</span><br><span class="line">    <span class="type">int</span> x = !<span class="built_in">pos</span>(t);</span><br><span class="line">    q-&gt;ch[!x] = t-&gt;ch[x];</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;ch[x]) t-&gt;ch[x]-&gt;p = q;</span><br><span class="line">    t-&gt;p = q-&gt;p;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;p) q-&gt;p-&gt;ch[<span class="built_in">pos</span>(q)] = t;</span><br><span class="line">    t-&gt;ch[x] = q;</span><br><span class="line">    q-&gt;p = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(Tree *t)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Tree *&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (Tree *i = t; i-&gt;p; i = i-&gt;p) s.<span class="built_in">push_back</span>(i-&gt;p);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">push</span>(s.<span class="built_in">back</span>());</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (t-&gt;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;p-&gt;p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pos</span>(t) == <span class="built_in">pos</span>(t-&gt;p)) <span class="built_in">rotate</span>(t-&gt;p);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Tree *&amp;t, Tree *x, Tree *p = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">        t = x;</span><br><span class="line">        x-&gt;p = p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">push</span>(t);</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;val &lt; t-&gt;val) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(t-&gt;ch[<span class="number">0</span>], x, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">insert</span>(t-&gt;ch[<span class="number">1</span>], x, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Tree *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push</span>(t);</span><br><span class="line">    <span class="built_in">dfs</span>(t-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">    std::cerr &lt;&lt; t-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(t-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;Tree *, Tree *&gt; <span class="title">split</span><span class="params">(Tree *t, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;t, t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree *v = <span class="literal">nullptr</span>;</span><br><span class="line">    Tree *j = t;</span><br><span class="line">    <span class="keyword">for</span> (Tree *i = t; i; ) &#123;</span><br><span class="line">        <span class="built_in">push</span>(i);</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">if</span> (i-&gt;val &gt;= x) &#123;</span><br><span class="line">            v = i;</span><br><span class="line">            i = i-&gt;ch[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i-&gt;ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">splay</span>(j);</span><br><span class="line">    <span class="keyword">if</span> (!v) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;j, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">splay</span>(v);</span><br><span class="line">    </span><br><span class="line">    Tree *u = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (u) &#123;</span><br><span class="line">        v-&gt;ch[<span class="number">0</span>] = u-&gt;p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cerr &lt;&lt; &quot;split &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// dfs(u);</span></span><br><span class="line">    <span class="comment">// std::cerr &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// dfs(v);</span></span><br><span class="line">    <span class="comment">// std::cerr &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;u, v&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">merge</span><span class="params">(Tree *l, Tree *r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l) &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree *i = l;</span><br><span class="line">    <span class="keyword">while</span> (i-&gt;ch[<span class="number">1</span>]) &#123;</span><br><span class="line">        i = i-&gt;ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(i);</span><br><span class="line">    i-&gt;ch[<span class="number">1</span>] = r;</span><br><span class="line">    r-&gt;p = i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cf.dianhsu.com/gym/104479/submission/221036520">2023-09-30</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node *ch[<span class="number">2</span>], *p;</span><br><span class="line">    <span class="type">bool</span> rev;</span><br><span class="line">    <span class="type">int</span> siz = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Node</span>() : ch&#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;, <span class="built_in">p</span>(<span class="literal">nullptr</span>), <span class="built_in">rev</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(t-&gt;ch[<span class="number">0</span>], t-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">        t-&gt;rev ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;rev) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(t-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">reverse</span>(t-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">        t-&gt;rev = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    t-&gt;siz = (t-&gt;ch[<span class="number">0</span>] ? t-&gt;ch[<span class="number">0</span>]-&gt;siz : <span class="number">0</span>) + <span class="number">1</span> + (t-&gt;ch[<span class="number">1</span>] ? t-&gt;ch[<span class="number">1</span>]-&gt;siz : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isroot</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t-&gt;p == <span class="literal">nullptr</span> || (t-&gt;p-&gt;ch[<span class="number">0</span>] != t &amp;&amp; t-&gt;p-&gt;ch[<span class="number">1</span>] != t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pos</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t-&gt;p-&gt;ch[<span class="number">1</span>] == t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushAll</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isroot</span>(t)) &#123;</span><br><span class="line">        <span class="built_in">pushAll</span>(t-&gt;p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    Node *q = t-&gt;p;</span><br><span class="line">    <span class="type">int</span> x = !<span class="built_in">pos</span>(t);</span><br><span class="line">    q-&gt;ch[!x] = t-&gt;ch[x];</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;ch[x]) &#123;</span><br><span class="line">        t-&gt;ch[x]-&gt;p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;p = q-&gt;p;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isroot</span>(q)) &#123;</span><br><span class="line">        q-&gt;p-&gt;ch[<span class="built_in">pos</span>(q)] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;ch[x] = q;</span><br><span class="line">    q-&gt;p = t;</span><br><span class="line">    <span class="built_in">pull</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pushAll</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isroot</span>(t)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(t-&gt;p)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pos</span>(t) == <span class="built_in">pos</span>(t-&gt;p)) &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(t-&gt;p);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pull</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node *i = t, *q = <span class="literal">nullptr</span>; i; q = i, i = i-&gt;p) &#123;</span><br><span class="line">        <span class="built_in">splay</span>(i);</span><br><span class="line">        i-&gt;ch[<span class="number">1</span>] = q;</span><br><span class="line">        <span class="built_in">pull</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeroot</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(t);</span><br><span class="line">    <span class="built_in">reverse</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(Node *x, Node *y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeroot</span>(x);</span><br><span class="line">    x-&gt;p = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(Node *x, Node *y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeroot</span>(x);</span><br><span class="line">    <span class="built_in">access</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(Node *x, Node *y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">split</span>(x, y);</span><br><span class="line">    x-&gt;p = y-&gt;ch[<span class="number">0</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">pull</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(Node *x, Node *y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">split</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> y-&gt;siz - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codeforces.com/contest/1942/submission/254202464">2024-03-30</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> : std::array&lt;std::array&lt;i64, 4&gt;, 4&gt; &#123;</span><br><span class="line">    <span class="built_in">Matrix</span>(i64 v = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                (*<span class="keyword">this</span>)[i][j] = (i == j ? v : inf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix &amp;a, <span class="type">const</span> Matrix &amp;b) &#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">c</span><span class="params">(inf)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                c[i][k] = std::<span class="built_in">min</span>(c[i][k], a[i][j] + b[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c[i][<span class="number">3</span>] = std::<span class="built_in">min</span>(c[i][<span class="number">3</span>], a[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    c[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node *ch[<span class="number">2</span>], *p;</span><br><span class="line">    i64 sumg = <span class="number">0</span>;</span><br><span class="line">    i64 sumh = <span class="number">0</span>;</span><br><span class="line">    i64 sumb = <span class="number">0</span>;</span><br><span class="line">    i64 g = <span class="number">0</span>;</span><br><span class="line">    i64 h = <span class="number">0</span>;</span><br><span class="line">    i64 b = <span class="number">0</span>;</span><br><span class="line">    Matrix mat;</span><br><span class="line">    Matrix prd;</span><br><span class="line">    std::array&lt;i64, 4&gt; ans&#123;&#125;;</span><br><span class="line">    <span class="built_in">Node</span>() : ch&#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;, <span class="built_in">p</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mat = <span class="built_in">Matrix</span>(inf);</span><br><span class="line">        mat[<span class="number">0</span>][<span class="number">0</span>] = b + h - g + sumg;</span><br><span class="line">        mat[<span class="number">1</span>][<span class="number">1</span>] = mat[<span class="number">1</span>][<span class="number">2</span>] = mat[<span class="number">1</span>][<span class="number">3</span>] = h + sumh;</span><br><span class="line">        mat[<span class="number">2</span>][<span class="number">0</span>] = mat[<span class="number">2</span>][<span class="number">1</span>] = mat[<span class="number">2</span>][<span class="number">2</span>] = mat[<span class="number">2</span>][<span class="number">3</span>] = b + h + sumb;</span><br><span class="line">        mat[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    t-&gt;prd = (t-&gt;ch[<span class="number">0</span>] ? t-&gt;ch[<span class="number">0</span>]-&gt;prd : <span class="built_in">Matrix</span>()) * t-&gt;mat * (t-&gt;ch[<span class="number">1</span>] ? t-&gt;ch[<span class="number">1</span>]-&gt;prd : <span class="built_in">Matrix</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isroot</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t-&gt;p == <span class="literal">nullptr</span> || (t-&gt;p-&gt;ch[<span class="number">0</span>] != t &amp;&amp; t-&gt;p-&gt;ch[<span class="number">1</span>] != t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pos</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t-&gt;p-&gt;ch[<span class="number">1</span>] == t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushAll</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isroot</span>(t)) &#123;</span><br><span class="line">        <span class="built_in">pushAll</span>(t-&gt;p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    Node *q = t-&gt;p;</span><br><span class="line">    <span class="type">int</span> x = !<span class="built_in">pos</span>(t);</span><br><span class="line">    q-&gt;ch[!x] = t-&gt;ch[x];</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;ch[x]) &#123;</span><br><span class="line">        t-&gt;ch[x]-&gt;p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;p = q-&gt;p;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isroot</span>(q)) &#123;</span><br><span class="line">        q-&gt;p-&gt;ch[<span class="built_in">pos</span>(q)] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;ch[x] = q;</span><br><span class="line">    q-&gt;p = t;</span><br><span class="line">    <span class="built_in">pull</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pushAll</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isroot</span>(t)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(t-&gt;p)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pos</span>(t) == <span class="built_in">pos</span>(t-&gt;p)) &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(t-&gt;p);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pull</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">std::array&lt;i64, 4&gt; <span class="title">get</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    std::array&lt;i64, 4&gt; ans;</span><br><span class="line">    ans.<span class="built_in">fill</span>(inf);</span><br><span class="line">    ans[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            ans[i] = std::<span class="built_in">min</span>(ans[i], t-&gt;prd[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    std::array&lt;i64, 4&gt; old&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (Node *i = t, *q = <span class="literal">nullptr</span>; i; q = i, i = i-&gt;p) &#123;</span><br><span class="line">        <span class="built_in">splay</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (i-&gt;ch[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> res = <span class="built_in">get</span>(i-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">            i-&gt;sumg += res[<span class="number">0</span>];</span><br><span class="line">            i-&gt;sumh += std::<span class="built_in">min</span>(&#123;res[<span class="number">1</span>], res[<span class="number">2</span>], res[<span class="number">3</span>]&#125;);</span><br><span class="line">            i-&gt;sumb += std::<span class="built_in">min</span>(&#123;res[<span class="number">0</span>], res[<span class="number">1</span>], res[<span class="number">2</span>], res[<span class="number">3</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        i-&gt;ch[<span class="number">1</span>] = q;</span><br><span class="line">        i-&gt;sumg -= old[<span class="number">0</span>];</span><br><span class="line">        i-&gt;sumh -= std::<span class="built_in">min</span>(&#123;old[<span class="number">1</span>], old[<span class="number">2</span>], old[<span class="number">3</span>]&#125;);</span><br><span class="line">        i-&gt;sumb -= std::<span class="built_in">min</span>(&#123;old[<span class="number">0</span>], old[<span class="number">1</span>], old[<span class="number">2</span>], old[<span class="number">3</span>]&#125;);</span><br><span class="line">        old = <span class="built_in">get</span>(i);</span><br><span class="line">        i-&gt;<span class="built_in">update</span>();</span><br><span class="line">        <span class="built_in">pull</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="08-其他平衡树">08 - 其他平衡树</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=63246177">2023-08-04</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node *l = <span class="literal">nullptr</span>;</span><br><span class="line">    Node *r = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sumodd = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Node</span>(Node *t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">            *<span class="keyword">this</span> = *t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">add</span><span class="params">(Node *t, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    t = <span class="keyword">new</span> <span class="built_in">Node</span>(t);</span><br><span class="line">    t-&gt;sum += v;</span><br><span class="line">    t-&gt;sumodd += (x % <span class="number">2</span>) * v;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">        t-&gt;l = <span class="built_in">add</span>(t-&gt;l, l, m, x, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t-&gt;r = <span class="built_in">add</span>(t-&gt;r, m, r, x, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query1</span><span class="params">(Node *t1, Node *t2, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> odd = (t1 &amp;&amp; t1-&gt;r ? t1-&gt;r-&gt;sumodd : <span class="number">0</span>) - (t2 &amp;&amp; t2-&gt;r ? t2-&gt;r-&gt;sumodd : <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> cnt = (t1 &amp;&amp; t1-&gt;r ? t1-&gt;r-&gt;sum : <span class="number">0</span>) - (t2 &amp;&amp; t2-&gt;r ? t2-&gt;r-&gt;sum : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (odd &gt; <span class="number">0</span> || cnt &gt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query1</span>(t1 ? t1-&gt;r : t1, t2 ? t2-&gt;r : t2, m, r, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query1</span>(t1 ? t1-&gt;l : t1, t2 ? t2-&gt;l : t2, l, m, k - cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::array&lt;<span class="type">int</span>, 3&gt; <span class="title">query2</span><span class="params">(Node *t1, Node *t2, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = (t1 ? t1-&gt;sumodd : <span class="number">0</span>) - (t2 ? t2-&gt;sumodd : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;l, cnt, k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> cnt = (t1 &amp;&amp; t1-&gt;r ? t1-&gt;r-&gt;sumodd : <span class="number">0</span>) - (t2 &amp;&amp; t2-&gt;r ? t2-&gt;r-&gt;sumodd : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query2</span>(t1 ? t1-&gt;r : t1, t2 ? t2-&gt;r : t2, m, r, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query2</span>(t1 ? t1-&gt;l : t1, t2 ? t2-&gt;l : t2, l, m, k - cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codeforces.com/contest/1864/submission/220558951">2023-08-26</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node *l = <span class="literal">nullptr</span>;</span><br><span class="line">    Node *r = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">add</span><span class="params">(Node *t, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="built_in">Node</span>(*t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t = <span class="keyword">new</span> Node;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">        t-&gt;l = <span class="built_in">add</span>(t-&gt;l, l, m, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t-&gt;r = <span class="built_in">add</span>(t-&gt;r, m, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node *t1, Node *t2, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = (t2 ? t2-&gt;cnt : <span class="number">0</span>) - (t1 ? t1-&gt;cnt : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span> || l &gt;= x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">query</span>(t1 ? t1-&gt;r : t1, t2 ? t2-&gt;r : t2, m, r, x);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        res = <span class="built_in">query</span>(t1 ? t1-&gt;l : t1, t2 ? t2-&gt;l : t2, l, m, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codeforces.com/contest/38/submission/200537139">2023-04-03</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> imp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;std::<span class="built_in">max</span>(a.imp, b.imp), <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> w = <span class="built_in">rng</span>();</span><br><span class="line">    Info info;</span><br><span class="line">    Info sum;</span><br><span class="line">    <span class="type">int</span> siz = <span class="number">1</span>;</span><br><span class="line">    Node *l = <span class="literal">nullptr</span>;</span><br><span class="line">    Node *r = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    t-&gt;sum = t-&gt;info;</span><br><span class="line">    t-&gt;siz = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;l) &#123;</span><br><span class="line">        t-&gt;sum = t-&gt;l-&gt;sum + t-&gt;sum;</span><br><span class="line">        t-&gt;siz += t-&gt;l-&gt;siz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;r) &#123;</span><br><span class="line">        t-&gt;sum = t-&gt;sum + t-&gt;r-&gt;sum;</span><br><span class="line">        t-&gt;siz += t-&gt;r-&gt;siz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;Node *, Node *&gt; <span class="title">splitAt</span><span class="params">(Node *t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;t, t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= (t-&gt;l ? t-&gt;l-&gt;siz : <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [l, r] = <span class="built_in">splitAt</span>(t-&gt;l, p);</span><br><span class="line">        t-&gt;l = r;</span><br><span class="line">        <span class="built_in">pull</span>(t);</span><br><span class="line">        <span class="keyword">return</span> &#123;l, t&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> [l, r] = <span class="built_in">splitAt</span>(t-&gt;r, p - <span class="number">1</span> - (t-&gt;l ? t-&gt;l-&gt;siz : <span class="number">0</span>));</span><br><span class="line">        t-&gt;r = l;</span><br><span class="line">        <span class="built_in">pull</span>(t);</span><br><span class="line">        <span class="keyword">return</span> &#123;t, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertAt</span><span class="params">(Node *&amp;t, <span class="type">int</span> p, Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">        t = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;w &lt; t-&gt;w) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [l, r] = <span class="built_in">splitAt</span>(t, p);</span><br><span class="line">        t = x;</span><br><span class="line">        t-&gt;l = l;</span><br><span class="line">        t-&gt;r = r;</span><br><span class="line">        <span class="built_in">pull</span>(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= (t-&gt;l ? t-&gt;l-&gt;siz : <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">insertAt</span>(t-&gt;l, p, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">insertAt</span>(t-&gt;r, p - <span class="number">1</span> - (t-&gt;l ? t-&gt;l-&gt;siz : <span class="number">0</span>), x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pull</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">merge</span><span class="params">(Node *a, Node *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a-&gt;w &lt; b-&gt;w) &#123;</span><br><span class="line">        a-&gt;r = <span class="built_in">merge</span>(a-&gt;r, b);</span><br><span class="line">        <span class="built_in">pull</span>(a);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b-&gt;l = <span class="built_in">merge</span>(a, b-&gt;l);</span><br><span class="line">        <span class="built_in">pull</span>(b);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node *t, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;sum.imp &lt; v) &#123;</span><br><span class="line">        <span class="keyword">return</span> t-&gt;siz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">query</span>(t-&gt;r, v);</span><br><span class="line">    <span class="keyword">if</span> (res != (t-&gt;r ? t-&gt;r-&gt;siz : <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;info.imp &gt; v) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span> + <span class="built_in">query</span>(t-&gt;l, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(t-&gt;l);</span><br><span class="line">    std::cout &lt;&lt; t-&gt;info.id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(t-&gt;r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=63162242">2023-07-31</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node *l = <span class="literal">nullptr</span>;</span><br><span class="line">    Node *r = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cntnew = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> isnew)</span> </span>&#123;</span><br><span class="line">    Node *t = <span class="keyword">new</span> Node;</span><br><span class="line">    t-&gt;cnt = <span class="number">1</span>;</span><br><span class="line">    t-&gt;cntnew = isnew;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">        t-&gt;l = <span class="built_in">add</span>(l, m, x, isnew);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t-&gt;r = <span class="built_in">add</span>(m, r, x, isnew);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    Node *t = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> psum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">    t-&gt;cnt = (t-&gt;l ? t-&gt;l-&gt;cnt : <span class="number">0</span>) + (t-&gt;r ? t-&gt;r-&gt;cnt : <span class="number">0</span>);</span><br><span class="line">    t-&gt;cntnew = (t-&gt;l ? t-&gt;l-&gt;cntnew : <span class="number">0</span>) + (t-&gt;r ? t-&gt;r-&gt;cntnew : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;Node *, Node *&gt; <span class="title">split</span><span class="params">(Node *t, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">bool</span> rev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;t, t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>, t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == t-&gt;cnt) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;t, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        Node *t2 = <span class="keyword">new</span> Node;</span><br><span class="line">        t2-&gt;cnt = t-&gt;cnt - x;</span><br><span class="line">        t-&gt;cnt = x;</span><br><span class="line">        <span class="keyword">return</span> &#123;t, t2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *t2 = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (!rev) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;l &amp;&amp; x &lt;= t-&gt;l-&gt;cnt) &#123;</span><br><span class="line">            std::<span class="built_in">tie</span>(t-&gt;l, t2-&gt;l) = <span class="built_in">split</span>(t-&gt;l, l, m, x, rev);</span><br><span class="line">            t2-&gt;r = t-&gt;r;</span><br><span class="line">            t-&gt;r = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::<span class="built_in">tie</span>(t-&gt;r, t2-&gt;r) = <span class="built_in">split</span>(t-&gt;r, m, r, x - (t-&gt;l ? t-&gt;l-&gt;cnt : <span class="number">0</span>), rev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;r &amp;&amp; x &lt;= t-&gt;r-&gt;cnt) &#123;</span><br><span class="line">            std::<span class="built_in">tie</span>(t-&gt;r, t2-&gt;r) = <span class="built_in">split</span>(t-&gt;r, m, r, x, rev);</span><br><span class="line">            t2-&gt;l = t-&gt;l;</span><br><span class="line">            t-&gt;l = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::<span class="built_in">tie</span>(t-&gt;l, t2-&gt;l) = <span class="built_in">split</span>(t-&gt;l, l, m, x - (t-&gt;r ? t-&gt;r-&gt;cnt : <span class="number">0</span>), rev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pull</span>(t);</span><br><span class="line">    <span class="built_in">pull</span>(t2);</span><br><span class="line">    <span class="keyword">return</span> &#123;t, t2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">merge</span><span class="params">(Node *t1, Node *t2, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t1) &#123;</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!t2) &#123;</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        t1-&gt;cnt += t2-&gt;cnt;</span><br><span class="line">        t1-&gt;cntnew += t2-&gt;cntnew;</span><br><span class="line">        <span class="keyword">delete</span> t2;</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    t1-&gt;l = <span class="built_in">merge</span>(t1-&gt;l, t2-&gt;l, l, m);</span><br><span class="line">    t1-&gt;r = <span class="built_in">merge</span>(t1-&gt;r, t2-&gt;r, m, r);</span><br><span class="line">    <span class="keyword">delete</span> t2;</span><br><span class="line">    <span class="built_in">pull</span>(t1);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="09-分数四则运算（Frac）">09 - 分数四则运算（Frac）</h2><p><a href="https://codeforces.com/contest/598/submission/203186397">2023-04-23</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Frac</span> &#123;</span><br><span class="line">    T num;</span><br><span class="line">    T den;</span><br><span class="line">    <span class="built_in">Frac</span>(T num_, T den_) : <span class="built_in">num</span>(num_), <span class="built_in">den</span>(den_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (den &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            den = -den;</span><br><span class="line">            num = -num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Frac</span>() : <span class="built_in">Frac</span>(<span class="number">0</span>, <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Frac</span>(T num_) : <span class="built_in">Frac</span>(num_, <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.</span> * num / den;</span><br><span class="line">    &#125;</span><br><span class="line">    Frac &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        num = num * rhs.den + rhs.num * den;</span><br><span class="line">        den *= rhs.den;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Frac &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        num = num * rhs.den - rhs.num * den;</span><br><span class="line">        den *= rhs.den;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Frac &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        num *= rhs.num;</span><br><span class="line">        den *= rhs.den;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Frac &amp;<span class="keyword">operator</span>/=(<span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        num *= rhs.den;</span><br><span class="line">        den *= rhs.num;</span><br><span class="line">        <span class="keyword">if</span> (den &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            num = -num;</span><br><span class="line">            den = -den;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Frac <span class="keyword">operator</span>+(Frac lhs, <span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs += rhs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Frac <span class="keyword">operator</span>-(Frac lhs, <span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs -= rhs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Frac <span class="keyword">operator</span>*(Frac lhs, <span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs *= rhs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Frac <span class="keyword">operator</span>/(Frac lhs, <span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs /= rhs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Frac <span class="keyword">operator</span>-(<span class="type">const</span> Frac &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Frac</span>(-a.num, a.den);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Frac &amp;lhs, <span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.num * rhs.den == rhs.num * lhs.den;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Frac &amp;lhs, <span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.num * rhs.den != rhs.num * lhs.den;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Frac &amp;lhs, <span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.num * rhs.den &lt; rhs.num * lhs.den;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Frac &amp;lhs, <span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.num * rhs.den &gt; rhs.num * lhs.den;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Frac &amp;lhs, <span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.num * rhs.den &lt;= rhs.num * lhs.den;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Frac &amp;lhs, <span class="type">const</span> Frac &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.num * rhs.den &gt;= rhs.num * lhs.den;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, Frac x) &#123;</span><br><span class="line">        T g = std::<span class="built_in">gcd</span>(x.num, x.den);</span><br><span class="line">        <span class="keyword">if</span> (x.den == g) &#123;</span><br><span class="line">            <span class="keyword">return</span> os &lt;&lt; x.num / g;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> os &lt;&lt; x.num / g &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; x.den / g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-线性基（Basis）">10 - 线性基（Basis）</h2><p><a href="https://codeforces.com/contest/1902/submission/235594491">2023-12-03</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Basis</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> t[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Basis</span>() &#123;</span><br><span class="line">        std::<span class="built_in">fill</span>(t, t + <span class="number">20</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y = <span class="number">1E9</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (y &gt; t[i]) &#123;</span><br><span class="line">                    std::<span class="built_in">swap</span>(a[i], x);</span><br><span class="line">                    std::<span class="built_in">swap</span>(t[i], y);</span><br><span class="line">                &#125;</span><br><span class="line">                x ^= a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; t[i] &gt;= y) &#123;</span><br><span class="line">                x ^= a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1>五、字符串</h1><h2 id="01-马拉车（Manacher）">01 - 马拉车（Manacher）</h2><p><a href="https://codeforces.com/contest/1827/submission/205865086">2023-05-14</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">manacher</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">    std::string t = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        t += c;</span><br><span class="line">        t += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * j - i &gt;= <span class="number">0</span> &amp;&amp; j + r[j] &gt; i) &#123;</span><br><span class="line">            r[i] = std::<span class="built_in">min</span>(r[<span class="number">2</span> * j - i], j + r[j] - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i - r[i] &gt;= <span class="number">0</span> &amp;&amp; i + r[i] &lt; n &amp;&amp; t[i - r[i]] == t[i + r[i]]) &#123;</span><br><span class="line">            r[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + r[i] &gt; j + r[j]) &#123;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="02-Z函数">02 - Z函数</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=63378373">2023-08-11</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">zFunction</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">z</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    z[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        z[i] = std::<span class="built_in">max</span>(<span class="number">0</span>, std::<span class="built_in">min</span>(j + z[j] - i, z[i - j]));</span><br><span class="line">        <span class="keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) &#123;</span><br><span class="line">            z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + z[i] &gt; j + z[j]) &#123;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="03-后缀数组（SA）">03 - 后缀数组（SA）</h2><p><a href="https://atcoder.jp/contests/discovery2016-qual/submissions/39727257">2023-03-14</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixArray</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; sa, rk, lc;</span><br><span class="line">    <span class="built_in">SuffixArray</span>(<span class="type">const</span> std::string &amp;s) &#123;</span><br><span class="line">        n = s.<span class="built_in">length</span>();</span><br><span class="line">        sa.<span class="built_in">resize</span>(n);</span><br><span class="line">        lc.<span class="built_in">resize</span>(n - <span class="number">1</span>);</span><br><span class="line">        rk.<span class="built_in">resize</span>(n);</span><br><span class="line">        std::<span class="built_in">iota</span>(sa.<span class="built_in">begin</span>(), sa.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        std::<span class="built_in">sort</span>(sa.<span class="built_in">begin</span>(), sa.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> s[a] &lt; s[b];&#125;);</span><br><span class="line">        rk[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            rk[sa[i]] = rk[sa[i - <span class="number">1</span>]] + (s[sa[i]] != s[sa[i - <span class="number">1</span>]]);</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; tmp, <span class="built_in">cnt</span>(n);</span><br><span class="line">        tmp.<span class="built_in">reserve</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (rk[sa[n - <span class="number">1</span>]] &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(n - k + i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : sa)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(i - k);</span><br><span class="line">            std::<span class="built_in">fill</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                ++cnt[rk[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">                cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">                sa[--cnt[rk[tmp[i]]]] = tmp[i];</span><br><span class="line">            std::<span class="built_in">swap</span>(rk, tmp);</span><br><span class="line">            rk[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">                rk[sa[i]] = rk[sa[i - <span class="number">1</span>]] + (tmp[sa[i - <span class="number">1</span>]] &lt; tmp[sa[i]] || sa[i - <span class="number">1</span>] + k == n || tmp[sa[i - <span class="number">1</span>] + k] &lt; tmp[sa[i] + k]);</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rk[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (j -= j &gt; <span class="number">0</span>; i + j &lt; n &amp;&amp; sa[rk[i] - <span class="number">1</span>] + j &lt; n &amp;&amp; s[i + j] == s[sa[rk[i] - <span class="number">1</span>] + j]; )</span><br><span class="line">                    ++j;</span><br><span class="line">                lc[rk[i] - <span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="04A-后缀自动机（SuffixAutomaton-旧版）">04A - 后缀自动机（SuffixAutomaton 旧版）</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=53409023&amp;returnHomeType=1&amp;uid=329687984">2022-08-17</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> ALPHABET_SIZE = <span class="number">26</span>, N = <span class="number">5e5</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> link;</span><br><span class="line">        <span class="type">int</span> next[ALPHABET_SIZE];</span><br><span class="line">        <span class="built_in">Node</span>() : <span class="built_in">len</span>(<span class="number">0</span>), <span class="built_in">link</span>(<span class="number">0</span>), next&#123;&#125; &#123;&#125;</span><br><span class="line">    &#125; t[<span class="number">2</span> * N];</span><br><span class="line">    <span class="type">int</span> cntNodes;</span><br><span class="line">    <span class="built_in">SuffixAutomaton</span>() &#123;</span><br><span class="line">        cntNodes = <span class="number">1</span>;</span><br><span class="line">        std::<span class="built_in">fill</span>(t[<span class="number">0</span>].next, t[<span class="number">0</span>].next + ALPHABET_SIZE, <span class="number">1</span>);</span><br><span class="line">        t[<span class="number">0</span>].len = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[p].next[c]) &#123;</span><br><span class="line">            <span class="type">int</span> q = t[p].next[c];</span><br><span class="line">            <span class="keyword">if</span> (t[q].len == t[p].len + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            <span class="type">int</span> r = ++cntNodes;</span><br><span class="line">            t[r].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">            t[r].link = t[q].link;</span><br><span class="line">            std::<span class="built_in">copy</span>(t[q].next, t[q].next + ALPHABET_SIZE, t[r].next);</span><br><span class="line">            t[q].link = r;</span><br><span class="line">            <span class="keyword">while</span> (t[p].next[c] == q) &#123;</span><br><span class="line">                t[p].next[c] = r;</span><br><span class="line">                p = t[p].link;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cur = ++cntNodes;</span><br><span class="line">        t[cur].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!t[p].next[c]) &#123;</span><br><span class="line">            t[p].next[c] = cur;</span><br><span class="line">            p = t[p].link;</span><br><span class="line">        &#125;</span><br><span class="line">        t[cur].link = <span class="built_in">extend</span>(p, c);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="04B-后缀自动机（SAM-新版）">04B - 后缀自动机（SAM 新版）</h2><p><a href="https://cf.dianhsu.com/gym/104353/submission/207318083">2023-05-27</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> ALPHABET_SIZE = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> link;</span><br><span class="line">        std::array&lt;<span class="type">int</span>, ALPHABET_SIZE&gt; next;</span><br><span class="line">        <span class="built_in">Node</span>() : len&#123;&#125;, link&#123;&#125;, next&#123;&#125; &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;Node&gt; t;</span><br><span class="line">    <span class="built_in">SAM</span>() &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">assign</span>(<span class="number">2</span>, <span class="built_in">Node</span>());</span><br><span class="line">        t[<span class="number">0</span>].next.<span class="built_in">fill</span>(<span class="number">1</span>);</span><br><span class="line">        t[<span class="number">0</span>].len = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">emplace_back</span>();</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[p].next[c]) &#123;</span><br><span class="line">            <span class="type">int</span> q = t[p].next[c];</span><br><span class="line">            <span class="keyword">if</span> (t[q].len == t[p].len + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">newNode</span>();</span><br><span class="line">            t[r].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">            t[r].link = t[q].link;</span><br><span class="line">            t[r].next = t[q].next;</span><br><span class="line">            t[q].link = r;</span><br><span class="line">            <span class="keyword">while</span> (t[p].next[c] == q) &#123;</span><br><span class="line">                t[p].next[c] = r;</span><br><span class="line">                p = t[p].link;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cur = <span class="built_in">newNode</span>();</span><br><span class="line">        t[cur].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!t[p].next[c]) &#123;</span><br><span class="line">            t[p].next[c] = cur;</span><br><span class="line">            p = t[p].link;</span><br><span class="line">        &#125;</span><br><span class="line">        t[cur].link = <span class="built_in">extend</span>(p, c);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> p, <span class="type">char</span> c, <span class="type">char</span> offset = <span class="string">&#x27;a&#x27;</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">extend</span>(p, c - offset);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t[p].next[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> p, <span class="type">char</span> c, <span class="type">char</span> offset = <span class="string">&#x27;a&#x27;</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>(p, c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">link</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t[p].link;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">len</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t[p].len;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="05-回文自动机（PAM）">05 - 回文自动机（PAM）</h2><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=62237107&amp;returnHomeType=1&amp;uid=329687984">2023-05-19</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PAM</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> ALPHABET_SIZE = <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> link;</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        std::array&lt;<span class="type">int</span>, ALPHABET_SIZE&gt; next;</span><br><span class="line">        <span class="built_in">Node</span>() : len&#123;&#125;, link&#123;&#125;, cnt&#123;&#125;, next&#123;&#125; &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;Node&gt; t;</span><br><span class="line">    <span class="type">int</span> suff;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="built_in">PAM</span>() &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">assign</span>(<span class="number">2</span>, <span class="built_in">Node</span>());</span><br><span class="line">        t[<span class="number">0</span>].len = <span class="number">-1</span>;</span><br><span class="line">        suff = <span class="number">1</span>;</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">emplace_back</span>();</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(<span class="type">char</span> c, <span class="type">char</span> offset = <span class="string">&#x27;a&#x27;</span>)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = s.<span class="built_in">size</span>();</span><br><span class="line">        s += c;</span><br><span class="line">        <span class="type">int</span> let = c - offset;</span><br><span class="line">        <span class="type">int</span> cur = suff, curlen = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            curlen = t[cur].len;</span><br><span class="line">            <span class="keyword">if</span> (pos - <span class="number">1</span> - curlen &gt;= <span class="number">0</span> &amp;&amp; s[pos - <span class="number">1</span> - curlen] == s[pos])</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            cur = t[cur].link;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">if</span> (t[cur].next[let]) &#123;  </span><br><span class="line">            suff = t[cur].next[let];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">newNode</span>();</span><br><span class="line">        suff = num;</span><br><span class="line">        t[num].len = t[cur].len + <span class="number">2</span>;</span><br><span class="line">        t[cur].next[let] = num;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (t[num].len == <span class="number">1</span>) &#123;</span><br><span class="line">            t[num].link = <span class="number">1</span>;</span><br><span class="line">            t[num].cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            cur = t[cur].link;</span><br><span class="line">            curlen = t[cur].len;</span><br><span class="line">            <span class="keyword">if</span> (pos - <span class="number">1</span> - curlen &gt;= <span class="number">0</span> &amp;&amp; s[pos - <span class="number">1</span> - curlen] == s[pos]) &#123;</span><br><span class="line">                t[num].link = t[cur].next[let];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;           </span><br><span class="line"> </span><br><span class="line">        t[num].cnt = <span class="number">1</span> + t[t[num].link].cnt;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">PAM pam;</span><br></pre></td></tr></table></figure><h2 id="06A-AC自动机（AC-旧版）">06A - AC自动机（AC 旧版）</h2><p><a href="https://codeforces.com/contest/710/submission/121661266">2021-07-07</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">30</span>, A = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> fail;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> next[A];</span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">fail</span>(<span class="number">-1</span>), <span class="built_in">sum</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        std::<span class="built_in">memset</span>(next, <span class="number">-1</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; node[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> bin[N];</span><br><span class="line"><span class="type">int</span> nBin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = nBin &gt; <span class="number">0</span> ? bin[--nBin] : cnt++;</span><br><span class="line">    node[p] = <span class="built_in">Node</span>();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">    <span class="built_in">AC</span>(AC &amp;&amp;a) : <span class="built_in">x</span>(std::<span class="built_in">move</span>(a.x)) &#123;&#125;</span><br><span class="line">    <span class="built_in">AC</span>(std::vector&lt;std::string&gt; s, std::vector&lt;<span class="type">int</span>&gt; w) &#123;</span><br><span class="line">        x = &#123;<span class="built_in">newNode</span>(), <span class="built_in">newNode</span>()&#125;;</span><br><span class="line">        std::<span class="built_in">fill</span>(node[x[<span class="number">0</span>]].next, node[x[<span class="number">0</span>]].next + A, x[<span class="number">1</span>]);</span><br><span class="line">        node[x[<span class="number">1</span>]].fail = x[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(s.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = x[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">int</span>(s[i].<span class="built_in">length</span>()); j++) &#123;</span><br><span class="line">                <span class="type">int</span> c = s[i][j] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node[p].next[c] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> u = <span class="built_in">newNode</span>();</span><br><span class="line">                    x.<span class="built_in">push_back</span>(u);</span><br><span class="line">                    node[p].next[c] = u;</span><br><span class="line">                &#125;</span><br><span class="line">                p = node[p].next[c];</span><br><span class="line">            &#125;</span><br><span class="line">            node[p].sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(x[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            node[u].sum += node[node[u].fail].sum;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; A; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node[u].next[c] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    node[u].next[c] = node[node[u].fail].next[c];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node[node[u].next[c]].fail = node[node[u].fail].next[c];</span><br><span class="line">                    que.<span class="built_in">push</span>(node[u].next[c]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">AC</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : x) &#123;</span><br><span class="line">            bin[nBin++] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">i64 <span class="title">query</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        i64 ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p = x[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(s.<span class="built_in">length</span>()); i++)  &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            p = node[p].next[c];</span><br><span class="line">            ans += node[p].sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="06B-AC自动机（AhoCorasick-新版）">06B - AC自动机（AhoCorasick 新版）</h2><p><a href="https://codeforces.com/contest/1801/submission/201155712">2023-04-07</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AhoCorasick</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> ALPHABET = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> link;</span><br><span class="line">        std::array&lt;<span class="type">int</span>, ALPHABET&gt; next;</span><br><span class="line">        <span class="built_in">Node</span>() : link&#123;&#125;, next&#123;&#125; &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;Node&gt; t;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AhoCorasick</span>() &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">assign</span>(<span class="number">2</span>, <span class="built_in">Node</span>());</span><br><span class="line">        t[<span class="number">0</span>].next.<span class="built_in">fill</span>(<span class="number">1</span>);</span><br><span class="line">        t[<span class="number">0</span>].len = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">emplace_back</span>();</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[p].next[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                t[p].next[x] = <span class="built_in">newNode</span>();</span><br><span class="line">                t[t[p].next[x]].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = t[p].next[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span> std::string &amp;a, <span class="type">char</span> offset = <span class="string">&#x27;a&#x27;</span>)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            b[i] = a[i] - offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">add</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[x].next[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    t[x].next[i] = t[t[x].link].next[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t[t[x].next[i]].link = t[t[x].link].next[i];</span><br><span class="line">                    q.<span class="built_in">push</span>(t[x].next[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t[p].next[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> p, <span class="type">char</span> c, <span class="type">char</span> offset = <span class="string">&#x27;a&#x27;</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>(p, c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">link</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t[p].link;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">len</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t[p].len;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="07-随机生成模底-字符串哈希（例题）">07 - 随机生成模底 字符串哈希（例题）</h2><p><a href="https://codeforces.com/contest/1598/submission/160006998">2022-06-09</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isprime</span>(n)) &#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Hash = std::array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> P = <span class="built_in">findPrime</span>(<span class="built_in">rng</span>() % <span class="number">900000000</span> + <span class="number">100000000</span>);</span><br><span class="line">    </span><br><span class="line">    std::string s, x;</span><br><span class="line">    std::cin &gt;&gt; s &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> m = x.<span class="built_in">length</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">h</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        h[i + <span class="number">1</span>] = (<span class="number">10LL</span> * h[i] + s[i] - <span class="string">&#x27;0&#x27;</span>) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        p[i + <span class="number">1</span>] = <span class="number">10LL</span> * p[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="built_in">return</span> (h[r] + <span class="number">1LL</span> * (P - h[l]) * p[r - l]) % P;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> px = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : x) &#123;</span><br><span class="line">        px = (<span class="number">10LL</span> * px + c - <span class="string">&#x27;0&#x27;</span>) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">2</span> * (m - <span class="number">1</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">get</span>(i, i + m - <span class="number">1</span>) + <span class="built_in">get</span>(i + m - <span class="number">1</span>, i + <span class="number">2</span> * m - <span class="number">2</span>)) % P == px) &#123;</span><br><span class="line">            std::cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i + m - <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            std::cout &lt;&lt; i + m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i + <span class="number">2</span> * m - <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">z</span><span class="params">(m + <span class="number">1</span>)</span>, <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    z[<span class="number">0</span>] = m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j != <span class="number">-1</span>) &#123;</span><br><span class="line">            z[i] = std::<span class="built_in">max</span>(<span class="number">0</span>, std::<span class="built_in">min</span>(j + z[j] - i, z[i - j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (z[i] + i &lt; m &amp;&amp; x[z[i]] == x[z[i] + i]) &#123;</span><br><span class="line">            z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || i + z[i] &gt; j + z[j]) &#123;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j != <span class="number">-1</span>) &#123;</span><br><span class="line">            f[i] = std::<span class="built_in">max</span>(<span class="number">0</span>, std::<span class="built_in">min</span>(j + f[j] - i, z[i - j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (f[i] + i &lt; n &amp;&amp; f[i] &lt; m &amp;&amp; x[f[i]] == s[f[i] + i]) &#123;</span><br><span class="line">            f[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || i + f[i] &gt; j + f[j]) &#123;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = std::<span class="built_in">min</span>(m, f[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : &#123; m - l, m - l - <span class="number">1</span> &#125;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= i &amp;&amp; (<span class="built_in">get</span>(i - j, i) + <span class="built_in">get</span>(i, i + m)) % P == px) &#123;</span><br><span class="line">                std::cout &lt;&lt; i - j + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                std::cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i + m &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i + m + j &lt;= n &amp;&amp; (<span class="built_in">get</span>(i, i + m) + <span class="built_in">get</span>(i + m, i + m + j)) % P == px) &#123;</span><br><span class="line">                std::cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i + m &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                std::cout &lt;&lt; i + m + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i + m + j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文转自 <a href="https://www.cnblogs.com/WIDA/p/17633758.html#01b---%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84fenwick-%E6%96%B0%E7%89%88">https://www.cnblogs.com/WIDA/p/17633758.html#01b---树状数组fenwick-新版</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <summary type="html">jly在cf比赛上的模板</summary>
    
    
    
    <category term="算法模板" scheme="https://blog.lazy-boy-acmer.cn/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="算法" scheme="https://blog.lazy-boy-acmer.cn/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法学习" scheme="https://blog.lazy-boy-acmer.cn/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hello2024</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/8187673c.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/8187673c.html</id>
    <published>2024-08-08T15:46:17.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1919/problem/A">Wallet Exchange</a></h1><h2 id="题目大意">题目大意</h2><blockquote><p><code>Alice</code>有<code>a</code>个硬币,<code>Bob</code>有<code>b</code>个硬币,双方轮流进行以下操作:<br>1.与对方交换硬币,或者保留现有硬币.<br>2.取出一个硬币<br>无法进行操作的人判定为输,总是从<code>Alice</code>开始操作<br>问:哪位获得胜利</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>我们可以把游戏看作是轮流取硬币,取得最后一个硬币的为胜利<br>那么我们就可以直接判断<code>a+b</code>奇偶性就可以得出答案.</p></blockquote><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(n) std::fixed &lt;&lt; std::setprecision(n)</span></span><br><span class="line">[[maybe_unused]]<span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    std::cout &lt;&lt; ((a + b) % <span class="number">2</span> ? <span class="string">&quot;Alice&quot;</span> : <span class="string">&quot;Bob&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://codeforces.com/contest/1919/problem/B">Plus-Minus Split</a></h1><h2 id="题目大意-2">题目大意</h2><blockquote><p>略</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>简单看下样例就猜出来是<code>+</code>与<code>-</code>的差值的绝对值</p></blockquote><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(n) std::fixed &lt;&lt; std::setprecision(n)</span></span><br><span class="line">[[maybe_unused]]<span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: s)</span><br><span class="line">        cnt1 += (i == <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">abs</span>((n - cnt1) - cnt1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://codeforces.com/contest/1919/problem/C">Grouping Increases</a></h1><h2 id="题目大意-3">题目大意</h2><blockquote><p><img src="http://tuchuang.lazy-boy-acmer.cn/images/202404060855225.png" alt="image.png"></p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>贪心</p></blockquote><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(n) std::fixed &lt;&lt; std::setprecision(n)</span></span><br><span class="line">[[maybe_unused]]<span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; a[i];</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    A.<span class="built_in">push_back</span>(INF), B.<span class="built_in">push_back</span>(INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = A.<span class="built_in">back</span>(), y = B.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= x)</span><br><span class="line">                A.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt;= y)</span><br><span class="line">                B.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                A.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= y)</span><br><span class="line">                B.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt;= x)</span><br><span class="line">                A.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                B.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-hello2024(A-C)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Goodbye2023</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/2e5c1b6c.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/2e5c1b6c.html</id>
    <published>2024-08-08T15:44:55.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1916/problem/A">2023</a></h1><h2 id="题目描述">题目描述</h2><blockquote><p>给定 <code>n</code>个数，让我们判断是否能与 <code>m</code>个数相乘后可以得到 <code>2023</code>，并且将这些数输出出来</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>我们只需要判断这些数能否被2023整除。</p></blockquote><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(n) std::fixed &lt;&lt; std::setprecision(n)</span></span><br><span class="line">[[maybe_unused]]<span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">2023</span>;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (s % a[i]) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s /= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">        std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>B  <a href="https://codeforces.com/contest/1916/problem/B">Two Divisors</a></h1><h2 id="题目描述-2">题目描述</h2><blockquote><p>选择一个 (1 &lt;= x &lt;= 1e9) 的数。同时满足 1≤a&lt;b&lt;x 的条件。<br>对于给定的数 a、b，你需要求出 x 的值。<br>如果有整数 k，使得 x=y⋅k, 则数 y 是数 x 的除数。</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>首先你得要知道，你需要这个值有a和b，那么是和lcm(a,b)是有关系的，默认a&lt;b，然后其次你发现，lcm(a,b)如果和b一样的话，那么你的这个值，实际上他会选不到b，那么我们需要把这个值增加一些，并且不影响答案。那么这个增加的值实际上就是lcm(a,b)/a，首先这题有解，那么lcm(a,b)一定有a和b的因子，由于他们是最大的，所以我们需要乘一个小数，去使得能选到b，但是a和b仍然是最大两个，所以当你的lcm(a,b)不是b的时候，那么lcm(a,b)就是答案，否则，答案应该乘上一个小值，那么乘上什么值是正确的，首先我们要理解，肯定不能让a变成除了b以外的数字，那么就是乘上一个lcm(a,b)/a，乘上这个值之后，他们的因子没有出现新大数。</p></blockquote><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(n) std::fixed &lt;&lt; std::setprecision(n)</span></span><br><span class="line">[[maybe_unused]]<span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b % a)</span><br><span class="line">        std::cout &lt;&lt; a * b / std::<span class="built_in">gcd</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; b * b / a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>C  <a href="https://codeforces.com/contest/1916/problem/C">Training Before the Olympiad</a></h1><h2 id="题目描述-3">题目描述</h2><blockquote><p>玛莎和奥丽雅马上就要参加一个重要的团队奥林匹克竞赛了。为此，玛莎建议和奥丽雅玩一个热身游戏：<br>有一个大小为 n 的数组 a。马莎先走，然后大家轮流走。每一步都可以用下面的操作顺序来描述：<br>如果数组的大小为 1，游戏结束。<br>当前下棋的棋手选择两个不同的索引 i、j(1≤i,j≤|a|)，并执行以下操作–从数组中移除 ai 和 aj，并在数组中添加一个等于⌊ai+aj2⌋⋅2 的数字。换句话说，首先将 ai 和 aj 的和除以 2(向下舍入)，然后将结果乘以 2。<br>玛莎的目标是最大化最终数字，而奥丽雅的目标是最小化最终数字。<br>玛莎和奥丽雅决定在初始数组 a 的每个非空前缀上进行博弈，并请求您的帮助。<br>对于每个 k(=1,2,…,n)，请回答下面的问题。让数组 a 的前 k 个元素出现在游戏中，索引分别为 1,2,…,k。在双方都下得最好的情况下，最后会剩下多少个元素？</p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>我们只需要注意到奇数加偶数会产生一个-1，那么我们就是要算怎么样计算这个值，我们发现，无论哪两个数字都会产生一个偶数，所以偶数是最后消去的，我们如果想要答案最大，那么一定是优先消除掉奇数，如果想要答案最小，一定是奇数和偶数组合，那么我们记录奇数和偶数的数量，在面对到奇数的时候，这个减去的多少个-1，我们可以算出他的过程，注意对于只有一个数字的情况要特判。</p></blockquote><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(n) std::fixed &lt;&lt; std::setprecision(n)</span></span><br><span class="line">[[maybe_unused]]<span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> S = <span class="number">0</span>, C = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        S += a[i], C += a[i] &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; S - C / <span class="number">3</span> - (C % <span class="number">3</span> == <span class="number">1</span>) &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-goodbye2023(A-C)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 168 (Rated for Div. 2)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/68460d35.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/68460d35.html</id>
    <published>2024-08-08T15:43:50.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1997/problem/A">Strong Password</a></h1><h2 id="题目描述">题目描述</h2><blockquote><p>给定字符串，现在让我们添加一个字符，使得字符串的价值最大，对于价值是这样看的</p><ul><li>第一个字符的价值为<code>2</code>，</li><li>后面的字符若与前面的字符相同，则价值为<code>1</code>，否则价值为<code>2</code>。<br>让我们输出价值最大的一种情况</li></ul></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>我们可以遍历每一个位置，然后找出在哪个位置插入的价值最大，毕竟 <code>n</code> 的取值较小，最后再将其替换为与前后位置不相等的字符即可。</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string s, t;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; (s[<span class="number">0</span>] == <span class="string">&#x27;z&#x27;</span> ? <span class="string">&#x27;a&#x27;</span> : <span class="string">&#x27;z&#x27;</span>) &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ma = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> w = s;</span><br><span class="line">    w.<span class="built_in">insert</span>(w.<span class="built_in">begin</span>() + i, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; w.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (w[j] == w[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        res++;</span><br><span class="line">      &#125; <span class="keyword">else</span> res += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ma &lt;= res) &#123;</span><br><span class="line">      ma = res;</span><br><span class="line">      t = w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pos = t.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="type">int</span> t1 = pos - <span class="number">1</span>, t2 = pos + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != t[t1] &amp;&amp; i != t[t2]) &#123;</span><br><span class="line">      t[pos] = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://codeforces.com/contest/1997/problem/B">Make Three Regions</a></h1><h2 id="题目描述-2">题目描述</h2><blockquote><p>给定一个 $2 * n$ 的一个字符矩阵，其中 <code>.</code> 是开放的，而 <code>X</code> 是阻塞的，现在让我们判断有几个点可以将这个字符矩阵分为三个联通的区域。</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>刚开始的时候，以为是有几个联通的区域，写完 <code>dfs</code> 后，什么<code>WA1</code>， 我连 <code>dfs</code> 都能写错，结果自己是小丑（小插曲）<br>可以通过给出的图例看出一列只可能有一个点能成为分割点，那么能成为分割点就需要满足四个条件，</p><ul><li>$s[0][i] =‘.’  &amp;&amp; s[1][i] =‘.’$</li><li>$s[0][i - 1] \neq s[1][i - 1]$</li><li>$s[0][i+1] \neq s[1][i+1]$</li><li>$s[0][i-1] = s[0][i + 1]$<br>既然这样，那就简单了</li></ul></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">2</span>, m;</span><br><span class="line">  std::cin &gt;&gt; m;</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">bool</span> k = <span class="literal">true</span>;</span><br><span class="line">    k &amp;= (s[<span class="number">0</span>][i] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s[<span class="number">1</span>][i] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    k &amp;= (s[<span class="number">0</span>][i - <span class="number">1</span>] != s[<span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">    k &amp;= (s[<span class="number">0</span>][i + <span class="number">1</span>] != s[<span class="number">1</span>][i + <span class="number">1</span>]);</span><br><span class="line">    k &amp;= (s[<span class="number">0</span>][i - <span class="number">1</span>] == s[<span class="number">0</span>][i + <span class="number">1</span>]);</span><br><span class="line">    ans += k ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">  std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">  <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://codeforces.com/contest/1997/problem/C">Even Positions</a></h1><h2 id="题目描述-3">题目描述</h2><blockquote><p>给定字符串，让我们输出字符串匹配的<code>()</code>的最短距离，距离是$pos(‘()’) - pos(‘(’)$</p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>手指玩玩就行了</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int ,int&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fix(x) std::fixed &lt;&lt; std::setprecision(x)  </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e17</span> + <span class="number">50</span>, MAX_N = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    std::cin &gt;&gt; n;  </span><br><span class="line">  </span><br><span class="line">    std::string s;  </span><br><span class="line">    std::cin &gt;&gt; s;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;  </span><br><span class="line">       <span class="keyword">if</span> (pre &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">          pre--;  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          pre++;  </span><br><span class="line">       &#125;       ans += pre;  </span><br><span class="line">       pre += (s[i + <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>);  </span><br><span class="line">       ans += pre;  </span><br><span class="line">    &#125;  </span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);  </span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);  </span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;  </span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;  </span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-edu-168(A-C)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 161 (Rated for Div. 2)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/90fae0c1.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/90fae0c1.html</id>
    <published>2024-08-08T15:42:58.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1922/problem/A">Tricky Template</a></h1><h2 id="题目描述">题目描述</h2><blockquote><p>给一个数字<code>n</code>和三个长度为<code>n</code>的字符串 <code>a</code>,<code>b</code>,<code>c</code>。找一个模板使得字符串<code>a</code>,<code>b</code>匹配，而<code>c</code>不匹配,是否存在这样一个模板.<br>匹配的定义是:当模板字母为小写时,两个字符串字符相同,为大写时,两个字符不同,这样的两个字符串则匹配</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>我们可以直接得出当<code>a</code>字符串和<code>b</code>字符串都不等于<code>c</code>字符串时,就存在这样一个模板使得满足题意</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">50</span>, pi = <span class="number">3</span>;</span><br><span class="line">[[maybe_unused]]<span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::string a, b, c;</span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != c[i] &amp;&amp; b[i] != c[i]) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://codeforces.com/contest/1922/problem/B">Forming Triangles</a></h1><h2 id="题目描述-2">题目描述</h2><blockquote><p>给定一个长度为<code>n</code>的一个数组<code>a</code>,对于<code>a[i]</code>来说,就是一个长度为<code>2^a[i]</code>的木棒,现在问:用这些木棒能组成多少个三角形.</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>对于一个三角形来说,两边之和大于第三边,两边之差小于第三边,不可能存在两边之和等于第三边,那么我们就可以得到要组成一个三角形就至少需要两条边相等,第三边小于等于这两个边,那么这个问题就成了一个组合数问题</p><p>组合数用<code>C(cnt, m)</code>来表示,其中<code>cnt</code>为这个数的总数,<code>m</code>为我们需要选的个数;<br><code>cnt</code>可以用<code>map</code>来写,对数组去重,遍历一次数组,<code>s</code>表示比遍历到当前数字小的个数<br>即写成<code>ans += C(mp[a[i]], 3) + C(mp[a[i]], 2) * s</code></p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">50</span>, pi = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        ans = ans * (n - m + i) / i;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) std::cin &gt;&gt; a[i], mp[a[i]]++;</span><br><span class="line">    std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    n = std::<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">C</span>(mp[a[<span class="number">0</span>]], <span class="number">3</span>), s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = mp[a[i]];</span><br><span class="line">        s += mp[a[i - <span class="number">1</span>]];</span><br><span class="line">        ans += <span class="built_in">C</span>(t, <span class="number">3</span>) + <span class="built_in">C</span>(t, <span class="number">2</span>) * s;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://codeforces.com/contest/1922/problem/C">Closest Cities</a></h1><h2 id="题目描述-3">题目描述</h2><blockquote><p>在<code>x</code>轴上有<code>n</code>个城市,其位置为<code>a[i]</code>,并且序列<code>a</code>按升序排列,保证每个城市只有一个最近的城市<br>若<code>i</code>的最近城市是<code>i+1</code>则花费<code>1</code>,否则花费<code>|a[i]-a[i+1]|</code>,现在有<code>q</code>次询问<br>问:每次询问城市<code>x</code>到城市<code>y</code>的最小花费.</p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>先分析一下<code>x&lt;y</code>,我们只有一直向右走才会有最小花费,那就需要判断当前城市的最近城市是否为下一个城市.<br>由于是一直向右走,我么就可以用前缀和求解这个问题.<br>同理,<code>x&gt;y</code>时,我们是从右向左走,可以用后缀和求解.</p></blockquote><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">50</span>, pi = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> s1 = a, s2 = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) std::cin &gt;&gt; a[i];</span><br><span class="line">    s1[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] - a[i - <span class="number">1</span>] &gt; a[i + <span class="number">1</span>] - a[i]) s1[i + <span class="number">1</span>] = s1[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> s1[i + <span class="number">1</span>] = s1[i] + <span class="built_in">abs</span>(a[i + <span class="number">1</span>] - a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    s2[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] - a[i - <span class="number">1</span>] &gt; a[i + <span class="number">1</span>] - a[i]) s2[i - <span class="number">1</span>] = s2[i] + <span class="built_in">abs</span>(a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> s2[i - <span class="number">1</span>] = s2[i] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//        std::cout &lt;&lt; s1[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//        std::cout &lt;&lt; s2[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        std::cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">            std::cout &lt;&lt; s1[y] - s1[x] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; s2[y] - s2[x] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-edu-161(A-C)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 160 (Rated for Div. 2)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/f59ddb87.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/f59ddb87.html</id>
    <published>2024-08-08T15:41:58.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1913/problem/A">Rating Increas</a></h1><h2 id="题目大意">题目大意</h2><blockquote><p>给定一个数字,让我们拆分成两个数,这两个数满足以下条件:</p><ol><li><code>a &lt; b</code>.</li><li>两个数没有前缀<code>0</code>.</li></ol><p>问:输出满足条件的数<code>a , b</code>.</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>直接暴力循环这个数的位数次,若满足<code>a &lt; b</code>,再判断两个数的位数和是否与拆分前相同.</p></blockquote><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, cnt = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> s = n;</span><br><span class="line">    <span class="keyword">while</span> (s) &#123;</span><br><span class="line">        k++;</span><br><span class="line">        s /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = k;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="type">int</span> w = n;</span><br><span class="line">        <span class="type">int</span> a = w / cnt, b = w % cnt;</span><br><span class="line">        <span class="type">int</span> x = a, y = b;</span><br><span class="line">        <span class="type">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            s1++;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (y) &#123;</span><br><span class="line">            s2++;</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b &amp;&amp; s1 + s2 == t) &#123;</span><br><span class="line">            std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>B <a href="https://codeforces.com/contest/1913/problem/B">Swap and Delete</a></h1><h2 id="题目大意-2">题目大意</h2><blockquote><p>给一个<code>01</code>字符串<code>s</code>,现在有以下操作:</p><ol><li>交换<code>s[i],s[j]</code>,此操作花费为<code>0</code>.</li><li>删除<code>s[i]</code>,此操作花费一个金币.</li></ol><p>将修改后的字符串记录为<code>t</code>.<br>问:至少花费多少金币,使得<code>t[i] != s[i] (0 &lt;= i &lt;= t.size())</code>.</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>我们可以记一下有多少个<code>0</code> 和多少个<code>1</code>,<br>然后我们遍历一次字符串,<code>check</code>当前<code>0</code>的个数是否大于<code>1</code>的总数和当前<code>1</code>的个数是否大于<code>0</code>的总数</p></blockquote><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: s)</span><br><span class="line">        s0 += (i == <span class="string">&#x27;0&#x27;</span>), s1 += (i == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cnt0 += (s[i] == <span class="string">&#x27;0&#x27;</span>), cnt1 += (s[i] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (s0 &gt;= cnt1 &amp;&amp; s1 &gt;= cnt0)</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">int</span>) s.<span class="built_in">size</span>() - ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://codeforces.com/contest/1913/problem/C">Game with Multiset</a></h1><h2 id="题目大意-3">题目大意</h2><blockquote><p>有两种查询类型:</p><ol><li><code>ADD x</code>,即在集合中添加<code>2^x</code>的元素.</li><li><code>GET w</code>,即询问集合中的某子集之和,能否等于<code>w</code>.</li></ol></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>很显然,本题考查位运算,用数组模拟,其中<code>cnt[i]</code>表示集合中<code>2^i</code>的元素个数.</p></blockquote><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">32</span>, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> calc = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = cnt[i], s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (mid * (<span class="number">1</span> &lt;&lt; i) &lt;= x)</span><br><span class="line">                    s = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x -= (<span class="number">1</span> &lt;&lt; i) * s;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; (x == <span class="number">0</span> ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="type">int</span> t, v;</span><br><span class="line">        std::cin &gt;&gt; t &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">            cnt[v]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">calc</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-edu-160(A-C)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 159 (Rated for Div. 2)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/763fb490.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/763fb490.html</id>
    <published>2024-08-08T15:40:53.000Z</published>
    <updated>2025-08-22T02:37:23.081Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1902/problem/A">Binary Imbalance</a></h1><h2 id="题目大意">题目大意</h2><blockquote><p>给定一个长度为<code>n</code>的一个<code>01</code>字符串，我们执行以下操作：<br>当<code>s[i]!=s[i+1]</code>在中间插入<code>0</code><br>问：是否可以实现<code>0</code>的个数大于<code>1</code>的个数</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>由题意可以明显看出只要有<code>0</code>就可以实现。下面简单分析下：</p><ol><li><code>0</code>的个数大于0，<code>1111110</code>我们可以在子串<code>10</code>中间一直插入<code>0</code></li><li><code>0</code>的个数为<code>0</code>时， <code>11111111</code>不可能在字符串中插入<code>0</code></li></ol></blockquote><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>B <a href="https://codeforces.com/contest/1902/problem/B">Getting Points</a>(贪心)</h1><h2 id="题目大意-2">题目大意</h2><blockquote><p><code>n</code>天里面要获得<code>p</code>分,可以通过两个路径获取分数:</p><ol><li>每天上一堂课,可获得<code>i</code>分.</li><li>进行一次实践,可获得<code>t</code>分,但是实践==每七天才会有一个==, ==每一天最多可以做两个实践==</li></ol><p>其中, 一天可以选择休息或者学习, 问最多可以休息多少天.</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>可以将所有任务放在最后几天</p></blockquote><h2 id="代码-2">代码</h2><p>(大佬们指点一下)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, p, L, t;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; p &gt;&gt; L &gt;&gt; t;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n, ans =<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="type">int</span> mid =(l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((n - mid + <span class="number">1</span>)* L +std::<span class="built_in">min</span>((n + <span class="number">6</span>) / <span class="number">7</span>,(n - mid + <span class="number">1</span>)* <span class="number">2</span> ) * t&gt;= p) ans = mid ,l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://codeforces.com/contest/1902/problem/C">Insert and Equalize</a></h1><h2 id="题目大意-3">题目大意</h2><blockquote><p>给你一个整数数组 <code>a[1],a[2],...,a[n]</code>所有元素都是不同的。</p><p>首先，要求你在这个数组中再插入一个整数 <code>a[n+1]，a[n+1]</code> 不应等于 a1,a2,…,an。</p><p>然后，你必须使数组中的所有元素相等。一开始，你选择一个==正整数==<code>x(x\&gt;0 )</code>在一次操作中，你将 <code>x </code>恰好加到数组的一个元素上。<br>==注意，所有操作中 x 都是相同的==。<br>在你选择 <code>a[n+1]</code>和 <code>x</code> 之后，使所有元素相等的最小操作次数是多少？</p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>假设数组<code>a</code> 中有元素<code>x, y, z </code>(三者互不相等, 其中 z 最大) , 那么我们就需要找到一个数<code>w</code>,使得 <code>x+k1*w=z, y+k2*w=z</code><br>显然就可以看出一个性质<code>w=gcd(abs(x-y), abs(y-z))</code><br>就这样我们找到了题目中的<code>x</code>,接下来, 我们需要找插入的<code>a[n+1]</code><br>令 <code>ma=max(a)</code>,因为元素互不相等, 我们就需要找插入比<code>ma</code>大<code>k*w</code> 和比<code>ma</code>小<code>k*w</code>的两个数,<br>分别重新找出最大值, 并计算所有元素加到<code>ma</code>的次数<br>输出两种情况下最小的次数.</p></blockquote><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line">    std::map&lt;<span class="type">int</span> , <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        std::cin &gt;&gt; x,a.<span class="built_in">push_back</span>(x), b.<span class="built_in">push_back</span>(x), mp[a[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> w = <span class="built_in">unique</span>(a.<span class="built_in">begin</span> (), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span> ();</span><br><span class="line">    <span class="keyword">if</span>(w == <span class="number">1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> o = <span class="built_in">abs</span>(a[<span class="number">1</span>] - a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span> ; i &lt; n ; i ++)</span><br><span class="line">        o = std::__gcd(<span class="built_in">abs</span>(a[i] - a[i - <span class="number">1</span>]), o);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; o &lt;&lt; endl;</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k1 = *std::<span class="built_in">max_element</span> (a.<span class="built_in">begin</span> (), a.<span class="built_in">end</span> ());</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        cnt ++;</span><br><span class="line">        <span class="keyword">if</span>(mp[k1 - cnt * o] != <span class="number">1</span>)&#123;</span><br><span class="line">            a.<span class="built_in">push_back</span> (k1 - cnt * o);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k1 = *std::<span class="built_in">max_element</span> (a.<span class="built_in">begin</span> (), a.<span class="built_in">end</span> ());</span><br><span class="line">    <span class="type">int</span> ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; (<span class="type">int</span>)a.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        ans1 += <span class="built_in">abs</span>(a[i] - k1) / o;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k2 = *std::<span class="built_in">max_element</span> (b.<span class="built_in">begin</span> (), b.<span class="built_in">end</span> ());</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        cnt ++;</span><br><span class="line">        <span class="keyword">if</span>(mp[k2 + cnt * o] != <span class="number">1</span>)&#123;</span><br><span class="line">            b.<span class="built_in">push_back</span> (k2 + cnt * o);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k2 = *std::<span class="built_in">max_element</span> (b.<span class="built_in">begin</span> (), b.<span class="built_in">end</span> ());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; (<span class="type">int</span>)b.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        ans2 += <span class="built_in">abs</span>(a[i] - k2) / o;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">min</span>(ans1, ans2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D <a href="https://codeforces.com/contest/1902/problem/D">Robot Queries</a></h1><h2 id="题目描述">题目描述</h2><blockquote><p>给一个长度为n 的字符串和q次询问, 机器人开始在<code>(0,0)</code><br>机器人可以执行四条指令：</p><ol><li>U-- 从点<code>(x,y)</code> 移动到 <code>(x,y+1)</code> ；</li><li>D-- 从点<code>(x,y)</code> 移动到 <code>(x,y−1)</code>；</li><li>L–从点 <code>(x,y)</code> 移动到 <code>(x−1,y)</code>；</li><li>R–从点 <code>(x,y)</code> 移动到 <code>(x+1,y)</code>。<br>每次询问四个数x, y, l, r ,<br>判断机器人是否访问过点(x, y),但字符串l 到 r 的字串是相反的.</li></ol></blockquote><h2 id="代码-4">代码</h2><p>(TLE 13)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    <span class="keyword">while</span>(q --)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, N, M, l, r;</span><br><span class="line">        std::cin &gt;&gt; N &gt;&gt; M &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="function">std::string <span class="title">str</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="type">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">reverse</span> (str.<span class="built_in">begin</span>() + l, str.<span class="built_in">begin</span> () + r + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="type">int</span>) str.<span class="built_in">size</span>() ;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == N &amp;&amp; y == M)&#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">                f = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;U&#x27;</span>)y ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;D&#x27;</span>) y --;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;L&#x27;</span>) x --;</span><br><span class="line">            <span class="keyword">else</span> x ++;</span><br><span class="line">            <span class="keyword">if</span>(x == N &amp;&amp; y == M)&#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">                f = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; Lazy_boy_;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-edu-159(A-D)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 922 (Div. 2)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/1b0b3fd5.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/1b0b3fd5.html</id>
    <published>2024-08-08T15:39:47.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1918/problem/A">Brick Wall</a></h1><h2 id="题目描述">题目描述</h2><blockquote><p>砖块大小为<code>1 * k</code>,砖块可以水平和竖直放置,<br>现在,我们用这样的砖块砌一堵<code>n * m</code>的墙, 墙的稳定性为水平砖块数与垂直砖块数之差.<br>问:最大稳定性是多少</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>为了使墙的稳定性最高,我们可以让所有的砖块水平放置,且砖块的大小为<code>1*2</code>,这样墙的稳定为$n \times (m / 2)$</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e16</span> + <span class="number">50</span>, MOD = <span class="number">10007</span>;</span><br><span class="line">[[maybe_unused]] <span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    std::cout &lt;&lt; n * (m / <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://codeforces.com/contest/1918/problem/B">Minimize Inversions</a></h1><h2 id="题目描述-2">题目描述</h2><blockquote><p>长度为<code>n</code>的数组<code>a</code>和<code>b</code>,由于讨厌倒置($a_{i}&lt;a_{j},i &gt;j$)<br>我们将调整顺序即:交换$a_i,a_j和b_i,b_j$<br>以使倒置的数较少</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>我们可以直接对一个数组排序即可,这样就可以使一个数组没有倒置,使答案最小化.</p></blockquote><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e17</span> + <span class="number">50</span>;</span><br><span class="line">[[maybe_unused]] <span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;pii&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        std::cin &gt;&gt; a[i].first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        std::cin &gt;&gt; a[i].second;</span><br><span class="line">    std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">        std::cout &lt;&lt; a[i].first &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">        std::cout &lt;&lt; a[i].second &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-round-922(A-B)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 916 (Div. 3)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/9219c8ef.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/9219c8ef.html</id>
    <published>2024-08-08T15:38:48.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1914/problem/A">Problemsolving Log</a></h1><h2 id="题目描述">题目描述</h2><blockquote><p>给一个整数<code>n</code>,字符串<code>s</code>,字符串中<code>s[i]</code>表示第<code>i</code>分钟解决第<code>s[i]</code>题.<br>问题<code>A</code>需要<code>1</code>分钟解决,问题<code>B</code>需要<code>2</code>分钟解决,以此类推.</p><p>问:可以解决多少题?</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>遍历字符串,统计问题<code>A -- Z</code>用了多少时间解决.<br>最后在遍历数组,判断问题<code>A -- Z</code>是否满足解决时间.</p></blockquote><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: s)</span><br><span class="line">        a[i - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= i + <span class="number">1</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">    std::cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://codeforces.com/contest/1914/problem/B">Preparing for the Contest</a></h1><h2 id="题目描述-2">题目描述</h2><blockquote><p>给两个整数<code>n, k (0 &lt;= k &lt;= n - 1)</code><br>问:打印出<code>a[i + 1] &gt; a[i](0&lt;= i &lt; n - 1)</code>的次数等于<code>k</code>的方案.</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>打个比方:<br><code>n == 6, k == 2</code>, 我们有这样一个数组<code>[1, 2, 3, 4, 5, 6]</code><br>现在将数组重新排序,排序后要满足<code>a[i + 1] &gt; a[i](0&lt;= i &lt; n - 1)</code>的次数等于<code>k</code>.<br>我们可以将数组后面<code>k + 1</code>个数放在前面,即<code>[4, 5, 6, 1, 2, 3]</code><br>多举几个例子就可以发现上述规律.</p></blockquote><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1ll</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - k - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - k - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://codeforces.com/contest/1914/problem/C">Quests</a></h1><h2 id="题目描述-3">题目描述</h2><blockquote><p>有<code>n</code>个任务,每个任务完成后对应两个值<code>a[i]</code>和<code>b[i]</code>,首次完成第<code>i</code>个任务时,可获得<code>a[i]</code>分,若此后再完成该任务可获得<code>b[i]</code>分<br>问:现在,可以完成<code>k</code>个任务,可获得的最大分数是多少?</p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>枚举走到哪一个位置，然后记录前面的b[i]最大值</p></blockquote><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0ll</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cin &gt;&gt; b[i];</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, ma = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; std::<span class="built_in">min</span>(n, k); i++) &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">        ma = std::<span class="built_in">max</span>(ma, b[i]);</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, s + (k - i - <span class="number">1</span>) * ma);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D <a href="https://codeforces.com/contest/1914/problem/D">Three Activities</a></h1><h2 id="题目描述-4">题目描述</h2><blockquote><p>给出一个<code>n</code>,并且给出这<code>n</code>天参加三项活动的人数<code>a[i], b[i], c[i]</code>.</p><p>问:最多能有多少人参加这三项活动,并且参加这三项不在同一天.</p></blockquote><h2 id="解题思路-4">解题思路</h2><blockquote><p>我们只需要模拟一下,但是这个模拟需要优化一下.</p></blockquote><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]]<span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0ll</span>)</span>, <span class="title">b</span><span class="params">(n, <span class="number">0ll</span>)</span>, <span class="title">c</span><span class="params">(n, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)std::cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)std::cin &gt;&gt; c[i];</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(n, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), <span class="number">0ll</span>);</span><br><span class="line">    <span class="keyword">auto</span> y = x, z = x;</span><br><span class="line">    std::<span class="built_in">sort</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> aa, <span class="type">int</span> bb) &#123; <span class="keyword">return</span> a[aa] &gt; a[bb]; &#125;);</span><br><span class="line">    std::<span class="built_in">sort</span>(y.<span class="built_in">begin</span>(), y.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> aa, <span class="type">int</span> bb) &#123; <span class="keyword">return</span> b[aa] &gt; b[bb]; &#125;);</span><br><span class="line">    std::<span class="built_in">sort</span>(z.<span class="built_in">begin</span>(), z.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> aa, <span class="type">int</span> bb) &#123; <span class="keyword">return</span> c[aa] &gt; c[bb]; &#125;);</span><br><span class="line">    <span class="type">int</span> w = std::<span class="built_in">min</span>(&#123;n, <span class="number">100ll</span>&#125;), ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">                <span class="keyword">if</span> (x[i] != y[j] &amp;&amp; x[i] != z[k] &amp;&amp; y[j] != z[k])</span><br><span class="line">                    ans = std::<span class="built_in">max</span>(a[x[i]] + b[y[j]] + c[z[k]], ans);</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-round-916(A-D)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 914 (Div. 2)</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/8ff72993.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/8ff72993.html</id>
    <published>2024-08-08T15:36:20.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1904/problem/A">Forked!</a></h1><h2 id="题目大意">题目大意</h2><blockquote><p>给定王后和国王的位置, 马可以先朝一个方向走<code>a</code>步,再朝另一个方向走<code>b</code>步<br>问:马有多少个位置可以同时走到皇后和国王</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>就无脑遍历一下马能走到国王和皇后的位置<br>然后再判断下有没有相同的位置</p></blockquote><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x1, x2, y1, y2, a, b;</span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    std::set&lt;std::pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt;&gt; s1, s2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">insert</span>(&#123;x1+dx[i]*a, y1+dy[i]*b&#125;);</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">insert</span>(&#123;x1+dx[i]*b, y1+dy[i]*a&#125;);</span><br><span class="line">        s<span class="number">2.</span><span class="built_in">insert</span>(&#123;x2+dx[i]*a, y2+dy[i]*b&#125;);</span><br><span class="line">        s<span class="number">2.</span><span class="built_in">insert</span>(&#123;x2+dx[i]*b, y2+dy[i]*a&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : s1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s<span class="number">2.f</span>ind (i) != s<span class="number">2.</span><span class="built_in">end</span>())</span><br><span class="line">            cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://codeforces.com/contest/1904/problem/B">Collecting Game</a></h1><h2 id="题目大意-2">题目大意</h2><blockquote><p>给一个数组<code>a</code>,对于每一个元素,我们都会有一个初始值<code>w = a[i]  (0 &lt;= i &lt; n)</code>只要<code>w</code>大于或等于数组中的某个元素,<code>w = w + a[k]</code>并且就会把这个数删除掉.</p><p>问: 对于每个元素,至多可以删除多少元素?</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>由于需要最大化删除个数,我们可以先对数组升序排序,这样对于<code>i(0 &lt;= i &lt; n)</code> 就可以将<code>0 ~ i-1</code>的所有数删除掉,然后再考虑后面的.</p><p>就这样模拟下过程就完事儿了.</p></blockquote><h2 id="代码-2">代码</h2><p>(提交的一次TLE的代码)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    pii a[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cin &gt;&gt; a[i].first, a[i].second = i;</span><br><span class="line">    std::<span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            s[i] = a[i].first;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[i] = s[i - <span class="number">1</span>] + a[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = s[i], j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; t &gt;= a[j].first)</span><br><span class="line">            t += a[j++].first;</span><br><span class="line">        ans[i] = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        a[i].first = ans[i];</span><br><span class="line">    std::<span class="built_in">sort</span>(a, a + n, [&amp;](pii aa, pii bb) &#123;</span><br><span class="line">        <span class="keyword">return</span> aa.second &lt; bb.second;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        std::cout &lt;&lt; a[i].first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(AC代码)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">[[maybe_unused]] <span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    pii a[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i].first;</span><br><span class="line">        a[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n, <span class="number">0ll</span>)</span>, <span class="title">c</span><span class="params">(n, <span class="number">0ll</span>)</span>, <span class="title">d</span><span class="params">(n, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        b[i] = a[i].first;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            c[i] = b[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c[i] = c[i + <span class="number">1</span>] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = c[i];</span><br><span class="line">        <span class="type">int</span> k = t;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> w = std::<span class="built_in">upper_bound</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), t) - b.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (w == n) &#123;</span><br><span class="line">                d[a[i].second] = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c[w - <span class="number">1</span>] == k) &#123;</span><br><span class="line">                    d[a[i].second] = w - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    k = c[w - <span class="number">1</span>];</span><br><span class="line">                    t = c[w - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://codeforces.com/contest/1904/problem/C">Array Game</a></h1><h2 id="题目大意-3">题目大意</h2><blockquote><p>给一个数组<code>a</code>,有<code>k</code>次操作,每次操作选一个<code>(i, j) (0 &lt;= i &lt; j &lt; n)</code> ,将<code>|a[j] - a[i]|</code>放在数组的足以后方.</p><p>问:<code>k</code>次操作后得到的数组最小的数为多少?</p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>首先,可以考虑到<code>k&gt;=3</code>时,我们可以先选两次相同的<code>(i, j)</code>,然后再选新加入的这两个,这样就可以得到<code>0</code>了`</p><p>然后再是<code>k == 1</code>时, 我们想让答案最小化,我们只能先将数组排序,然后再找相邻的两个的的差值,再到最小值后,答案还不是最优值, 所以还要与原数组最小值比较.</p><p>最后, 再是 <code>k == 2</code>时, 题目中明确告诉<code>n^2 &lt; 4e6</code>,这就是让我们暴力循环,我们可以先将<code>k == 1</code>时的最小值记录下来,然后再暴力<code>n^2</code>跑一遍数组,再与之前的比较一下,最后输出答案.</p></blockquote><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        std::cin &gt;&gt; x;</span><br><span class="line">        a.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> calc = [&amp;]() &#123;<span class="comment">//相当于处理了一次</span></span><br><span class="line">        std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ans = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="type">int</span>) a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ans = std::<span class="built_in">min</span>(ans, a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">calc</span>();</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> w = a[j] - a[i];</span><br><span class="line">                <span class="type">int</span> p = std::<span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), w) - a.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">if</span> (p != n - <span class="number">1</span>)</span><br><span class="line">                    ans = std::<span class="built_in">min</span>(ans, a[p] - w);</span><br><span class="line">                <span class="keyword">if</span> (p != <span class="number">0</span>)</span><br><span class="line">                    ans = std::<span class="built_in">min</span>(ans, w - a[p - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-round-914(A-C)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces-Round-913-Div-3</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/a842e41b.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/a842e41b.html</id>
    <published>2024-08-07T09:11:13.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1907/problem/A">Rook</a></h1><h2 id="题目大意">题目大意</h2><blockquote><p>给一个国际象棋棋盘,有<code>t</code>次询问,每次询问给定一个棋子坐标<code>s</code> 例如 <code>d4</code>.</p><p>问: 输出这个棋子上下左右四个方向的坐标</p></blockquote><h2 id="解题思路">解题思路</h2><blockquote><p>两个<code>for</code>循环暴力求解</p></blockquote><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span> ; i ++)<span class="comment">//枚举当前列</span></span><br><span class="line">        <span class="keyword">if</span>(i != s[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            std::cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span> ; i ++)<span class="comment">//枚举当前行</span></span><br><span class="line">        <span class="keyword">if</span>(i + <span class="string">&#x27;a&#x27;</span> != s[<span class="number">0</span>])</span><br><span class="line">            std::cout &lt;&lt; (<span class="type">char</span>)(i + <span class="string">&#x27;a&#x27;</span>) &lt;&lt; s[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://codeforces.com/contest/1907/problem/B">YetnotherrokenKeoard</a></h1><h2 id="题目大意-2">题目大意</h2><blockquote><p>有<code>t</code>次询问,每次询问会给定一个字符串<code>s</code>,<br>我们要敲击键盘拼接出这个字符串,但是存在一些规则:</p><ol><li>每次敲击<code>b</code>就会将位于这个<code>b</code>左边存在小写字母,那么就将距离<code>b</code>最近的一个删除,</li><li>同理,当敲击大写字母时,就会删除这个<code>B</code>左边最近的一个大写字母.</li></ol><p>问: 最后会组成一个怎样的字符串.</p></blockquote><h2 id="解题思路-2">解题思路</h2><blockquote><p>这个题由于数据量比较大,就不要尝试双重循环去删除字符了<br>我们可以发现一个规律,我们只删除当前字符前大小写形式相同的字符,并且只能删除一次,而且<br>是删除距离最近的,<br>这就有点像堆栈(后进先出),那我们就可以用栈来模拟这个过程<br>我们可以给每个字符做个标记,即创建一个和字符串大小相同的bool数组<br>若为<code>b</code>或<code>B</code>或被删除的字符标记为<code>false</code>,否则为true</p></blockquote><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">f</span><span class="params">((<span class="type">int</span>) s.size(), <span class="literal">true</span>)</span></span>;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;b&#x27;</span> || s[i] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            f[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(s[i]) &amp;&amp; !b.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                f[b.<span class="built_in">top</span>()] = <span class="literal">false</span>;</span><br><span class="line">                b.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">islower</span>(s[i]) &amp;&amp; !a.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                f[a.<span class="built_in">top</span>()] = <span class="literal">false</span>;</span><br><span class="line">                a.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">islower</span>(s[i]))</span><br><span class="line">                a.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span> (!b.<span class="built_in">empty</span>())</span><br><span class="line">        b.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (f[i])</span><br><span class="line">            std::cout &lt;&lt; s[i];</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://codeforces.com/contest/1907/problem/C">Removal of Unattractive Pairs</a></h1><h2 id="题目描述">题目描述</h2><blockquote><p>有<code>t</code>次询问,每次询问给出一个长度为<code>n</code>的字符串,字符串两个字符不同则可以删除这两个字符<br>问: 字符串最短有多长.</p></blockquote><h2 id="解题思路-3">解题思路</h2><blockquote><p>用手玩玩就<code>ok</code></p></blockquote><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">26</span>, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">        a[i - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">    <span class="type">int</span> ma = *std::<span class="built_in">max_element</span>(a.<span class="built_in">begin</span> (), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(ma * <span class="number">2</span> &lt;= n)</span><br><span class="line">        std::cout &lt;&lt; n % <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        std::cout &lt;&lt; n - <span class="number">2</span> * (n - ma) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D <a href="https://codeforces.com/contest/1907/problem/C">Jumping Through Segments</a></h1><h2 id="题目描述-2">题目描述</h2><blockquote><p>有<code>t</code>次询问,每次询问会给<code>n</code>个<code>L, R</code>,其中第 <code>i</code> 段从坐标为<code>L[i]</code>的点开始,到坐标为<code>R[i]</code>的点结束。<br>玩家从坐标为 0 的点开始通关。在一次移动中，他们可以移动到距离不超过 k 的任意一点。<br>在第<code>i</code>次移动后，玩家必须落在第<code>i</code>段之内，即在坐标<code>x</code>处，使得 <code>L[i]≤x≤R[i]</code>。<br>这意味着,每次移动都必须在<code>L[i] ~ R[i]</code><br>如果玩家按照上述规则到达了第 <code>n</code>个段落，那么这一关就算完成了。<br>为了不希望这个关卡太简单，所以要求确定可以完成这个关卡的最小整数<code>k</code>。</p></blockquote><h2 id="解题思路-4">解题思路</h2><blockquote><p>核心思想就是<strong>二分答案</strong>.</p></blockquote><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n, <span class="number">0ll</span>)</span>, <span class="title">R</span><span class="params">(n, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">        std::cin &gt;&gt; L[i] &gt;&gt; R[i];</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e16</span> + <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;] (<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="type">int</span> ma = <span class="number">0</span>, mi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">            ma = std::<span class="built_in">min</span> (ma + x, INF);</span><br><span class="line">            mi = std::<span class="built_in">max</span> (mi - x, <span class="number">0ll</span>);</span><br><span class="line">            mi = std::<span class="built_in">max</span>(mi, L[i]);</span><br><span class="line">            ma = std::<span class="built_in">min</span>(ma, R[i]);</span><br><span class="line">            <span class="keyword">if</span>(mi &gt; ma)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span> (mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-round-913(A-D)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces-Round-912-Div-2</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/7932df39.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/7932df39.html</id>
    <published>2024-08-07T09:07:28.000Z</published>
    <updated>2025-08-22T02:37:23.080Z</updated>
    
    <content type="html"><![CDATA[<h1>A <a href="https://codeforces.com/contest/1903/problem/A">Halloumi Boxes</a></h1><h2 id="题目大意">题目大意</h2><blockquote><p>给定一个数组A,我们可以对数组惊醒多次操作,操作如下:<br>我们可以将数组中的某一段倒置,但是长度不能超过K,例如:反转子数组意味着选择两个索引i和j(其中 1 &lt;= i &lt;= j &lt;= n )<br>并将数组 $a_1,a_2,\cdots,a_n$ 改为 $a_1,a_2,\cdots,a_{i−1},a_{j},a_{j−1},\cdots,a_{i},a_{j+1},…,a_{n-1},a_n \quad (j − i + 1 \le k )$ 。</p></blockquote><h2 id="分析">分析</h2><blockquote><p>由于可以操作多次,那么我们可以判断下k是否为1:</p><ol><li>若k = 1时, 我们只能反转一个元素,显然是无效的, 我们就只需要判断数组是否为有序</li><li>若k &gt; 1时,显然是可行的</li></ol></blockquote><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">b</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++) </span><br><span class="line">        std::cin &gt;&gt; a[i], b[i] = a[i];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(b.<span class="built_in">begin</span> (), b.<span class="built_in">end</span> ());</span><br><span class="line">    <span class="type">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i])&#123;</span><br><span class="line">            f = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">1</span>)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B <a href="https://codeforces.com/contest/1903/problem/B">StORage room</a></h1><h2 id="题目大意-2">题目大意</h2><blockquote><p>给定一个数<code>n</code>,和一个<code>n*n</code>的数组<code>M</code>,数组$M_{i,j}$<br>表示为:$M_{i,j} = \begin{cases} a_i|a_j,(i \not= j)\\ 0, (i == j)\end{cases}(M_{i,j} &lt; 2 ^{30})$</p><p>让我们判断是否存在这样的一个数组a满足上式,若存在输出YES和数组a<br>否则输出NO</p></blockquote><h2 id="分析-2">分析</h2><blockquote><p>现在我有两个数<code>x, y</code>,如果我将这两个数进行或运算后<code>(w = x | y)</code>, 在二进制状态下<code>x</code>和<code>y</code>在某一位上有一个为<code>1</code>,则该位为<code>1</code>通过这个我们可以发现在$M_i$ 中,$M_{i,0} = a_i | a_0, M_{i,1} = a_i | a_1, …, M_{i,n - 1} = a_i | a_{n - 1}$ , 我们可以通过与运算将$a_i$<br>计算出来, 但是在运算时我们需要排除$M_{i,j}(i==j)$;<br>在计算完后我们可以遍历一次M数组,判断$M_{i,j}=a_i|a_j(i \not= j)$</p></blockquote><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">m</span>(n, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j ++)&#123;</span><br><span class="line">            std::cin &gt;&gt; m[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">-1</span>)</span><br><span class="line">                    x = m[i][j];</span><br><span class="line">                x &amp;= m[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;<span class="comment">//特殊情况,可任意输出一个数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;] ()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++)&#123;</span><br><span class="line">                <span class="type">int</span> x = a[i] | a[j];</span><br><span class="line">                <span class="keyword">if</span>(m[i][j] != x &amp;&amp; i != j)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">            std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C <a href="https://codeforces.com/contest/1903/problem/C">Theofanis’ Nightmare</a>(贪心)</h1><h2 id="题目大意-3">题目大意</h2><blockquote><p>给定一个数组<code>a</code>,大小为<code>n</code>,现在将数组<code>a</code>分割成几个非空子数组,并且保证每个元素只在一个一个子数组中,例如，数组 <code>[1,−3,7,−6,2,5]</code>可以划分为 <code>[1][−3,7][−6,2][5]</code>。<br>这种分割的值等于$\sum_{i=1}^k i*sum_i$<br>，其中<code>k</code>是我们将数组分割成的子数组的个数，$sum_i$<br>是第<code>i</code>个子数组的和。<br>这个数组的值为$[1][−3,7][−6,2][5]=1\times 1+2\times (−3+7)+3\times (−6+2)+4\times5=17$<br>现在让我们求分割的最大值为多少?</p></blockquote><h2 id="分析-3">分析</h2><blockquote><p>先考虑每个子段的数字贡献，i* sum_i也可以转化为该子段中每个数字被加上了i次。那么就可以把乘法转化为加法。</p><p>然后考虑怎么划分子段最优，如果从前往后考虑，很难判断是否该将当前数字划分为一个新子段的起点。<br>因此，需要从后往前遍历，统计i∼n之间的数字总和，为了使答案尽可能大，那么只要当前数字总和大于等于0，就可以将当前位置划分给一个新的子段起点。</p><p>此时，划分出一个新的起点后，那么后面所有的数字均需要再被加上一次，不难发现，此时要加上的就是维护的数字总和。</p><p>由于第一个元素也可能被划分到一个新的子段中，为了避免重复计算，当遍历到第一个元素时，必须将当前元素视为子段起点，加上维护的数字总和。</p></blockquote><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i --)&#123;</span><br><span class="line">        w += a[i];</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || w &gt; <span class="number">0</span>)</span><br><span class="line">            ans += w; </span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0ll</span>)</span>, <span class="title">s</span><span class="params">(n + <span class="number">1</span>, <span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++)</span><br><span class="line">        std::cin &gt;&gt; a[i], s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span> || s[n] - s[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) </span><br><span class="line">            w ++;</span><br><span class="line">        ans += w * a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy_ = <span class="number">1</span>;</span><br><span class="line">    std::cin &gt;&gt; Lazy_boy_;</span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy_--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D1 <a href="https://codeforces.com/contest/1903/problem/D1">Maximum And Queries (easy version)</a></h1><h2 id="题目大意-4">题目大意</h2><blockquote><p>给出一个长度为n的数组a，并进行q次询问，每次询问为：<br>你可以进行<code>k</code>次操作，每次从数组a中选择一个元素，让这个元素 <code>+ 1</code>。<br>问：经过<code>q</code>次操作后,$a_1,a_2,…,a_n$的与的最大值是多少<br>注：每次询问都是独立的，不会保留前面询问的操作结果。</p></blockquote><h2 id="分析-4">分析</h2><blockquote><p>由于每次询问都是独立的，那么修改不能在原数组上进行，需要将原数组元素复制到其他数组中再进行操作。<br>题目数据规定了$n\times q≤10^5$，那么可以认为最大的数据就是对长度为$10^5$的数组进行一次询问。由于给出的$k≤10^{18}$ ，那么当数组中只有一个元素时，最大可能的结果为$10^{18}+10^6≈2^{60}$<br>，因此需要一个大于<code>60</code>的数组记录与运算后的结果每位二进制数是多少。<br>对于每次询问，从二进制高位开始往低位进行遍历，每次检查当前剩余的k是否还能将数组中所有数的当前二进制位修改为1<br>如果可以，进行修改，并记录在答案数组中，如果不行，继续遍历更低的二进制位。<br>结束修改后，将数组中记录的信息转化为十进制数即可。</p><p><strong>本题数据较大，需要注意使用左移运算需要使用1ll将1转化为long long类型再进行运算，计算花费时也要考虑如果超过操作次数就该退出检查，避免数据溢出。</strong></p></blockquote><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N], ans[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCost</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((b[j] &amp; (<span class="number">1ll</span> &lt;&lt; x)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//使用位运算计算将b[j]的第x位二进制修改为1需要加上多少</span></span><br><span class="line">            cost += (<span class="number">1ll</span> &lt;&lt; x) - ((<span class="number">1ll</span> &lt;&lt; (x + <span class="number">1</span>)) - <span class="number">1ll</span> &amp; b[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cost &gt; k) <span class="keyword">return</span> cost; <span class="comment">//超过k就返回，避免数据溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">while</span>(q --)&#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        std::cin &gt;&gt; k;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">60</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//检查第i位结果与运算的结果是否可能为1</span></span><br><span class="line">            <span class="type">int</span> cost = <span class="built_in">getCost</span>(i, k);</span><br><span class="line">            <span class="keyword">if</span> (cost &lt;= k) &#123;<span class="comment">//花费在操作次数范围内</span></span><br><span class="line">                ans[i] = <span class="number">1</span>;<span class="comment">//与运算结果可以为1</span></span><br><span class="line">                k -= cost;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((b[j] &amp; (<span class="number">1ll</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//通过或运算将2^i位修改为1，再通过与运算将后面数字清0</span></span><br><span class="line">                        b[j] = ((b[j] | (<span class="number">1ll</span> &lt;&lt; i)) &amp; (<span class="number">1ll</span> &lt;&lt; i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">60</span>; i++)</span><br><span class="line">            res |= (ans[i] &lt;&lt; i);<span class="comment">//这里ans[i]如果不是long long类型也会发生溢出</span></span><br><span class="line">        std::cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>), std::cout.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> Lazy_boy = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; Lazy_boy;</span></span><br><span class="line">    <span class="keyword">while</span> (Lazy_boy--)</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces-round-912(A-D1)</summary>
    
    
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/categories/codeforces/"/>
    
    
    <category term="题解" scheme="https://blog.lazy-boy-acmer.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://blog.lazy-boy-acmer.cn/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>小新pro14使用体验</title>
    <link href="https://blog.lazy-boy-acmer.cn/posts/da1743b8.html"/>
    <id>https://blog.lazy-boy-acmer.cn/posts/da1743b8.html</id>
    <published>2022-08-25T09:49:01.000Z</published>
    <updated>2025-08-22T02:37:23.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人体验：适合办公，娱乐。对于要跑些测试那可以放弃掉了，毕竟是轻薄本，性能没有游戏本性能好。</p></blockquote><p>我这是22年8月优惠下买的小新pro14 16G + 512G（14寸）</p><h1>重量</h1><p>对于我来说，这重量就和两本书的重量没多大区别，当时购买就是奔着这重量去的，谁也不想天天带着砖块去上课或上班吧<br><img src="https://th.bing.com/th/id/R.2f0a176a7a9286fee6d2dd1d4eeddfcc?rik=8siUTWRJo7NZFg&amp;riu=http%3a%2f%2fi0.hdslb.com%2fbfs%2farchive%2ff00aa1158ed904c85ccbc05804910b9b8d8b604d.jpg&amp;ehk=lrR7ed09T4BJORoHGaHj7Bsgxhq1rLJnnKDePwHh0Gs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="img1"></p><h1>续航</h1><p>续航方面的话，满电量中度使用是可以使用一天的🥱，若条件允许，使用时还是插上电源。<br><img src="https://img2cdn.clubstatic.lenovo.com.cn/pic/32790989959080/600" alt="img2"></p><h1>系统</h1><p>系统被我重装为专业工作站版</p><table><thead><tr><th>配置项</th><th>详情</th></tr></thead><tbody><tr><td>型号</td><td>联想小新 Pro 14 2021 锐龙版</td></tr><tr><td>处理器</td><td>AMD Ryzen 5 5600H</td></tr><tr><td>显卡</td><td>集成显卡：AMD Radeon Graphics</td></tr><tr><td>内存</td><td>16GB DDR4 3200MHz（双通道，板载）</td></tr><tr><td>存储</td><td>512GB NVMe PCIe SSD</td></tr><tr><td>显示屏</td><td>14 英寸 IPS 屏幕，分辨率 2240x1400（2.2K），100% sRGB 色域</td></tr><tr><td>刷新率</td><td>90Hz</td></tr><tr><td>电池</td><td>56.5Wh</td></tr><tr><td>充电</td><td>65W Type-C 快充</td></tr><tr><td>接口</td><td>2 x USB-C（支持充电和数据传输），1 x USB-A，1 x 3.5mm 耳机接口</td></tr><tr><td>无线网络</td><td>Wi-Fi 6（802.11ax），蓝牙 5.1</td></tr><tr><td>操作系统</td><td>Windows 11 专业工作站版</td></tr><tr><td>重量</td><td>约 1.4kg</td></tr><tr><td>厚度</td><td>约 16.9mm</td></tr><tr><td>颜色</td><td>深空灰</td></tr><tr><td>其他特性</td><td>背光键盘，双扬声器，杜比音效</td></tr></tbody></table><h1>另外</h1><blockquote><p>感觉被恨恨的背刺了</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="分享" scheme="https://blog.lazy-boy-acmer.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="生产力" scheme="https://blog.lazy-boy-acmer.cn/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
    <category term="分享" scheme="https://blog.lazy-boy-acmer.cn/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="生活" scheme="https://blog.lazy-boy-acmer.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
